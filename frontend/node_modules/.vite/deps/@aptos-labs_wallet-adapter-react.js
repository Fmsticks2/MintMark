import {
  W as W2,
  getWallets,
  h as h2,
  require_buffer
} from "./chunk-QM2BRSBP.js";
import {
  HexString,
  aptos_types_exports,
  bcs_exports,
  generated_exports,
  require_nacl_fast
} from "./chunk-4XT743C4.js";
import {
  Ae,
  AxiosError,
  B,
  Dt,
  E5 as E,
  Gn,
  Gt,
  O4 as O,
  Se,
  U4 as U,
  Ur,
  V,
  W3 as W,
  Wn,
  _e,
  a,
  a3 as a2,
  axios_default,
  e,
  f4 as f,
  h3 as h,
  isAxiosError,
  jwtDecode,
  k2 as k,
  l2 as l,
  me,
  n,
  o5 as o,
  ot,
  pa,
  pe,
  qs,
  r5 as r,
  s4 as s,
  sha3_256,
  t4 as t,
  ut,
  v3 as v,
  z2 as z
} from "./chunk-IRGIHQLX.js";
import "./chunk-5GFRP27I.js";
import "./chunk-7XVSFMII.js";
import {
  Slot
} from "./chunk-X75TN4WQ.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee = new Array(l3); i4 < l3; i4++) {
        ee[i4] = handlers[i4].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a22);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events.push(listeners[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f3) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f3(require_nacl_fast());
      else root.ed2curve = f3(root.nacl);
    })(exports, function(nacl4) {
      "use strict";
      if (!nacl4) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i4, r9 = new Float64Array(16);
        if (init) for (i4 = 0; i4 < init.length; i4++) r9[i4] = init[i4];
        return r9;
      };
      var gf0 = gf(), gf1 = gf([1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o16) {
        var c;
        var i4;
        for (i4 = 0; i4 < 16; i4++) {
          o16[i4] += 65536;
          c = Math.floor(o16[i4] / 65536);
          o16[(i4 + 1) * (i4 < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i4 === 15 ? 1 : 0);
          o16[i4] -= c * 65536;
        }
      }
      function sel25519(p4, q, b2) {
        var t11, c = ~(b2 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t11 = c & (p4[i4] ^ q[i4]);
          p4[i4] ^= t11;
          q[i4] ^= t11;
        }
      }
      function unpack25519(o16, n15) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o16[i4] = n15[2 * i4] + (n15[2 * i4 + 1] << 8);
        o16[15] &= 32767;
      }
      function A4(o16, a3, b2) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o16[i4] = a3[i4] + b2[i4] | 0;
      }
      function Z2(o16, a3, b2) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o16[i4] = a3[i4] - b2[i4] | 0;
      }
      function M(o16, a3, b2) {
        var i4, j, t11 = new Float64Array(31);
        for (i4 = 0; i4 < 31; i4++) t11[i4] = 0;
        for (i4 = 0; i4 < 16; i4++) {
          for (j = 0; j < 16; j++) {
            t11[i4 + j] += a3[i4] * b2[j];
          }
        }
        for (i4 = 0; i4 < 15; i4++) {
          t11[i4] += 38 * t11[i4 + 16];
        }
        for (i4 = 0; i4 < 16; i4++) o16[i4] = t11[i4];
        car25519(o16);
        car25519(o16);
      }
      function S(o16, a3) {
        M(o16, a3, a3);
      }
      function inv25519(o16, i4) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i4[a3];
        for (a3 = 253; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 2 && a3 !== 4) M(c, c, i4);
        }
        for (a3 = 0; a3 < 16; a3++) o16[a3] = c[a3];
      }
      function pack25519(o16, n15) {
        var i4, j, b2;
        var m = gf(), t11 = gf();
        for (i4 = 0; i4 < 16; i4++) t11[i4] = n15[i4];
        car25519(t11);
        car25519(t11);
        car25519(t11);
        for (j = 0; j < 2; j++) {
          m[0] = t11[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m[i4] = t11[i4] - 65535 - (m[i4 - 1] >> 16 & 1);
            m[i4 - 1] &= 65535;
          }
          m[15] = t11[15] - 32767 - (m[14] >> 16 & 1);
          b2 = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t11, m, 1 - b2);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o16[2 * i4] = t11[i4] & 255;
          o16[2 * i4 + 1] = t11[i4] >> 8;
        }
      }
      function par25519(a3) {
        var d8 = new Uint8Array(32);
        pack25519(d8, a3);
        return d8[0] & 1;
      }
      function vn(x, xi, y2, yi, n15) {
        var i4, d8 = 0;
        for (i4 = 0; i4 < n15; i4++) d8 |= x[xi + i4] ^ y2[yi + i4];
        return (1 & d8 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x, xi, y2, yi) {
        return vn(x, xi, y2, yi, 32);
      }
      function neq25519(a3, b2) {
        var c = new Uint8Array(32), d8 = new Uint8Array(32);
        pack25519(c, a3);
        pack25519(d8, b2);
        return crypto_verify_32(c, 0, d8, 0);
      }
      function pow2523(o16, i4) {
        var c = gf();
        var a3;
        for (a3 = 0; a3 < 16; a3++) c[a3] = i4[a3];
        for (a3 = 250; a3 >= 0; a3--) {
          S(c, c);
          if (a3 !== 1) M(c, c, i4);
        }
        for (a3 = 0; a3 < 16; a3++) o16[a3] = c[a3];
      }
      function set25519(r9, a3) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r9[i4] = a3[i4] | 0;
      }
      function unpackneg(r9, p4) {
        var t11 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r9[2], gf1);
        unpack25519(r9[1], p4);
        S(num, r9[1]);
        M(den, num, D);
        Z2(num, num, r9[2]);
        A4(den, r9[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t11, den6, num);
        M(t11, t11, den);
        pow2523(t11, t11);
        M(t11, t11, num);
        M(t11, t11, den);
        M(t11, t11, den);
        M(r9[0], t11, den);
        S(chk, r9[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r9[0], r9[0], I2);
        S(chk, r9[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r9[0]) === p4[31] >> 7) Z2(r9[0], gf0, r9[0]);
        M(r9[3], r9[0], r9[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z2 = new Uint8Array(32), q = [gf(), gf(), gf(), gf()], a3 = gf(), b2 = gf();
        if (unpackneg(q, pk)) return null;
        var y2 = q[1];
        A4(a3, gf1, y2);
        Z2(b2, gf1, y2);
        inv25519(b2, b2);
        M(a3, a3, b2);
        pack25519(z2, a3);
        return z2;
      }
      function convertSecretKey(sk) {
        var d8 = new Uint8Array(64), o16 = new Uint8Array(32), i4;
        nacl4.lowlevel.crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        for (i4 = 0; i4 < 32; i4++) o16[i4] = d8[i4];
        for (i4 = 0; i4 < 64; i4++) d8[i4] = 0;
        return o16;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/@wallet-standard/errors/lib/esm/codes.js
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834e3;
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001;
var WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001e3;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 616e4;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002;

// node_modules/@wallet-standard/errors/lib/esm/messages.js
var WalletStandardErrorMessages = {
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]: "The wallet account $address does not support the chain `$chain`",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]: "The wallet account $address does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]: "The wallet '$walletName' does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]: "No account with address $address could be found in the '$walletName' wallet",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]: "No underlying Wallet Standard wallet could be found for this handle. This can happen if the wallet associated with the handle has been unregistered.",
  [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: "The user rejected the request"
};

// node_modules/@wallet-standard/errors/lib/esm/message-formatter.js
var StateType;
(function(StateType2) {
  StateType2[StateType2["EscapeSequence"] = 0] = "EscapeSequence";
  StateType2[StateType2["Text"] = 1] = "Text";
  StateType2[StateType2["Variable"] = 2] = "Variable";
})(StateType || (StateType = {}));

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n2 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i(t11, e14 = []) {
  return [...n2, ...e14].every((s5) => s5 in t11.features);
}
function d() {
  let { get: t11, on: e14 } = getWallets(), s5 = t11(), a3 = [];
  return s5.map((l3) => {
    i(l3) && a3.push(l3);
  }), { aptosWallets: a3, on: e14 };
}

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o2 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(o2 || {});
var r2 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r3 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r3 || {});

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-PFWJQYHN.mjs
var n6 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-VGZKKC3H.mjs
var n7 = "aptos:signIn";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e6 = "aptos:signMessage";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-DIMEBT3E.mjs
var n8 = "aptos:signTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o6 = "aptos:connect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o7 = "aptos:disconnect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t5 = "aptos:account";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t6 = "aptos:network";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n9 = "aptos:onAccountChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e7 = "aptos:onNetworkChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d3 = class o8 extends B {
  constructor({ address: e14, publicKey: n15, ansName: t11 }) {
    super();
    this.address = l.from(e14), this.publicKey = n15, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof f) e14.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e14.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e14.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e14.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n15 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s5;
    switch (t11) {
      case E.Ed25519:
        s5 = f.deserialize(e14);
        break;
      case E.MultiEd25519:
        s5 = Dt.deserialize(e14);
        break;
      case E.SingleKey:
        s5 = k.deserialize(e14);
        break;
      case E.MultiKey:
        s5 = Se.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b2 = e14.deserializeStr() || void 0;
    return new o8({ address: n15, publicKey: s5, ansName: b2 });
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t7 = "aptos:devnet";
var o9 = "aptos:testnet";
var A2 = "aptos:localnet";
var T2 = "aptos:mainnet";
var e8 = [t7, o9, A2, T2];

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o10 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(o10 || {});
var r4 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });
var s3 = class n10 extends Error {
  constructor(t11, e14) {
    var _a, _b;
    super(e14 ?? ((_a = r4[t11]) == null ? void 0 : _a.message) ?? "Unknown error occurred");
    this.code = t11, this.status = ((_b = r4[t11]) == null ? void 0 : _b.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, n10.prototype);
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r5 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r5 || {});

// node_modules/@identity-connect/crypto/dist/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d5 = class o11 extends B {
  constructor({ address: e14, publicKey: n15, ansName: t11 }) {
    super();
    this.address = l.from(e14), this.publicKey = n15, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof f) e14.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e14.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e14.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e14.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n15 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s5;
    switch (t11) {
      case E.Ed25519:
        s5 = f.deserialize(e14);
        break;
      case E.MultiEd25519:
        s5 = Dt.deserialize(e14);
        break;
      case E.SingleKey:
        s5 = k.deserialize(e14);
        break;
      case E.MultiKey:
        s5 = Se.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b2 = e14.deserializeStr() || void 0;
    return new o11({ address: n15, publicKey: s5, ansName: b2 });
  }
};

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o12 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(o12 || {});
var r6 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r7 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r7 || {});

// node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m) => m.charCodeAt(0));
}
function bytesToBase64(bytes) {
  const binaryString = String.fromCharCode(...bytes);
  return btoa(binaryString);
}
function bytesToBase64url(bytes) {
  return bytesToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function chainIdToNetwork(chainId) {
  switch (chainId) {
    case r.mainnet:
      return e.MAINNET;
    case r.testnet:
      return e.TESTNET;
    default:
      return e.DEVNET;
  }
}
function isSupportedNetwork(network) {
  return [e.MAINNET, e.TESTNET, e.DEVNET].includes(network);
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(l);
  const authenticator = deserializer.deserialize(V);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof f) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof Dt) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof k) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else if (value instanceof Se) {
    serializer.serializeU32AsUleb128(E.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(f);
    case E.MultiEd25519:
      return deserializer.deserialize(Dt);
    case E.SingleKey:
      return deserializer.deserialize(k);
    case E.MultiKey:
      return deserializer.deserialize(Se);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(l);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(l);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i4 = 0; i4 < length; i4 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(l);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes = deserializer.deserializeBytes();
      return new t(bytes);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeSignature(serializer, value) {
  if (value instanceof h) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof _e) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof O) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(h);
    case E.MultiEd25519:
      return deserializer.deserialize(_e);
    case E.SingleKey:
      return deserializer.deserialize(O);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? Ae(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i4 = 0; i4 < typeArgumentsLength; i4 += 1) {
    const typeTag = deserializer.deserialize(U);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = l.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = a.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(l);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
        const argument = qs(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeWalletRequest({
  dappInfo,
  name,
  version: version2
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequest({
  data,
  name,
  version: version2
}) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version: version2 };
}
function serializeWalletRequestWithArgs({ args, dappInfo, name, version: version2 }, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequestWithArgs({ data, name, version: version2 }, deserializeArgsFn) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version: version2 };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2, 3, 4];
  ConnectRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
    serializer.serializeOptionStr(value.preferredWalletName);
    serializer.serializeBool(value.claimOptions !== void 0);
    if (value.claimOptions) {
      serializer.serialize(value.claimOptions.secretKey);
      serializer.serializeStr(value.claimOptions.network);
      serializer.serializeOptionStr(value.claimOptions.asset);
      if (!isSupportedNetwork(value.claimOptions.network)) {
        throw new Error(`Unsupported network '${value.claimOptions.network}'`);
      }
    }
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    if (version2 === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOption("string");
    const dappEd25519PublicKeyB64 = deserializer.deserializeOption("string");
    const preferredWalletName = version2 >= 3 ? deserializer.deserializeOption("string") : void 0;
    const hasClaimOptions = version2 >= 4 ? deserializer.deserializeBool() : false;
    let claimOptions;
    if (hasClaimOptions) {
      const secretKey = deserializer.deserialize(z);
      const network = deserializer.deserializeStr();
      const asset = deserializer.deserializeOption("string");
      if (!isSupportedNetwork(network)) {
        throw new Error(`Unsupported network '${network}'`);
      }
      claimOptions = { asset, network, secretKey };
    }
    return { claimOptions, dappEd25519PublicKeyB64, dappId, preferredWalletName };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion }, serializeArgs);
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequestWithArgs(request2, (d8) => deserializeArgs(d8, request2.version));
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request2.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new a2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0);
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOption("string");
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, version2 = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(args, version2 === 1 ? serializeArgsV1 : serializeArgs);
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === DisconnectRequest2.name && request2.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
function serializeAptosSignInInput(serializer, value) {
  serializer.serializeStr(JSON.stringify(value));
}
function deserializeAptosSignInInput(deserializer) {
  return JSON.parse(deserializer.deserializeStr());
}
var SignInRequest;
((SignInRequest2) => {
  SignInRequest2.name = "signIn";
  SignInRequest2.supportedVersions = [1];
  SignInRequest2.currentVersion = 1;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}' in SignInRequest.serializeArgs`);
    }
    serializeAptosSignInInput(serializer, value);
    serializer.serializeStr(value.network);
  }
  SignInRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, _2) {
    return { ...deserializeAptosSignInInput(deserializer), network: deserializer.deserializeStr() };
  }
  SignInRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: SignInRequest2.name, version: SignInRequest2.currentVersion }, serializeArgs);
  }
  SignInRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequestWithArgs(request2, (d8) => deserializeArgs(d8, request2.version));
  }
  SignInRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignInRequest2.name && SignInRequest2.supportedVersions.includes(request2.version);
  }
  SignInRequest2.isSerialized = isSerialized;
})(SignInRequest || (SignInRequest = {}));
function serializeAptosSignInOutput(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializer.serializeStr(value.plainText);
  serializeSignature(serializer, value.signature);
  serializer.serializeBytes(value.signingMessage);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutput(deserializer) {
  return {
    account: new d5(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    plainText: deserializer.deserializeStr(),
    signature: deserializeSignature(deserializer),
    signingMessage: deserializer.deserializeBytes(),
    type: deserializer.deserializeStr()
  };
}
var SignInResponse;
((SignInResponse2) => {
  SignInResponse2.supportedVersions = [1];
  SignInResponse2.currentVersion = 1;
  function serializeApprovalArgs(serializer, value) {
    serializeAptosSignInOutput(serializer, value);
  }
  function deserializeApprovalArgs(deserializer) {
    return deserializeAptosSignInOutput(deserializer);
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, _2 = SignInResponse2.currentVersion) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignInResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignInResponse2.deserialize = deserialize;
})(SignInResponse || (SignInResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === GetConnectedAccountsRequest2.name && request2.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i4 = 0; i4 < length; i4 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request2) {
    return deserializeWalletRequest(request2);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === IsConnectedRequest2.name && request2.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3];
  SignAndSubmitTransactionRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version2 === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request2.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(serializedRequest, (d8) => deserializeArgs(d8, serializedRequest.version));
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignMessageRequest2.name && request2.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3, 4];
  SignTransactionRequest2.currentVersion = 4;
  function normalizeArgs(args) {
    const { feePayer, secondarySigners, senderPublicKey, signerAddress, transaction } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const isPayloadBcsSerializable = version2 < 4 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i4 = 0; i4 < secondarySignersLength; i4 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request2 = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request2, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request2) {
    return request2.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request2.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(V);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(pe) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return (message == null ? void 0 : message.__messageType) === messageCls.TYPE;
}
var _PromptConnectionRequestMessage = class _PromptConnectionRequestMessage2 {
  constructor() {
    this.__messageType = _PromptConnectionRequestMessage2.TYPE;
  }
};
_PromptConnectionRequestMessage.TYPE = "PromptConnectionRequest";
var PromptConnectionRequestMessage = _PromptConnectionRequestMessage;
var _PromptConnectionResponseMessage = class _PromptConnectionResponseMessage2 {
  constructor(serializedRequest) {
    this.serializedRequest = serializedRequest;
    this.__messageType = _PromptConnectionResponseMessage2.TYPE;
  }
};
_PromptConnectionResponseMessage.TYPE = "PromptConnectionResponse";
var PromptConnectionResponseMessage = _PromptConnectionResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function encodeWalletRequestBody({ data, ...rest }) {
  const serialized = JSON.stringify({ data, ...rest }, (key, value) => key === "data" ? bytesToBase64(value) : value);
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64(utf8Encoded);
}
function encodePopupWalletRequest(request2) {
  const serialized = JSON.stringify(request2, (key, value) => {
    switch (key) {
      case "body":
        return encodeWalletRequestBody(value);
      case "clientIdentityKey":
        return bytesToBase64(value.toUint8Array());
      case "signature":
        return bytesToBase64(value.toUint8Array());
      default:
        return value;
    }
  });
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64url(utf8Encoded);
}
function makePopupWalletRequestChallenge({
  accountAddress,
  body,
  id,
  timestamp
}) {
  const serializer = new n();
  serializer.serializeStr("SignedPopupWalletRequest");
  serializer.serializeStr(id);
  serializer.serializeU64(timestamp);
  serializer.serializeBool(accountAddress !== void 0);
  if (accountAddress !== void 0) {
    serializer.serialize(l.from(accountAddress));
  }
  serializer.serializeStr(body.name);
  serializer.serializeU8(body.version);
  serializer.serializeBytes(body.data);
  return serializer.toUint8Array();
}

// node_modules/@identity-connect/crypto/dist/index.mjs
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl2.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl2.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m) => m.codePointAt(0));
}
function encodeBase64(bytes) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes).toString("base64");
  }
  return btoa(Array.from(bytes, (x) => String.fromCodePoint(x)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(ed25519PublicKey.key.slice(0, 32));
  if (!x25519PublicKey)
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(ed25519SecretKey.key.slice(0, 32));
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl.default.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e14) {
    throw new DecryptionError(`Could not decrypt message: ${e14.message}`);
  }
  if (!decryptedUint8)
    throw new DecryptionError("Could not decrypt message");
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);
  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));
  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl.default.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter((x) => Object.keys(publicMessage).includes(x));
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key));
  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key));
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);
  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, "SECURED_ENVELOPE");
  return a.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new h(a.fromHexInput(messageSignatureInput).toUint8Array());
  const senderPublicKey = new f(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, "SECURED_ENVELOPE");
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError("Could not verify SecuredEnvelope signature", "messageSignature");
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new a2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new f(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/@telegram-apps/bridge/dist/index.js
var d7 = class _d extends Error {
  constructor(t11, r9, n15) {
    super(
      typeof r9 == "object" ? r9.message : r9 || t11,
      {
        cause: typeof r9 == "object" ? r9.cause : n15
      }
    ), this.type = t11, this.name = "TypedError", Object.setPrototypeOf(this, _d.prototype);
  }
};
function we(e14) {
  return e14.replace(/_[a-z]/g, (t11) => t11[1].toUpperCase());
}
var he = "ERR_INVALID_VALUE";
var me2 = "ERR_UNEXPECTED_VALUE";
var de = "ERR_UNEXPECTED_TYPE";
var K = "ERR_PARSE";
function V2(e14, t11) {
  const r9 = {};
  for (const n15 in e14) {
    const o16 = e14[n15];
    if (!o16)
      continue;
    let s5, a3;
    typeof o16 == "function" ? (s5 = n15, a3 = o16) : [s5, a3] = o16;
    try {
      const c = a3(t11(s5));
      c !== void 0 && (r9[n15] = c);
    } catch (c) {
      throw new d7(
        K,
        `Parser for "${n15}" property failed${s5 === n15 ? "" : `. Source field: "${s5}"`}`,
        c
      );
    }
  }
  return r9;
}
function Z(e14) {
  let t11 = e14;
  if (typeof t11 == "string")
    try {
      t11 = JSON.parse(t11);
    } catch (r9) {
      throw new d7(he, { cause: r9 });
    }
  if (typeof t11 != "object" || !t11 || Array.isArray(t11))
    throw new d7(me2);
  return t11;
}
function g(e14, t11) {
  return (r9) => {
    const n15 = (o16) => {
      if (!(r9 && o16 === void 0))
        try {
          return t11(o16);
        } catch (s5) {
          throw new d7(K, {
            message: `"${e14}" transformer failed to parse the value`,
            cause: s5
          });
        }
    };
    return Object.assign(
      n15,
      {
        isValid(o16) {
          try {
            return n15(o16), true;
          } catch {
            return false;
          }
        }
      }
    );
  };
}
function l2(e14, t11) {
  return g(t11 || "object", (r9) => {
    const n15 = Z(r9);
    return V2(e14, (o16) => n15[o16]);
  });
}
function R(e14) {
  throw new d7(de, `Unexpected value received: ${JSON.stringify(e14)}`);
}
var $ = g("boolean", (e14) => {
  if (typeof e14 == "boolean")
    return e14;
  const t11 = String(e14);
  if (t11 === "1" || t11 === "true")
    return true;
  if (t11 === "0" || t11 === "false")
    return false;
  R(e14);
});
var _ = g("string", (e14) => {
  if (typeof e14 == "string" || typeof e14 == "number")
    return e14.toString();
  R(e14);
});
var P = g("number", (e14) => {
  if (typeof e14 == "number")
    return e14;
  if (typeof e14 == "string") {
    const t11 = Number(e14);
    if (!Number.isNaN(t11))
      return t11;
  }
  R(e14);
});
var Ee = g("date", (e14) => e14 instanceof Date ? e14 : new Date(P()(e14) * 1e3));
function ve(e14) {
  return /^#[\da-f]{6}$/i.test(e14);
}
function Pe(e14) {
  return /^#[\da-f]{3}$/i.test(e14);
}
function Re(e14) {
  const t11 = e14.replace(/\s/g, "").toLowerCase();
  if (ve(t11))
    return t11;
  if (Pe(t11)) {
    let n15 = "#";
    for (let o16 = 0; o16 < 3; o16 += 1)
      n15 += t11[1 + o16].repeat(2);
    return n15;
  }
  const r9 = t11.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t11.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!r9)
    throw new Error(`Value "${e14}" does not satisfy any of known RGB formats.`);
  return r9.slice(1).reduce((n15, o16) => {
    const s5 = parseInt(o16, 10).toString(16);
    return n15 + (s5.length === 1 ? "0" : "") + s5;
  }, "#");
}
var Te = g("rgb", (e14) => Re(_()(e14)));
var I = g(
  "themeParams",
  (e14) => {
    const t11 = Te(true);
    return Object.entries(Z(e14)).reduce((r9, [n15, o16]) => (r9[we(n15)] = t11(o16), r9), {});
  }
);
var X = l2({
  eventType: _(),
  eventData: (e14) => e14
}, "miniAppsMessage");
var Y = g("fn", (e14) => {
  if (typeof e14 == "function")
    return e14;
  R(e14);
});
var Ce = l2({
  TelegramWebviewProxy: l2({ postEvent: Y() })()
});
function Q(e14) {
  return Ce().isValid(e14);
}
function Ne() {
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}
var b = class _b extends Error {
  constructor(t11, r9, n15) {
    super(
      typeof r9 == "object" ? r9.message : r9 || t11,
      {
        cause: typeof r9 == "object" ? r9.cause : n15
      }
    ), this.type = t11, this.name = "TypedError", Object.setPrototypeOf(this, _b.prototype);
  }
};
function Ue(e14, t11) {
  return e14 instanceof b && e14.type === t11;
}
function L(e14) {
  return (t11) => Ue(t11, e14);
}
var re = "ERR_ABORTED";
var ne = "ERR_CANCELED";
var oe = "ERR_TIMED_OUT";
var nt = L(oe);
var ot2 = L(re);
var st = L(ne);
function ke(e14, t11) {
  t11 || (t11 = {});
  const {
    textColor: r9,
    bgColor: n15,
    shouldLog: o16 = true
  } = t11;
  function s5(a3, ...c) {
    if (!o16 || typeof o16 == "function" && !o16())
      return;
    const i4 = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a3](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${e14}`,
      `${i4};background-color: lightblue;color:black`,
      "",
      `${i4};${r9 ? `color:${r9};` : ""}${n15 ? `background-color:${n15}` : ""}`,
      ...c
    );
  }
  return [
    function(...a3) {
      s5("log", ...a3);
    },
    function(...a3) {
      s5("error", ...a3);
    }
  ];
}
function Le(e14, t11) {
  t11();
}
function y(e14, t11) {
  t11 || (t11 = {});
  const r9 = t11.equals || Object.is;
  let n15 = [], o16 = e14;
  const s5 = (u) => {
    if (!r9(o16, u)) {
      const f3 = o16;
      o16 = u, Le(i4, () => {
        [...n15].forEach(([h3, m]) => {
          h3(u, f3), m && c(h3, true);
        });
      });
    }
  };
  function a3(u) {
    const f3 = typeof u != "object" ? { once: u } : u;
    return {
      once: f3.once || false,
      signal: f3.signal || false
    };
  }
  const c = (u, f3) => {
    const h3 = a3(f3), m = n15.findIndex(([T4, A4]) => T4 === u && A4.once === h3.once && A4.signal === h3.signal);
    m >= 0 && n15.splice(m, 1);
  }, i4 = Object.assign(
    function() {
      return Oe(i4), o16;
    },
    {
      destroy() {
        n15 = [];
      },
      set: s5,
      reset() {
        s5(e14);
      },
      sub(u, f3) {
        return n15.push([u, a3(f3)]), () => c(u, f3);
      },
      unsub: c,
      unsubAll() {
        n15 = n15.filter((u) => u[1].signal);
      }
    }
  );
  return i4;
}
var U2 = [];
function Oe(e14) {
  U2.length && U2[U2.length - 1].add(e14);
}
var ae = y(false);
var [O2, qe] = ke("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: ae
});
var Ie = {
  clipboard_text_received: l2({
    req_id: _(),
    data: (e14) => e14 === null ? e14 : _(true)(e14)
  }, "clipboard_text_received"),
  custom_method_invoked: l2({
    req_id: _(),
    result: (e14) => e14,
    error: _(true)
  }, "custom_method_invoked"),
  popup_closed: g("popup_closed", (e14) => e14 ? l2({
    button_id: (t11) => t11 == null ? void 0 : _()(t11)
  })()(e14) : {}),
  viewport_changed: l2({
    height: P(),
    width: (e14) => e14 == null ? window.innerWidth : P()(e14),
    is_state_stable: $(),
    is_expanded: $()
  }, "viewport_changed")
};
var C = y();
var N = y();
var v2 = y({});
var Ge = "ERR_UNKNOWN_ENV";
var ue = y("https://web.telegram.org");
function pe2(e14, t11) {
  O2("Posting event:", t11 ? { eventType: e14, eventData: t11 } : { eventType: e14 });
  const r9 = window;
  if (Q(r9)) {
    r9.TelegramWebviewProxy.postEvent(e14, JSON.stringify(t11));
    return;
  }
  const n15 = JSON.stringify({ eventType: e14, eventData: t11 });
  if (Ne())
    return r9.parent.postMessage(n15, ue());
  const { external: o16 } = r9;
  if (l2({ notify: Y() })().isValid(o16)) {
    o16.notify(n15);
    return;
  }
  throw new b(Ge);
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i4 = 0; i4 < 16; ++i4) {
        buf[offset + i4] = bytes[i4];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes[i4] = msg.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i4 = 0; i4 < length32; i4 += 8) {
    const x = input[i4 >> 5] >>> i4 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a3 = 1732584193;
  let b2 = -271733879;
  let c = -1732584194;
  let d8 = 271733878;
  for (let i4 = 0; i4 < x.length; i4 += 16) {
    const olda = a3;
    const oldb = b2;
    const oldc = c;
    const oldd = d8;
    a3 = md5ff(a3, b2, c, d8, x[i4], 7, -680876936);
    d8 = md5ff(d8, a3, b2, c, x[i4 + 1], 12, -389564586);
    c = md5ff(c, d8, a3, b2, x[i4 + 2], 17, 606105819);
    b2 = md5ff(b2, c, d8, a3, x[i4 + 3], 22, -1044525330);
    a3 = md5ff(a3, b2, c, d8, x[i4 + 4], 7, -176418897);
    d8 = md5ff(d8, a3, b2, c, x[i4 + 5], 12, 1200080426);
    c = md5ff(c, d8, a3, b2, x[i4 + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d8, a3, x[i4 + 7], 22, -45705983);
    a3 = md5ff(a3, b2, c, d8, x[i4 + 8], 7, 1770035416);
    d8 = md5ff(d8, a3, b2, c, x[i4 + 9], 12, -1958414417);
    c = md5ff(c, d8, a3, b2, x[i4 + 10], 17, -42063);
    b2 = md5ff(b2, c, d8, a3, x[i4 + 11], 22, -1990404162);
    a3 = md5ff(a3, b2, c, d8, x[i4 + 12], 7, 1804603682);
    d8 = md5ff(d8, a3, b2, c, x[i4 + 13], 12, -40341101);
    c = md5ff(c, d8, a3, b2, x[i4 + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d8, a3, x[i4 + 15], 22, 1236535329);
    a3 = md5gg(a3, b2, c, d8, x[i4 + 1], 5, -165796510);
    d8 = md5gg(d8, a3, b2, c, x[i4 + 6], 9, -1069501632);
    c = md5gg(c, d8, a3, b2, x[i4 + 11], 14, 643717713);
    b2 = md5gg(b2, c, d8, a3, x[i4], 20, -373897302);
    a3 = md5gg(a3, b2, c, d8, x[i4 + 5], 5, -701558691);
    d8 = md5gg(d8, a3, b2, c, x[i4 + 10], 9, 38016083);
    c = md5gg(c, d8, a3, b2, x[i4 + 15], 14, -660478335);
    b2 = md5gg(b2, c, d8, a3, x[i4 + 4], 20, -405537848);
    a3 = md5gg(a3, b2, c, d8, x[i4 + 9], 5, 568446438);
    d8 = md5gg(d8, a3, b2, c, x[i4 + 14], 9, -1019803690);
    c = md5gg(c, d8, a3, b2, x[i4 + 3], 14, -187363961);
    b2 = md5gg(b2, c, d8, a3, x[i4 + 8], 20, 1163531501);
    a3 = md5gg(a3, b2, c, d8, x[i4 + 13], 5, -1444681467);
    d8 = md5gg(d8, a3, b2, c, x[i4 + 2], 9, -51403784);
    c = md5gg(c, d8, a3, b2, x[i4 + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d8, a3, x[i4 + 12], 20, -1926607734);
    a3 = md5hh(a3, b2, c, d8, x[i4 + 5], 4, -378558);
    d8 = md5hh(d8, a3, b2, c, x[i4 + 8], 11, -2022574463);
    c = md5hh(c, d8, a3, b2, x[i4 + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d8, a3, x[i4 + 14], 23, -35309556);
    a3 = md5hh(a3, b2, c, d8, x[i4 + 1], 4, -1530992060);
    d8 = md5hh(d8, a3, b2, c, x[i4 + 4], 11, 1272893353);
    c = md5hh(c, d8, a3, b2, x[i4 + 7], 16, -155497632);
    b2 = md5hh(b2, c, d8, a3, x[i4 + 10], 23, -1094730640);
    a3 = md5hh(a3, b2, c, d8, x[i4 + 13], 4, 681279174);
    d8 = md5hh(d8, a3, b2, c, x[i4], 11, -358537222);
    c = md5hh(c, d8, a3, b2, x[i4 + 3], 16, -722521979);
    b2 = md5hh(b2, c, d8, a3, x[i4 + 6], 23, 76029189);
    a3 = md5hh(a3, b2, c, d8, x[i4 + 9], 4, -640364487);
    d8 = md5hh(d8, a3, b2, c, x[i4 + 12], 11, -421815835);
    c = md5hh(c, d8, a3, b2, x[i4 + 15], 16, 530742520);
    b2 = md5hh(b2, c, d8, a3, x[i4 + 2], 23, -995338651);
    a3 = md5ii(a3, b2, c, d8, x[i4], 6, -198630844);
    d8 = md5ii(d8, a3, b2, c, x[i4 + 7], 10, 1126891415);
    c = md5ii(c, d8, a3, b2, x[i4 + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d8, a3, x[i4 + 5], 21, -57434055);
    a3 = md5ii(a3, b2, c, d8, x[i4 + 12], 6, 1700485571);
    d8 = md5ii(d8, a3, b2, c, x[i4 + 3], 10, -1894986606);
    c = md5ii(c, d8, a3, b2, x[i4 + 10], 15, -1051523);
    b2 = md5ii(b2, c, d8, a3, x[i4 + 1], 21, -2054922799);
    a3 = md5ii(a3, b2, c, d8, x[i4 + 8], 6, 1873313359);
    d8 = md5ii(d8, a3, b2, c, x[i4 + 15], 10, -30611744);
    c = md5ii(c, d8, a3, b2, x[i4 + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d8, a3, x[i4 + 13], 21, 1309151649);
    a3 = md5ii(a3, b2, c, d8, x[i4 + 4], 6, -145523070);
    d8 = md5ii(d8, a3, b2, c, x[i4 + 11], 10, -1120210379);
    c = md5ii(c, d8, a3, b2, x[i4 + 2], 15, 718787259);
    b2 = md5ii(b2, c, d8, a3, x[i4 + 9], 21, -343485551);
    a3 = safeAdd(a3, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d8 = safeAdd(d8, oldd);
  }
  return [a3, b2, c, d8];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a3, b2, x, s5, t11) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q), safeAdd(x, t11)), s5), b2);
}
function md5ff(a3, b2, c, d8, x, s5, t11) {
  return md5cmn(b2 & c | ~b2 & d8, a3, b2, x, s5, t11);
}
function md5gg(a3, b2, c, d8, x, s5, t11) {
  return md5cmn(b2 & d8 | c & ~d8, a3, b2, x, s5, t11);
}
function md5hh(a3, b2, c, d8, x, s5, t11) {
  return md5cmn(b2 ^ c ^ d8, a3, b2, x, s5, t11);
}
function md5ii(a3, b2, c, d8, x, s5, t11) {
  return md5cmn(c ^ (b2 | ~d8), a3, b2, x, s5, t11);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s5, x, y2, z2) {
  switch (s5) {
    case 0:
      return x & y2 ^ ~x & z2;
    case 1:
      return x ^ y2 ^ z2;
    case 2:
      return x & y2 ^ x & z2 ^ y2 & z2;
    case 3:
      return x ^ y2 ^ z2;
  }
}
function ROTL(x, n15) {
  return x << n15 | x >>> 32 - n15;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes.push(msg.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l3 = bytes.length / 4 + 2;
  const N2 = Math.ceil(l3 / 16);
  const M = new Array(N2);
  for (let i4 = 0; i4 < N2; ++i4) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i4 * 64 + j * 4] << 24 | bytes[i4 * 64 + j * 4 + 1] << 16 | bytes[i4 * 64 + j * 4 + 2] << 8 | bytes[i4 * 64 + j * 4 + 3];
    }
    M[i4] = arr;
  }
  M[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N2 - 1][14] = Math.floor(M[N2 - 1][14]);
  M[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N2; ++i4) {
    const W4 = new Uint32Array(80);
    for (let t11 = 0; t11 < 16; ++t11) {
      W4[t11] = M[i4][t11];
    }
    for (let t11 = 16; t11 < 80; ++t11) {
      W4[t11] = ROTL(W4[t11 - 3] ^ W4[t11 - 8] ^ W4[t11 - 14] ^ W4[t11 - 16], 1);
    }
    let a3 = H[0];
    let b2 = H[1];
    let c = H[2];
    let d8 = H[3];
    let e14 = H[4];
    for (let t11 = 0; t11 < 80; ++t11) {
      const s5 = Math.floor(t11 / 20);
      const T4 = ROTL(a3, 5) + f2(s5, b2, c, d8) + e14 + K2[s5] + W4[t11] >>> 0;
      e14 = d8;
      d8 = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a3;
      a3 = T4;
    }
    H[0] = H[0] + a3 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d8 >>> 0;
    H[4] = H[4] + e14 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({ status: "dismissed" });
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow, request2) {
  return new Promise((resolve, reject) => {
    const listeners = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptConnectionRequestMessage, message.data)) {
          promptWindow.postMessage(new PromptConnectionResponseMessage(request2), baseUrl);
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new a2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i4 = 0; i4 < connectedAccountsLength; i4 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a3) => a3.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
async function createWalletRequest(baseUrl, request2) {
  const encodedClientIdentityKey = bytesToBase64url(request2.clientIdentityKey.toUint8Array());
  const response = await fetch(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`, {
    body: JSON.stringify({
      body: encodeWalletRequestBody(request2.body),
      id: request2.id,
      signature: bytesToBase64(request2.signature.toUint8Array()),
      timestamp: request2.timestamp
    }),
    headers: { Accept: "application/json", "Content-Type": "application/json" },
    method: "post"
  });
  if (!response.ok) {
    throw new Error("Failed creating the wallet request");
  }
}
var identityKeyStorageKey = "@aptos-connect/client-identity-key";
function getClientIdentityKey() {
  const serialized = window.localStorage.getItem(identityKeyStorageKey);
  if (serialized) {
    return new z(serialized);
  }
  const identityKey = z.generate();
  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());
  return identityKey;
}
var ON_RESUME_DELAY = 300;
var FG_RESPONSE_POLLING_INTERVAL = 2e3;
var BG_RESPONSE_POLLING_INTERVAL = 3e3;
var POLLING_TIMEOUT = 5 * 6e4;
function waitFor(milliseconds) {
  let timeoutId;
  let cancel = () => {
  };
  const timer = new Promise((resolve) => {
    timeoutId = setTimeout(resolve, milliseconds);
    cancel = () => {
      clearTimeout(timeoutId);
      resolve();
    };
  });
  timer.cancel = cancel;
  return timer;
}
async function smartPolling(callback) {
  let timer;
  let justResumed = false;
  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  const onWindowFocus = () => {
    justResumed = true;
    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;
    timer == null ? void 0 : timer.cancel();
  };
  const onWindowBlur = () => {
    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  };
  window.addEventListener("focus", onWindowFocus);
  window.addEventListener("blur", onWindowBlur);
  try {
    const startTime = Date.now();
    while (Date.now() - startTime < POLLING_TIMEOUT) {
      timer = waitFor(pollingInterval);
      await timer;
      if (justResumed) {
        timer = waitFor(ON_RESUME_DELAY);
        await timer;
      }
      const response = await callback();
      if (response.status === 200) {
        return response;
      }
      justResumed = false;
    }
    throw new Error("Timeout");
  } finally {
    window.removeEventListener("focus", onWindowFocus);
    window.removeEventListener("blur", onWindowFocus);
  }
}
async function getWalletResponse(baseUrl, clientIdentityKey, requestId) {
  const encodedClientIdentityKey = bytesToBase64url(clientIdentityKey.toUint8Array());
  const url = new URL(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`);
  const response = await smartPolling(
    () => fetch(url, {
      headers: { Accept: "application/json" },
      method: "get"
    })
  );
  const responseBody = await response.json();
  const data = base64ToBytes(responseBody.data.body);
  return { data };
}
async function openTelegramPrompt(args) {
  const { baseUrl, request: body, tgWebAppUrl = "/AptosConnectBot/AptosConnect" } = args;
  const identityKey = getClientIdentityKey();
  const clientIdentityKey = identityKey.publicKey();
  const requestId = v4_default();
  const timestamp = Date.now();
  const challenge = makePopupWalletRequestChallenge({ body, id: requestId, timestamp });
  const signature = identityKey.sign(challenge);
  const signedWalletRequest = {
    body,
    clientIdentityKey,
    id: requestId,
    signature,
    timestamp
  };
  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);
  if (encodedRequest.length > 1024) {
    void createWalletRequest(baseUrl, signedWalletRequest);
    encodedRequest = encodePopupWalletRequest({
      clientIdentityKey,
      id: requestId,
      signature,
      timestamp
    });
  }
  pe2("web_app_open_tg_link", {
    path_full: `${tgWebAppUrl}?startapp=${encodedRequest}`
  });
  return getWalletResponse(baseUrl, clientIdentityKey, requestId);
}
function isTelegramMiniApp() {
  return window.TelegramWebviewProxy !== void 0;
}
var WebWalletTransport = class {
  constructor(baseUrl, provider = "google", tgWebAppUrl) {
    this.baseUrl = baseUrl;
    this.provider = provider;
    this.tgWebAppUrl = tgWebAppUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request2) {
    if (isTelegramMiniApp()) {
      return openTelegramPrompt({
        baseUrl: this.baseUrl,
        request: request2,
        tgWebAppUrl: this.tgWebAppUrl
      });
    }
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("provider", this.provider);
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt, request2);
  }
  async sendRequest(request2) {
    switch (request2.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request2);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case SignInRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request2);
        const response = SignInResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account } = response.args.args;
          addConnectedAccount(account);
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request2);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});
var WalletOSEnum = ((WalletOSEnum2) => {
  WalletOSEnum2["Android"] = "android";
  WalletOSEnum2["IdentityConnect"] = "ic";
  WalletOSEnum2["Linux"] = "linux";
  WalletOSEnum2["Macos"] = "osx";
  WalletOSEnum2["Windows"] = "win";
  WalletOSEnum2["iOS"] = "ios";
  return WalletOSEnum2;
})(WalletOSEnum || {});
var WalletPlatformEnum = ((WalletPlatformEnum2) => {
  WalletPlatformEnum2["BraveExtension"] = "brave-extension";
  WalletPlatformEnum2["ChromeExtension"] = "chrome-extension";
  WalletPlatformEnum2["FirefoxExtension"] = "firefox-extension";
  WalletPlatformEnum2["IcDappWallet"] = "ic-dapp-wallet";
  WalletPlatformEnum2["KiwiExtension"] = "kiwi-extension";
  WalletPlatformEnum2["NativeApp"] = "native-app";
  WalletPlatformEnum2["OperaExtension"] = "opera-extension";
  WalletPlatformEnum2["SafariExtension"] = "safari-extension";
  return WalletPlatformEnum2;
})(WalletPlatformEnum || {});

// node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializableV1(value) {
  return (value == null ? void 0 : value.serialize) !== void 0;
}
function isBcsSerializableV2(value) {
  return (value == null ? void 0 : value.serialize) !== void 0 && (value == null ? void 0 : value.bcsToBytes) !== void 0 && (value == null ? void 0 : value.bcsToHex) !== void 0;
}
function isBcsSerializable(value) {
  return isBcsSerializableV1(value) || isBcsSerializableV2(value);
}
function bcsSerialize(serializable) {
  if (isBcsSerializableV2(serializable)) {
    return serializable.bcsToHex().toString();
  }
  const serializedValueBytes = bcs_exports.bcsToBytes(serializable);
  return a.fromHexInput(serializedValueBytes).toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = a.fromHexString(serializedValue).toUint8Array();
  const deserializer = new a2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: a.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(V, args.accountAuthenticator);
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(pe, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://aptosconnect.app";
function convertToSerializableArgument(argument) {
  if (argument === void 0 || argument === null) {
    return argument;
  }
  if (Array.isArray(argument)) {
    return argument.map((subArgument) => convertToSerializableArgument(subArgument));
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || argument instanceof Uint8Array) {
    return argument;
  }
  if (typeof argument === "bigint") {
    return argument.toString();
  }
  if (argument instanceof ArrayBuffer) {
    return new Uint8Array(argument);
  }
  if ("values" in argument) {
    return argument.values.map((subArgument) => convertToSerializableArgument(subArgument));
  }
  if ("data" in argument) {
    return l.from(argument.data).toString();
  }
  if (argument.value === void 0) {
    return void 0;
  }
  if (typeof argument.value === "string" || typeof argument.value === "number" || typeof argument.value === "boolean" || argument.value instanceof Uint8Array) {
    return argument.value;
  }
  if (typeof argument.value === "bigint") {
    return argument.value.toString();
  }
  throw new Error("Unexpected argument");
}
function normalizePayloadForIC(payload, aptosConfig) {
  if ("bcsToBytes" in payload) {
    return payload;
  }
  if ("bytecode" in payload) {
    return Wn(payload);
  }
  if (aptosConfig) {
    return payload.abi !== void 0 ? pa({ ...payload, abi: payload.abi }) : Wn({ aptosConfig, ...payload });
  }
  const entryFunctionPayload = {
    arguments: payload.functionArguments.map(convertToSerializableArgument),
    function: payload.function,
    type: "entry_function_payload",
    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString())
  };
  return "multisigAddress" in payload ? {
    multisig_address: l.from(payload.multisigAddress).toString(),
    transaction_payload: entryFunctionPayload,
    type: "multisig_payload"
  } : entryFunctionPayload;
}
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor2(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i4 = 0; i4 < retries; i4 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet == null ? void 0 : dappSpecificWallet.id
      });
    } catch (err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        var _a, _b, _c;
        if (isAxiosError(err)) {
          const errorMessage = (_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message;
          const expectedSequenceNumber = (_c = errorMessage == null ? void 0 : errorMessage.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)) == null ? void 0 : _c[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    var _a, _b;
    const response = await this.axiosInstance.get(
      `v1/signing-request/${id}/`,
      {
        validateStatus: (status) => status === 200 || status === 404
      }
    );
    return (_b = (_a = response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor2(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken == null ? void 0 : cancelToken.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),
      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_MESSAGE,
      args,
      options
    );
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    var _a, _b, _c, _d;
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e14) {
      if (e14 instanceof AxiosError && ((_b = (_a = e14.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message)) {
        throw new Error((_d = (_c = e14.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message);
      }
      throw e14;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({
        address: l.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL,
    provider = "google",
    tgWebAppURL
  } = {}) {
    this.defaultNetworkName = defaultNetworkName;
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(frontendBaseURL, provider, tgWebAppURL);
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find((account) => account.address.equals(l.from(address))) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = l.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect({
    claimOptions,
    preferredWalletName
  } = {}) {
    const dappKeypair = createEd25519KeyPair();
    const injectedPreferredWalletName = typeof window !== "undefined" ? window.AC_PREFERRED_WALLET_NAME : void 0;
    const requestArgs = {
      claimOptions,
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId,
      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName
    };
    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signIn(args) {
    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignInResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = a.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === h.LENGTH ? new h(signatureBytes) : O.deserialize(new a2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      if (!("bcsToBytes" in payload)) {
        throw new Error("Payload input format is only supported with Keyless accounts.");
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender == null ? void 0 : sender.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;
      const aptosConfig = new s({ network });
      let convertedArgs;
      if (feePayer !== void 0) {
        const payload = await normalizePayloadForIC(args.payload, aptosConfig);
        const rawTxn = await Ur({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new ut(rawTxn, [], feePayer.address)
        };
      } else {
        const payload = normalizePayloadForIC(args.payload);
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {
        networkName: network
      });
      return makeUserApproval({ txnHash: hash });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e8;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof f) {
      return E.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof Dt) {
      return E.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof k) {
      return E.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof Se) {
      return E.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
function customAccountToStandardAccount({ address, name, publicKey }) {
  return new d3({
    address,
    ansName: name,
    publicKey
  });
}
function unwrapUserResponse(response, callback) {
  if (response.status === "dismissed") {
    return { status: r5.REJECTED };
  }
  return { args: callback(response.args), status: r5.APPROVED };
}
function networkToChainId(network) {
  switch (network) {
    case e.MAINNET:
      return r.mainnet;
    case e.TESTNET:
      return r.testnet;
    default:
      return r.devnet;
  }
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({
    claimSecretKey,
    network = e.MAINNET,
    preferredWalletName,
    ...clientConfig
  }) {
    this.version = "1.0.0";
    this.chains = e8;
    this.client = new ACDappClient(clientConfig);
    if (!o[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new s({ network });
    this.aptosClient = new W(aptosConfig);
    this.preferredWalletName = preferredWalletName;
    this.claimOptions = claimSecretKey ? { network, secretKey: new z(claimSecretKey) } : void 0;
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(_AptosConnectWallet2.connectedAccountStorageKey);
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(serialized);
      return new d3({
        address: l.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      });
    } catch (err) {
      console.warn("Inconsistent state, resetting it");
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(_AptosConnectWallet2.connectedAccountStorageKey, JSON.stringify(serialized));
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r5.APPROVED };
    }
    const response = await this.client.connect({
      claimOptions: this.claimOptions,
      preferredWalletName: this.preferredWalletName
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(response.args.account);
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r5.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  async signIn(input) {
    const response = await this.client.signIn({ network: this.aptosClient.config.network, ...input });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const output = response.args;
    _AptosConnectWallet2.connectedAccount = output.account;
    return { args: output, status: r5.APPROVED };
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(o10.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o[network];
    return {
      chainId,
      name: network,
      url
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(o10.Unauthorized);
    }
    const chainId = networkToChainId(this.aptosClient.config.network);
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r5.APPROVED
    };
  }
  async signTransaction(txnOrArgs, _asFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(o10.Unauthorized);
    }
    if ("bcsToBytes" in txnOrArgs) {
      const transaction = txnOrArgs;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map((address) => ({ address }));
      const response2 = await this.client.signTransaction({
        feePayer,
        secondarySigners,
        signerAddress: connectedAccount.address,
        transaction: transaction.rawTransaction
      });
      return unwrapUserResponse(response2, (args) => args.authenticator);
    }
    const requestArgs = txnOrArgs;
    const response = await this.client.signTransaction({
      ...requestArgs,
      signerAddress: connectedAccount.address
    });
    return unwrapUserResponse(response, (responseArgs) => {
      var _a2, _b;
      const { authenticator, rawTransaction } = responseArgs;
      if (!rawTransaction) {
        throw new Error("Expected raw transaction in response args");
      }
      const secondarySigners = requestArgs.secondarySigners ?? [];
      let transaction;
      if (secondarySigners.length > 0) {
        transaction = new Gn(
          rawTransaction,
          secondarySigners.map((s5) => s5.address),
          (_a2 = requestArgs.feePayer) == null ? void 0 : _a2.address
        );
      } else {
        transaction = new Gt(rawTransaction, (_b = requestArgs.feePayer) == null ? void 0 : _b.address);
      }
      return {
        authenticator,
        rawTransaction: transaction
      };
    });
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(o10.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    return {
      args: { hash: response.args.txnHash },
      status: r5.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
var walletMetadata = {
  apple: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg=="
    ),
    name: "Continue with Apple",
    url: "https://aptosconnect.app"
  },
  google: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
    ),
    name: "Continue with Google",
    url: "https://aptosconnect.app"
  }
};
var AptosConnectGoogleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "google" });
    this.name = walletMetadata.google.name;
    this.icon = walletMetadata.google.icon;
    this.url = walletMetadata.google.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o6]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o7]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n6]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n7]: {
        signIn: this.signIn.bind(this),
        version: "0.1.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n8]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
};
var AptosConnectAppleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "apple" });
    this.name = walletMetadata.apple.name;
    this.icon = walletMetadata.apple.icon;
    this.url = walletMetadata.apple.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o6]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o7]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n6]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n7]: {
        signIn: this.signIn.bind(this),
        version: "0.1.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n8]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
};

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError = class _ClientError extends Error {
  constructor(response, request2) {
    const message = `${_ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request2
    })}`;
    super(message);
    __publicField(this, "response");
    __publicField(this, "request");
    Object.setPrototypeOf(this, _ClientError.prototype);
    this.response = response;
    this.request = request2;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, _ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b;
    return ((_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) ?? `GraphQL Error (Code: ${String(response.status)})`;
  }
};

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase();
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
var zip = (a3, b2) => a3.map((k2, i4) => [k2, b2[i4]]);
var HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== void 0) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
};
var HeadersInstanceToPlainObject = (headers) => {
  const o16 = {};
  headers.forEach((v6, k2) => {
    o16[k2] = v6;
  });
  return o16;
};
var tryCatch = (fn) => {
  try {
    const result = fn();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
};
var errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
};
var isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
};
var casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
};
var isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 11,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i4 = 0; i4 < locationLine.length; i4 += 80) {
      subLines.push(locationLine.slice(i4, i4 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i4 = 0; i4 < lines.length; ++i4) {
    var _firstNonEmptyLine;
    const line = lines[i4];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i4;
    lastNonEmptyLine = i4;
    if (i4 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i4) => i4 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i4 = 0;
  while (i4 < str.length && isWhiteSpace(str.charCodeAt(i4))) {
    ++i4;
  }
  return i4;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i4 = 0; i4 < len; ++i4) {
    items.push(formatValue(array[i4], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse2(source, options) {
  const parser = new Parser(source, options);
  const document2 = parser.parseDocument();
  Object.defineProperty(document2, "tokenCount", {
    enumerable: false,
    value: parser.tokenCount
  });
  return document2;
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i4 = 1; i4 <= aLength; i4++) {
      const upRow = rows[(i4 - 1) % 3];
      const currentRow = rows[i4 % 3];
      let smallestCell = currentRow[0] = i4;
      for (let j = 1; j <= bLength; j++) {
        const cost = a3[i4 - 1] === b2[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i4 > 1 && j > 1 && a3[i4 - 1] === b2[j - 2] && a3[i4 - 2] === b2[j - 1]) {
          const doubleDiagonalCell = rows[(i4 - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i4 = 0; i4 < strLength; ++i4) {
    array[i4] = str.charCodeAt(i4);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = { ...node };
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i4 = 1; i4 < name.length; ++i4) {
    if (!isNameContinue(name.charCodeAt(i4))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type) => {
        if (isInputObjectType(type)) {
          return type.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s5) => '"' + s5.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i4 = 0; i4 < fragmentNames.length; i4++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i4]
      );
      for (let j = i4 + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i4],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i4 = 0; i4 < fields.length; i4++) {
        for (let j = i4 + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i4],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var OrderedPairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a3)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b2);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a3, b2, weaklyPresent) {
    const map = this._data.get(a3);
    if (map === void 0) {
      this._data.set(a3, /* @__PURE__ */ new Map([[b2, weaklyPresent]]));
    } else {
      map.set(b2, weaklyPresent);
    }
  }
};
var PairSet = class {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a3, b2, weaklyPresent) {
    return a3 < b2 ? this._orderedPairSet.has(a3, b2, weaklyPresent) : this._orderedPairSet.has(b2, a3, weaklyPresent);
  }
  add(a3, b2, weaklyPresent) {
    if (a3 < b2) {
      this._orderedPairSet.add(a3, b2, weaklyPresent);
    } else {
      this._orderedPairSet.add(b2, a3, weaklyPresent);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        } else if (selectionSet.selections.length === 0) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue, parentType } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
            if (isInputObjectType(parentType) && parentType.isOneOf && isNullableType(varType)) {
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a22);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a22, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`;
var CONTENT_TYPE_HEADER = `Content-Type`;
var CONTENT_TYPE_JSON = `application/json`;
var CONTENT_TYPE_GQL = `application/graphql-response+json`;

// node_modules/graphql-request/build/legacy/lib/graphql.js
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
};
var parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e14) {
    return e14;
  }
};
var parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors = void 0;
  let data = void 0;
  let extensions = void 0;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors,
    extensions
  };
};
var isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult);
var isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors);
var isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === Kind.OPERATION_DEFINITION;
};

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var extractOperationName = (document2) => {
  var _a;
  let operationName = void 0;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = (_a = defs[0].name) == null ? void 0 : _a.value;
  }
  return operationName;
};
var extractIsMutation = (document2) => {
  let isMutation = false;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === `mutation`;
  }
  return isMutation;
};
var analyzeDocument = (document2, excludeOperationName) => {
  const expression = typeof document2 === `string` ? document2 : print(document2);
  let isMutation = false;
  let operationName = void 0;
  if (excludeOperationName) {
    return { expression, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document2 === `string` ? parse2(document2) : document2);
  if (docNode instanceof Error) {
    return { expression, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression, operationName, isMutation };
};

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: input.fetchOptions.errorPolicy ?? `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
};
var executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : void 0
  };
};
var parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
};
var createFetcher = (method) => async (params) => {
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = void 0;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : void 0,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = params.fetch ?? fetch;
  return await $fetch(url, initResolved);
};
var buildBody = (params) => {
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
};
var buildQueryParams = (params) => {
  var _a;
  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
  const searchParams = new URLSearchParams();
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = ((_a = params.request.variables) == null ? void 0 : _a.map((v6) => $jsonSerializer.stringify(v6))) ?? [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    __publicField(this, "rawRequest", async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const document2 = analyzeDocument(rawRequestOptions.query, excludeOperationName);
      const response = await runRequest({
        url,
        request: {
          _tag: `Single`,
          document: document2,
          variables: rawRequestOptions.variables
        },
        headers: {
          ...HeadersInitToPlainObject(callOrIdentity(headers)),
          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
        },
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      });
      if (responseMiddleware) {
        await responseMiddleware(response, {
          operationName: document2.operationName,
          variables,
          url: this.url
        });
      }
      if (response instanceof Error) {
        throw response;
      }
      return response;
    });
    this.url = url;
    this.requestConfig = requestConfig;
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document: document2 }) => analyzeDocument(document2, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression }) => expression);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: void 0,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: void 0,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};

// node_modules/graphql-request/build/legacy/functions/request.js
async function request(urlOrOptions, document2, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document2, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRequestExtendedArgs = (urlOrOptions, document2, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return typeof urlOrOptions === `string` ? {
    url: urlOrOptions,
    document: document2,
    variables,
    requestHeaders,
    signal: void 0
  } : urlOrOptions;
};

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// node_modules/graphql-request/build/entrypoints/main.js
var main_default = request;

// node_modules/@mizuwallet-sdk/core/dist/index.js
var Gt2 = Object.defineProperty;
var Ht = (E2, s5, x) => s5 in E2 ? Gt2(E2, s5, { enumerable: true, configurable: true, writable: true, value: x }) : E2[s5] = x;
var pf = (E2, s5, x) => Ht(E2, typeof s5 != "symbol" ? s5 + "" : s5, x);
var Qt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Kt(E2) {
  return E2 && E2.__esModule && Object.prototype.hasOwnProperty.call(E2, "default") ? E2.default : E2;
}
function Zt(E2) {
  if (E2.__esModule) return E2;
  var s5 = E2.default;
  if (typeof s5 == "function") {
    var x = function $2() {
      return this instanceof $2 ? Reflect.construct(s5, arguments, this.constructor) : s5.apply(this, arguments);
    };
    x.prototype = s5.prototype;
  } else x = {};
  return Object.defineProperty(x, "__esModule", { value: true }), Object.keys(E2).forEach(function($2) {
    var N2 = Object.getOwnPropertyDescriptor(E2, $2);
    Object.defineProperty(x, $2, N2.get ? N2 : {
      enumerable: true,
      get: function() {
        return E2[$2];
      }
    });
  }), x;
}
var Lt = { exports: {} };
(function(E2) {
  (function(s5, x) {
    E2.exports ? E2.exports = x() : (s5.nacl || (s5.nacl = {}), s5.nacl.util = x());
  })(Qt, function() {
    var s5 = {};
    function x($2) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test($2))
        throw new TypeError("invalid encoding");
    }
    return s5.decodeUTF8 = function($2) {
      if (typeof $2 != "string") throw new TypeError("expected string");
      var N2, ff2 = unescape(encodeURIComponent($2)), of2 = new Uint8Array(ff2.length);
      for (N2 = 0; N2 < ff2.length; N2++) of2[N2] = ff2.charCodeAt(N2);
      return of2;
    }, s5.encodeUTF8 = function($2) {
      var N2, ff2 = [];
      for (N2 = 0; N2 < $2.length; N2++) ff2.push(String.fromCharCode($2[N2]));
      return decodeURIComponent(escape(ff2.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (s5.encodeBase64 = function($2) {
      return Buffer.from($2).toString("base64");
    }, s5.decodeBase64 = function($2) {
      return x($2), new Uint8Array(Array.prototype.slice.call(Buffer.from($2, "base64"), 0));
    }) : (s5.encodeBase64 = function($2) {
      return new Buffer($2).toString("base64");
    }, s5.decodeBase64 = function($2) {
      return x($2), new Uint8Array(Array.prototype.slice.call(new Buffer($2, "base64"), 0));
    }) : (s5.encodeBase64 = function($2) {
      var N2, ff2 = [], of2 = $2.length;
      for (N2 = 0; N2 < of2; N2++) ff2.push(String.fromCharCode($2[N2]));
      return btoa(ff2.join(""));
    }, s5.decodeBase64 = function($2) {
      x($2);
      var N2, ff2 = atob($2), of2 = new Uint8Array(ff2.length);
      for (N2 = 0; N2 < ff2.length; N2++) of2[N2] = ff2.charCodeAt(N2);
      return of2;
    }), s5;
  });
})(Lt);
var Xt = Lt.exports;
var $f = Kt(Xt);
function Vt(E2) {
  throw new Error('Could not dynamically require "' + E2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var fr = { exports: {} };
var tr = {};
var rr = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: tr
}, Symbol.toStringTag, { value: "Module" }));
var er = Zt(rr);
(function(E2) {
  (function(s5) {
    var x = function(t11) {
      var e14, r9 = new Float64Array(16);
      if (t11) for (e14 = 0; e14 < t11.length; e14++) r9[e14] = t11[e14];
      return r9;
    }, $2 = function() {
      throw new Error("no PRNG");
    }, N2 = new Uint8Array(16), ff2 = new Uint8Array(32);
    ff2[0] = 9;
    var of2 = x(), wf = x([1]), zt = x([56129, 1]), xt = x([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), Ot = x([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), st3 = x([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), ht = x([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), Pt = x([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ct(t11, e14, r9, f3) {
      t11[e14] = r9 >> 24 & 255, t11[e14 + 1] = r9 >> 16 & 255, t11[e14 + 2] = r9 >> 8 & 255, t11[e14 + 3] = r9 & 255, t11[e14 + 4] = f3 >> 24 & 255, t11[e14 + 5] = f3 >> 16 & 255, t11[e14 + 6] = f3 >> 8 & 255, t11[e14 + 7] = f3 & 255;
    }
    function Df(t11, e14, r9, f3, n15) {
      var i4, o16 = 0;
      for (i4 = 0; i4 < n15; i4++) o16 |= t11[e14 + i4] ^ r9[f3 + i4];
      return (1 & o16 - 1 >>> 8) - 1;
    }
    function dt(t11, e14, r9, f3) {
      return Df(t11, e14, r9, f3, 16);
    }
    function Ff(t11, e14, r9, f3) {
      return Df(t11, e14, r9, f3, 32);
    }
    function mt(t11, e14, r9, f3) {
      for (var n15 = f3[0] & 255 | (f3[1] & 255) << 8 | (f3[2] & 255) << 16 | (f3[3] & 255) << 24, i4 = r9[0] & 255 | (r9[1] & 255) << 8 | (r9[2] & 255) << 16 | (r9[3] & 255) << 24, o16 = r9[4] & 255 | (r9[5] & 255) << 8 | (r9[6] & 255) << 16 | (r9[7] & 255) << 24, u = r9[8] & 255 | (r9[9] & 255) << 8 | (r9[10] & 255) << 16 | (r9[11] & 255) << 24, g2 = r9[12] & 255 | (r9[13] & 255) << 8 | (r9[14] & 255) << 16 | (r9[15] & 255) << 24, U3 = f3[4] & 255 | (f3[5] & 255) << 8 | (f3[6] & 255) << 16 | (f3[7] & 255) << 24, w = e14[0] & 255 | (e14[1] & 255) << 8 | (e14[2] & 255) << 16 | (e14[3] & 255) << 24, G = e14[4] & 255 | (e14[5] & 255) << 8 | (e14[6] & 255) << 16 | (e14[7] & 255) << 24, _2 = e14[8] & 255 | (e14[9] & 255) << 8 | (e14[10] & 255) << 16 | (e14[11] & 255) << 24, M = e14[12] & 255 | (e14[13] & 255) << 8 | (e14[14] & 255) << 16 | (e14[15] & 255) << 24, j = f3[8] & 255 | (f3[9] & 255) << 8 | (f3[10] & 255) << 16 | (f3[11] & 255) << 24, P2 = r9[16] & 255 | (r9[17] & 255) << 8 | (r9[18] & 255) << 16 | (r9[19] & 255) << 24, O3 = r9[20] & 255 | (r9[21] & 255) << 8 | (r9[22] & 255) << 16 | (r9[23] & 255) << 24, C2 = r9[24] & 255 | (r9[25] & 255) << 8 | (r9[26] & 255) << 16 | (r9[27] & 255) << 24, z2 = r9[28] & 255 | (r9[29] & 255) << 8 | (r9[30] & 255) << 16 | (r9[31] & 255) << 24, L2 = f3[12] & 255 | (f3[13] & 255) << 8 | (f3[14] & 255) << 16 | (f3[15] & 255) << 24, I2 = n15, S = i4, v6 = o16, A4 = u, T4 = g2, p4 = U3, h3 = w, c = G, b2 = _2, d8 = M, l3 = j, y2 = P2, B2 = O3, m = C2, Y2 = z2, q = L2, a3, W4 = 0; W4 < 20; W4 += 2)
        a3 = I2 + B2 | 0, T4 ^= a3 << 7 | a3 >>> 25, a3 = T4 + I2 | 0, b2 ^= a3 << 9 | a3 >>> 23, a3 = b2 + T4 | 0, B2 ^= a3 << 13 | a3 >>> 19, a3 = B2 + b2 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = p4 + S | 0, d8 ^= a3 << 7 | a3 >>> 25, a3 = d8 + p4 | 0, m ^= a3 << 9 | a3 >>> 23, a3 = m + d8 | 0, S ^= a3 << 13 | a3 >>> 19, a3 = S + m | 0, p4 ^= a3 << 18 | a3 >>> 14, a3 = l3 + h3 | 0, Y2 ^= a3 << 7 | a3 >>> 25, a3 = Y2 + l3 | 0, v6 ^= a3 << 9 | a3 >>> 23, a3 = v6 + Y2 | 0, h3 ^= a3 << 13 | a3 >>> 19, a3 = h3 + v6 | 0, l3 ^= a3 << 18 | a3 >>> 14, a3 = q + y2 | 0, A4 ^= a3 << 7 | a3 >>> 25, a3 = A4 + q | 0, c ^= a3 << 9 | a3 >>> 23, a3 = c + A4 | 0, y2 ^= a3 << 13 | a3 >>> 19, a3 = y2 + c | 0, q ^= a3 << 18 | a3 >>> 14, a3 = I2 + A4 | 0, S ^= a3 << 7 | a3 >>> 25, a3 = S + I2 | 0, v6 ^= a3 << 9 | a3 >>> 23, a3 = v6 + S | 0, A4 ^= a3 << 13 | a3 >>> 19, a3 = A4 + v6 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = p4 + T4 | 0, h3 ^= a3 << 7 | a3 >>> 25, a3 = h3 + p4 | 0, c ^= a3 << 9 | a3 >>> 23, a3 = c + h3 | 0, T4 ^= a3 << 13 | a3 >>> 19, a3 = T4 + c | 0, p4 ^= a3 << 18 | a3 >>> 14, a3 = l3 + d8 | 0, y2 ^= a3 << 7 | a3 >>> 25, a3 = y2 + l3 | 0, b2 ^= a3 << 9 | a3 >>> 23, a3 = b2 + y2 | 0, d8 ^= a3 << 13 | a3 >>> 19, a3 = d8 + b2 | 0, l3 ^= a3 << 18 | a3 >>> 14, a3 = q + Y2 | 0, B2 ^= a3 << 7 | a3 >>> 25, a3 = B2 + q | 0, m ^= a3 << 9 | a3 >>> 23, a3 = m + B2 | 0, Y2 ^= a3 << 13 | a3 >>> 19, a3 = Y2 + m | 0, q ^= a3 << 18 | a3 >>> 14;
      I2 = I2 + n15 | 0, S = S + i4 | 0, v6 = v6 + o16 | 0, A4 = A4 + u | 0, T4 = T4 + g2 | 0, p4 = p4 + U3 | 0, h3 = h3 + w | 0, c = c + G | 0, b2 = b2 + _2 | 0, d8 = d8 + M | 0, l3 = l3 + j | 0, y2 = y2 + P2 | 0, B2 = B2 + O3 | 0, m = m + C2 | 0, Y2 = Y2 + z2 | 0, q = q + L2 | 0, t11[0] = I2 >>> 0 & 255, t11[1] = I2 >>> 8 & 255, t11[2] = I2 >>> 16 & 255, t11[3] = I2 >>> 24 & 255, t11[4] = S >>> 0 & 255, t11[5] = S >>> 8 & 255, t11[6] = S >>> 16 & 255, t11[7] = S >>> 24 & 255, t11[8] = v6 >>> 0 & 255, t11[9] = v6 >>> 8 & 255, t11[10] = v6 >>> 16 & 255, t11[11] = v6 >>> 24 & 255, t11[12] = A4 >>> 0 & 255, t11[13] = A4 >>> 8 & 255, t11[14] = A4 >>> 16 & 255, t11[15] = A4 >>> 24 & 255, t11[16] = T4 >>> 0 & 255, t11[17] = T4 >>> 8 & 255, t11[18] = T4 >>> 16 & 255, t11[19] = T4 >>> 24 & 255, t11[20] = p4 >>> 0 & 255, t11[21] = p4 >>> 8 & 255, t11[22] = p4 >>> 16 & 255, t11[23] = p4 >>> 24 & 255, t11[24] = h3 >>> 0 & 255, t11[25] = h3 >>> 8 & 255, t11[26] = h3 >>> 16 & 255, t11[27] = h3 >>> 24 & 255, t11[28] = c >>> 0 & 255, t11[29] = c >>> 8 & 255, t11[30] = c >>> 16 & 255, t11[31] = c >>> 24 & 255, t11[32] = b2 >>> 0 & 255, t11[33] = b2 >>> 8 & 255, t11[34] = b2 >>> 16 & 255, t11[35] = b2 >>> 24 & 255, t11[36] = d8 >>> 0 & 255, t11[37] = d8 >>> 8 & 255, t11[38] = d8 >>> 16 & 255, t11[39] = d8 >>> 24 & 255, t11[40] = l3 >>> 0 & 255, t11[41] = l3 >>> 8 & 255, t11[42] = l3 >>> 16 & 255, t11[43] = l3 >>> 24 & 255, t11[44] = y2 >>> 0 & 255, t11[45] = y2 >>> 8 & 255, t11[46] = y2 >>> 16 & 255, t11[47] = y2 >>> 24 & 255, t11[48] = B2 >>> 0 & 255, t11[49] = B2 >>> 8 & 255, t11[50] = B2 >>> 16 & 255, t11[51] = B2 >>> 24 & 255, t11[52] = m >>> 0 & 255, t11[53] = m >>> 8 & 255, t11[54] = m >>> 16 & 255, t11[55] = m >>> 24 & 255, t11[56] = Y2 >>> 0 & 255, t11[57] = Y2 >>> 8 & 255, t11[58] = Y2 >>> 16 & 255, t11[59] = Y2 >>> 24 & 255, t11[60] = q >>> 0 & 255, t11[61] = q >>> 8 & 255, t11[62] = q >>> 16 & 255, t11[63] = q >>> 24 & 255;
    }
    function qt2(t11, e14, r9, f3) {
      for (var n15 = f3[0] & 255 | (f3[1] & 255) << 8 | (f3[2] & 255) << 16 | (f3[3] & 255) << 24, i4 = r9[0] & 255 | (r9[1] & 255) << 8 | (r9[2] & 255) << 16 | (r9[3] & 255) << 24, o16 = r9[4] & 255 | (r9[5] & 255) << 8 | (r9[6] & 255) << 16 | (r9[7] & 255) << 24, u = r9[8] & 255 | (r9[9] & 255) << 8 | (r9[10] & 255) << 16 | (r9[11] & 255) << 24, g2 = r9[12] & 255 | (r9[13] & 255) << 8 | (r9[14] & 255) << 16 | (r9[15] & 255) << 24, U3 = f3[4] & 255 | (f3[5] & 255) << 8 | (f3[6] & 255) << 16 | (f3[7] & 255) << 24, w = e14[0] & 255 | (e14[1] & 255) << 8 | (e14[2] & 255) << 16 | (e14[3] & 255) << 24, G = e14[4] & 255 | (e14[5] & 255) << 8 | (e14[6] & 255) << 16 | (e14[7] & 255) << 24, _2 = e14[8] & 255 | (e14[9] & 255) << 8 | (e14[10] & 255) << 16 | (e14[11] & 255) << 24, M = e14[12] & 255 | (e14[13] & 255) << 8 | (e14[14] & 255) << 16 | (e14[15] & 255) << 24, j = f3[8] & 255 | (f3[9] & 255) << 8 | (f3[10] & 255) << 16 | (f3[11] & 255) << 24, P2 = r9[16] & 255 | (r9[17] & 255) << 8 | (r9[18] & 255) << 16 | (r9[19] & 255) << 24, O3 = r9[20] & 255 | (r9[21] & 255) << 8 | (r9[22] & 255) << 16 | (r9[23] & 255) << 24, C2 = r9[24] & 255 | (r9[25] & 255) << 8 | (r9[26] & 255) << 16 | (r9[27] & 255) << 24, z2 = r9[28] & 255 | (r9[29] & 255) << 8 | (r9[30] & 255) << 16 | (r9[31] & 255) << 24, L2 = f3[12] & 255 | (f3[13] & 255) << 8 | (f3[14] & 255) << 16 | (f3[15] & 255) << 24, I2 = n15, S = i4, v6 = o16, A4 = u, T4 = g2, p4 = U3, h3 = w, c = G, b2 = _2, d8 = M, l3 = j, y2 = P2, B2 = O3, m = C2, Y2 = z2, q = L2, a3, W4 = 0; W4 < 20; W4 += 2)
        a3 = I2 + B2 | 0, T4 ^= a3 << 7 | a3 >>> 25, a3 = T4 + I2 | 0, b2 ^= a3 << 9 | a3 >>> 23, a3 = b2 + T4 | 0, B2 ^= a3 << 13 | a3 >>> 19, a3 = B2 + b2 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = p4 + S | 0, d8 ^= a3 << 7 | a3 >>> 25, a3 = d8 + p4 | 0, m ^= a3 << 9 | a3 >>> 23, a3 = m + d8 | 0, S ^= a3 << 13 | a3 >>> 19, a3 = S + m | 0, p4 ^= a3 << 18 | a3 >>> 14, a3 = l3 + h3 | 0, Y2 ^= a3 << 7 | a3 >>> 25, a3 = Y2 + l3 | 0, v6 ^= a3 << 9 | a3 >>> 23, a3 = v6 + Y2 | 0, h3 ^= a3 << 13 | a3 >>> 19, a3 = h3 + v6 | 0, l3 ^= a3 << 18 | a3 >>> 14, a3 = q + y2 | 0, A4 ^= a3 << 7 | a3 >>> 25, a3 = A4 + q | 0, c ^= a3 << 9 | a3 >>> 23, a3 = c + A4 | 0, y2 ^= a3 << 13 | a3 >>> 19, a3 = y2 + c | 0, q ^= a3 << 18 | a3 >>> 14, a3 = I2 + A4 | 0, S ^= a3 << 7 | a3 >>> 25, a3 = S + I2 | 0, v6 ^= a3 << 9 | a3 >>> 23, a3 = v6 + S | 0, A4 ^= a3 << 13 | a3 >>> 19, a3 = A4 + v6 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = p4 + T4 | 0, h3 ^= a3 << 7 | a3 >>> 25, a3 = h3 + p4 | 0, c ^= a3 << 9 | a3 >>> 23, a3 = c + h3 | 0, T4 ^= a3 << 13 | a3 >>> 19, a3 = T4 + c | 0, p4 ^= a3 << 18 | a3 >>> 14, a3 = l3 + d8 | 0, y2 ^= a3 << 7 | a3 >>> 25, a3 = y2 + l3 | 0, b2 ^= a3 << 9 | a3 >>> 23, a3 = b2 + y2 | 0, d8 ^= a3 << 13 | a3 >>> 19, a3 = d8 + b2 | 0, l3 ^= a3 << 18 | a3 >>> 14, a3 = q + Y2 | 0, B2 ^= a3 << 7 | a3 >>> 25, a3 = B2 + q | 0, m ^= a3 << 9 | a3 >>> 23, a3 = m + B2 | 0, Y2 ^= a3 << 13 | a3 >>> 19, a3 = Y2 + m | 0, q ^= a3 << 18 | a3 >>> 14;
      t11[0] = I2 >>> 0 & 255, t11[1] = I2 >>> 8 & 255, t11[2] = I2 >>> 16 & 255, t11[3] = I2 >>> 24 & 255, t11[4] = p4 >>> 0 & 255, t11[5] = p4 >>> 8 & 255, t11[6] = p4 >>> 16 & 255, t11[7] = p4 >>> 24 & 255, t11[8] = l3 >>> 0 & 255, t11[9] = l3 >>> 8 & 255, t11[10] = l3 >>> 16 & 255, t11[11] = l3 >>> 24 & 255, t11[12] = q >>> 0 & 255, t11[13] = q >>> 8 & 255, t11[14] = q >>> 16 & 255, t11[15] = q >>> 24 & 255, t11[16] = h3 >>> 0 & 255, t11[17] = h3 >>> 8 & 255, t11[18] = h3 >>> 16 & 255, t11[19] = h3 >>> 24 & 255, t11[20] = c >>> 0 & 255, t11[21] = c >>> 8 & 255, t11[22] = c >>> 16 & 255, t11[23] = c >>> 24 & 255, t11[24] = b2 >>> 0 & 255, t11[25] = b2 >>> 8 & 255, t11[26] = b2 >>> 16 & 255, t11[27] = b2 >>> 24 & 255, t11[28] = d8 >>> 0 & 255, t11[29] = d8 >>> 8 & 255, t11[30] = d8 >>> 16 & 255, t11[31] = d8 >>> 24 & 255;
    }
    function Mf(t11, e14, r9, f3) {
      mt(t11, e14, r9, f3);
    }
    function jf(t11, e14, r9, f3) {
      qt2(t11, e14, r9, f3);
    }
    var bf2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function ut2(t11, e14, r9, f3, n15, i4, o16) {
      var u = new Uint8Array(16), g2 = new Uint8Array(64), U3, w;
      for (w = 0; w < 16; w++) u[w] = 0;
      for (w = 0; w < 8; w++) u[w] = i4[w];
      for (; n15 >= 64; ) {
        for (Mf(g2, u, o16, bf2), w = 0; w < 64; w++) t11[e14 + w] = r9[f3 + w] ^ g2[w];
        for (U3 = 1, w = 8; w < 16; w++)
          U3 = U3 + (u[w] & 255) | 0, u[w] = U3 & 255, U3 >>>= 8;
        n15 -= 64, e14 += 64, f3 += 64;
      }
      if (n15 > 0)
        for (Mf(g2, u, o16, bf2), w = 0; w < n15; w++) t11[e14 + w] = r9[f3 + w] ^ g2[w];
      return 0;
    }
    function lt(t11, e14, r9, f3, n15) {
      var i4 = new Uint8Array(16), o16 = new Uint8Array(64), u, g2;
      for (g2 = 0; g2 < 16; g2++) i4[g2] = 0;
      for (g2 = 0; g2 < 8; g2++) i4[g2] = f3[g2];
      for (; r9 >= 64; ) {
        for (Mf(o16, i4, n15, bf2), g2 = 0; g2 < 64; g2++) t11[e14 + g2] = o16[g2];
        for (u = 1, g2 = 8; g2 < 16; g2++)
          u = u + (i4[g2] & 255) | 0, i4[g2] = u & 255, u >>>= 8;
        r9 -= 64, e14 += 64;
      }
      if (r9 > 0)
        for (Mf(o16, i4, n15, bf2), g2 = 0; g2 < r9; g2++) t11[e14 + g2] = o16[g2];
      return 0;
    }
    function bt(t11, e14, r9, f3, n15) {
      var i4 = new Uint8Array(32);
      jf(i4, f3, n15, bf2);
      for (var o16 = new Uint8Array(8), u = 0; u < 8; u++) o16[u] = f3[u + 16];
      return lt(t11, e14, r9, o16, i4);
    }
    function Jf(t11, e14, r9, f3, n15, i4, o16) {
      var u = new Uint8Array(32);
      jf(u, i4, o16, bf2);
      for (var g2 = new Uint8Array(8), U3 = 0; U3 < 8; U3++) g2[U3] = i4[U3 + 16];
      return ut2(t11, e14, r9, f3, n15, g2, u);
    }
    var Cf = function(t11) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var e14, r9, f3, n15, i4, o16, u, g2;
      e14 = t11[0] & 255 | (t11[1] & 255) << 8, this.r[0] = e14 & 8191, r9 = t11[2] & 255 | (t11[3] & 255) << 8, this.r[1] = (e14 >>> 13 | r9 << 3) & 8191, f3 = t11[4] & 255 | (t11[5] & 255) << 8, this.r[2] = (r9 >>> 10 | f3 << 6) & 7939, n15 = t11[6] & 255 | (t11[7] & 255) << 8, this.r[3] = (f3 >>> 7 | n15 << 9) & 8191, i4 = t11[8] & 255 | (t11[9] & 255) << 8, this.r[4] = (n15 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, o16 = t11[10] & 255 | (t11[11] & 255) << 8, this.r[6] = (i4 >>> 14 | o16 << 2) & 8191, u = t11[12] & 255 | (t11[13] & 255) << 8, this.r[7] = (o16 >>> 11 | u << 5) & 8065, g2 = t11[14] & 255 | (t11[15] & 255) << 8, this.r[8] = (u >>> 8 | g2 << 8) & 8191, this.r[9] = g2 >>> 5 & 127, this.pad[0] = t11[16] & 255 | (t11[17] & 255) << 8, this.pad[1] = t11[18] & 255 | (t11[19] & 255) << 8, this.pad[2] = t11[20] & 255 | (t11[21] & 255) << 8, this.pad[3] = t11[22] & 255 | (t11[23] & 255) << 8, this.pad[4] = t11[24] & 255 | (t11[25] & 255) << 8, this.pad[5] = t11[26] & 255 | (t11[27] & 255) << 8, this.pad[6] = t11[28] & 255 | (t11[29] & 255) << 8, this.pad[7] = t11[30] & 255 | (t11[31] & 255) << 8;
    };
    Cf.prototype.blocks = function(t11, e14, r9) {
      for (var f3 = this.fin ? 0 : 2048, n15, i4, o16, u, g2, U3, w, G, _2, M, j, P2, O3, C2, z2, L2, I2, S, v6, A4 = this.h[0], T4 = this.h[1], p4 = this.h[2], h3 = this.h[3], c = this.h[4], b2 = this.h[5], d8 = this.h[6], l3 = this.h[7], y2 = this.h[8], B2 = this.h[9], m = this.r[0], Y2 = this.r[1], q = this.r[2], a3 = this.r[3], W4 = this.r[4], H = this.r[5], R2 = this.r[6], k2 = this.r[7], F = this.r[8], J = this.r[9]; r9 >= 16; )
        n15 = t11[e14 + 0] & 255 | (t11[e14 + 1] & 255) << 8, A4 += n15 & 8191, i4 = t11[e14 + 2] & 255 | (t11[e14 + 3] & 255) << 8, T4 += (n15 >>> 13 | i4 << 3) & 8191, o16 = t11[e14 + 4] & 255 | (t11[e14 + 5] & 255) << 8, p4 += (i4 >>> 10 | o16 << 6) & 8191, u = t11[e14 + 6] & 255 | (t11[e14 + 7] & 255) << 8, h3 += (o16 >>> 7 | u << 9) & 8191, g2 = t11[e14 + 8] & 255 | (t11[e14 + 9] & 255) << 8, c += (u >>> 4 | g2 << 12) & 8191, b2 += g2 >>> 1 & 8191, U3 = t11[e14 + 10] & 255 | (t11[e14 + 11] & 255) << 8, d8 += (g2 >>> 14 | U3 << 2) & 8191, w = t11[e14 + 12] & 255 | (t11[e14 + 13] & 255) << 8, l3 += (U3 >>> 11 | w << 5) & 8191, G = t11[e14 + 14] & 255 | (t11[e14 + 15] & 255) << 8, y2 += (w >>> 8 | G << 8) & 8191, B2 += G >>> 5 | f3, _2 = 0, M = _2, M += A4 * m, M += T4 * (5 * J), M += p4 * (5 * F), M += h3 * (5 * k2), M += c * (5 * R2), _2 = M >>> 13, M &= 8191, M += b2 * (5 * H), M += d8 * (5 * W4), M += l3 * (5 * a3), M += y2 * (5 * q), M += B2 * (5 * Y2), _2 += M >>> 13, M &= 8191, j = _2, j += A4 * Y2, j += T4 * m, j += p4 * (5 * J), j += h3 * (5 * F), j += c * (5 * k2), _2 = j >>> 13, j &= 8191, j += b2 * (5 * R2), j += d8 * (5 * H), j += l3 * (5 * W4), j += y2 * (5 * a3), j += B2 * (5 * q), _2 += j >>> 13, j &= 8191, P2 = _2, P2 += A4 * q, P2 += T4 * Y2, P2 += p4 * m, P2 += h3 * (5 * J), P2 += c * (5 * F), _2 = P2 >>> 13, P2 &= 8191, P2 += b2 * (5 * k2), P2 += d8 * (5 * R2), P2 += l3 * (5 * H), P2 += y2 * (5 * W4), P2 += B2 * (5 * a3), _2 += P2 >>> 13, P2 &= 8191, O3 = _2, O3 += A4 * a3, O3 += T4 * q, O3 += p4 * Y2, O3 += h3 * m, O3 += c * (5 * J), _2 = O3 >>> 13, O3 &= 8191, O3 += b2 * (5 * F), O3 += d8 * (5 * k2), O3 += l3 * (5 * R2), O3 += y2 * (5 * H), O3 += B2 * (5 * W4), _2 += O3 >>> 13, O3 &= 8191, C2 = _2, C2 += A4 * W4, C2 += T4 * a3, C2 += p4 * q, C2 += h3 * Y2, C2 += c * m, _2 = C2 >>> 13, C2 &= 8191, C2 += b2 * (5 * J), C2 += d8 * (5 * F), C2 += l3 * (5 * k2), C2 += y2 * (5 * R2), C2 += B2 * (5 * H), _2 += C2 >>> 13, C2 &= 8191, z2 = _2, z2 += A4 * H, z2 += T4 * W4, z2 += p4 * a3, z2 += h3 * q, z2 += c * Y2, _2 = z2 >>> 13, z2 &= 8191, z2 += b2 * m, z2 += d8 * (5 * J), z2 += l3 * (5 * F), z2 += y2 * (5 * k2), z2 += B2 * (5 * R2), _2 += z2 >>> 13, z2 &= 8191, L2 = _2, L2 += A4 * R2, L2 += T4 * H, L2 += p4 * W4, L2 += h3 * a3, L2 += c * q, _2 = L2 >>> 13, L2 &= 8191, L2 += b2 * Y2, L2 += d8 * m, L2 += l3 * (5 * J), L2 += y2 * (5 * F), L2 += B2 * (5 * k2), _2 += L2 >>> 13, L2 &= 8191, I2 = _2, I2 += A4 * k2, I2 += T4 * R2, I2 += p4 * H, I2 += h3 * W4, I2 += c * a3, _2 = I2 >>> 13, I2 &= 8191, I2 += b2 * q, I2 += d8 * Y2, I2 += l3 * m, I2 += y2 * (5 * J), I2 += B2 * (5 * F), _2 += I2 >>> 13, I2 &= 8191, S = _2, S += A4 * F, S += T4 * k2, S += p4 * R2, S += h3 * H, S += c * W4, _2 = S >>> 13, S &= 8191, S += b2 * a3, S += d8 * q, S += l3 * Y2, S += y2 * m, S += B2 * (5 * J), _2 += S >>> 13, S &= 8191, v6 = _2, v6 += A4 * J, v6 += T4 * F, v6 += p4 * k2, v6 += h3 * R2, v6 += c * H, _2 = v6 >>> 13, v6 &= 8191, v6 += b2 * W4, v6 += d8 * a3, v6 += l3 * q, v6 += y2 * Y2, v6 += B2 * m, _2 += v6 >>> 13, v6 &= 8191, _2 = (_2 << 2) + _2 | 0, _2 = _2 + M | 0, M = _2 & 8191, _2 = _2 >>> 13, j += _2, A4 = M, T4 = j, p4 = P2, h3 = O3, c = C2, b2 = z2, d8 = L2, l3 = I2, y2 = S, B2 = v6, e14 += 16, r9 -= 16;
      this.h[0] = A4, this.h[1] = T4, this.h[2] = p4, this.h[3] = h3, this.h[4] = c, this.h[5] = b2, this.h[6] = d8, this.h[7] = l3, this.h[8] = y2, this.h[9] = B2;
    }, Cf.prototype.finish = function(t11, e14) {
      var r9 = new Uint16Array(10), f3, n15, i4, o16;
      if (this.leftover) {
        for (o16 = this.leftover, this.buffer[o16++] = 1; o16 < 16; o16++) this.buffer[o16] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (f3 = this.h[1] >>> 13, this.h[1] &= 8191, o16 = 2; o16 < 10; o16++)
        this.h[o16] += f3, f3 = this.h[o16] >>> 13, this.h[o16] &= 8191;
      for (this.h[0] += f3 * 5, f3 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += f3, f3 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += f3, r9[0] = this.h[0] + 5, f3 = r9[0] >>> 13, r9[0] &= 8191, o16 = 1; o16 < 10; o16++)
        r9[o16] = this.h[o16] + f3, f3 = r9[o16] >>> 13, r9[o16] &= 8191;
      for (r9[9] -= 8192, n15 = (f3 ^ 1) - 1, o16 = 0; o16 < 10; o16++) r9[o16] &= n15;
      for (n15 = ~n15, o16 = 0; o16 < 10; o16++) this.h[o16] = this.h[o16] & n15 | r9[o16];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, i4 = this.h[0] + this.pad[0], this.h[0] = i4 & 65535, o16 = 1; o16 < 8; o16++)
        i4 = (this.h[o16] + this.pad[o16] | 0) + (i4 >>> 16) | 0, this.h[o16] = i4 & 65535;
      t11[e14 + 0] = this.h[0] >>> 0 & 255, t11[e14 + 1] = this.h[0] >>> 8 & 255, t11[e14 + 2] = this.h[1] >>> 0 & 255, t11[e14 + 3] = this.h[1] >>> 8 & 255, t11[e14 + 4] = this.h[2] >>> 0 & 255, t11[e14 + 5] = this.h[2] >>> 8 & 255, t11[e14 + 6] = this.h[3] >>> 0 & 255, t11[e14 + 7] = this.h[3] >>> 8 & 255, t11[e14 + 8] = this.h[4] >>> 0 & 255, t11[e14 + 9] = this.h[4] >>> 8 & 255, t11[e14 + 10] = this.h[5] >>> 0 & 255, t11[e14 + 11] = this.h[5] >>> 8 & 255, t11[e14 + 12] = this.h[6] >>> 0 & 255, t11[e14 + 13] = this.h[6] >>> 8 & 255, t11[e14 + 14] = this.h[7] >>> 0 & 255, t11[e14 + 15] = this.h[7] >>> 8 & 255;
    }, Cf.prototype.update = function(t11, e14, r9) {
      var f3, n15;
      if (this.leftover) {
        for (n15 = 16 - this.leftover, n15 > r9 && (n15 = r9), f3 = 0; f3 < n15; f3++)
          this.buffer[this.leftover + f3] = t11[e14 + f3];
        if (r9 -= n15, e14 += n15, this.leftover += n15, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (r9 >= 16 && (n15 = r9 - r9 % 16, this.blocks(t11, e14, n15), e14 += n15, r9 -= n15), r9) {
        for (f3 = 0; f3 < r9; f3++)
          this.buffer[this.leftover + f3] = t11[e14 + f3];
        this.leftover += r9;
      }
    };
    function Gf(t11, e14, r9, f3, n15, i4) {
      var o16 = new Cf(i4);
      return o16.update(r9, f3, n15), o16.finish(t11, e14), 0;
    }
    function yt(t11, e14, r9, f3, n15, i4) {
      var o16 = new Uint8Array(16);
      return Gf(o16, 0, r9, f3, n15, i4), dt(t11, e14, o16, 0);
    }
    function Hf(t11, e14, r9, f3, n15) {
      var i4;
      if (r9 < 32) return -1;
      for (Jf(t11, 0, e14, 0, r9, f3, n15), Gf(t11, 16, t11, 32, r9 - 32, t11), i4 = 0; i4 < 16; i4++) t11[i4] = 0;
      return 0;
    }
    function Rf(t11, e14, r9, f3, n15) {
      var i4, o16 = new Uint8Array(32);
      if (r9 < 32 || (bt(o16, 0, 32, f3, n15), yt(e14, 16, e14, 32, r9 - 32, o16) !== 0)) return -1;
      for (Jf(t11, 0, e14, 0, r9, f3, n15), i4 = 0; i4 < 32; i4++) t11[i4] = 0;
      return 0;
    }
    function uf2(t11, e14) {
      var r9;
      for (r9 = 0; r9 < 16; r9++) t11[r9] = e14[r9] | 0;
    }
    function Qf(t11) {
      var e14, r9, f3 = 1;
      for (e14 = 0; e14 < 16; e14++)
        r9 = t11[e14] + f3 + 65535, f3 = Math.floor(r9 / 65536), t11[e14] = r9 - f3 * 65536;
      t11[0] += f3 - 1 + 37 * (f3 - 1);
    }
    function vf(t11, e14, r9) {
      for (var f3, n15 = ~(r9 - 1), i4 = 0; i4 < 16; i4++)
        f3 = n15 & (t11[i4] ^ e14[i4]), t11[i4] ^= f3, e14[i4] ^= f3;
    }
    function _f(t11, e14) {
      var r9, f3, n15, i4 = x(), o16 = x();
      for (r9 = 0; r9 < 16; r9++) o16[r9] = e14[r9];
      for (Qf(o16), Qf(o16), Qf(o16), f3 = 0; f3 < 2; f3++) {
        for (i4[0] = o16[0] - 65517, r9 = 1; r9 < 15; r9++)
          i4[r9] = o16[r9] - 65535 - (i4[r9 - 1] >> 16 & 1), i4[r9 - 1] &= 65535;
        i4[15] = o16[15] - 32767 - (i4[14] >> 16 & 1), n15 = i4[15] >> 16 & 1, i4[14] &= 65535, vf(o16, i4, 1 - n15);
      }
      for (r9 = 0; r9 < 16; r9++)
        t11[2 * r9] = o16[r9] & 255, t11[2 * r9 + 1] = o16[r9] >> 8;
    }
    function gt(t11, e14) {
      var r9 = new Uint8Array(32), f3 = new Uint8Array(32);
      return _f(r9, t11), _f(f3, e14), Ff(r9, 0, f3, 0);
    }
    function pt(t11) {
      var e14 = new Uint8Array(32);
      return _f(e14, t11), e14[0] & 1;
    }
    function Kf(t11, e14) {
      var r9;
      for (r9 = 0; r9 < 16; r9++) t11[r9] = e14[2 * r9] + (e14[2 * r9 + 1] << 8);
      t11[15] &= 32767;
    }
    function cf2(t11, e14, r9) {
      for (var f3 = 0; f3 < 16; f3++) t11[f3] = e14[f3] + r9[f3];
    }
    function df2(t11, e14, r9) {
      for (var f3 = 0; f3 < 16; f3++) t11[f3] = e14[f3] - r9[f3];
    }
    function D(t11, e14, r9) {
      var f3, n15, i4 = 0, o16 = 0, u = 0, g2 = 0, U3 = 0, w = 0, G = 0, _2 = 0, M = 0, j = 0, P2 = 0, O3 = 0, C2 = 0, z2 = 0, L2 = 0, I2 = 0, S = 0, v6 = 0, A4 = 0, T4 = 0, p4 = 0, h3 = 0, c = 0, b2 = 0, d8 = 0, l3 = 0, y2 = 0, B2 = 0, m = 0, Y2 = 0, q = 0, a3 = r9[0], W4 = r9[1], H = r9[2], R2 = r9[3], k2 = r9[4], F = r9[5], J = r9[6], V3 = r9[7], Q2 = r9[8], K2 = r9[9], Z2 = r9[10], X2 = r9[11], tf2 = r9[12], rf2 = r9[13], ef2 = r9[14], nf2 = r9[15];
      f3 = e14[0], i4 += f3 * a3, o16 += f3 * W4, u += f3 * H, g2 += f3 * R2, U3 += f3 * k2, w += f3 * F, G += f3 * J, _2 += f3 * V3, M += f3 * Q2, j += f3 * K2, P2 += f3 * Z2, O3 += f3 * X2, C2 += f3 * tf2, z2 += f3 * rf2, L2 += f3 * ef2, I2 += f3 * nf2, f3 = e14[1], o16 += f3 * a3, u += f3 * W4, g2 += f3 * H, U3 += f3 * R2, w += f3 * k2, G += f3 * F, _2 += f3 * J, M += f3 * V3, j += f3 * Q2, P2 += f3 * K2, O3 += f3 * Z2, C2 += f3 * X2, z2 += f3 * tf2, L2 += f3 * rf2, I2 += f3 * ef2, S += f3 * nf2, f3 = e14[2], u += f3 * a3, g2 += f3 * W4, U3 += f3 * H, w += f3 * R2, G += f3 * k2, _2 += f3 * F, M += f3 * J, j += f3 * V3, P2 += f3 * Q2, O3 += f3 * K2, C2 += f3 * Z2, z2 += f3 * X2, L2 += f3 * tf2, I2 += f3 * rf2, S += f3 * ef2, v6 += f3 * nf2, f3 = e14[3], g2 += f3 * a3, U3 += f3 * W4, w += f3 * H, G += f3 * R2, _2 += f3 * k2, M += f3 * F, j += f3 * J, P2 += f3 * V3, O3 += f3 * Q2, C2 += f3 * K2, z2 += f3 * Z2, L2 += f3 * X2, I2 += f3 * tf2, S += f3 * rf2, v6 += f3 * ef2, A4 += f3 * nf2, f3 = e14[4], U3 += f3 * a3, w += f3 * W4, G += f3 * H, _2 += f3 * R2, M += f3 * k2, j += f3 * F, P2 += f3 * J, O3 += f3 * V3, C2 += f3 * Q2, z2 += f3 * K2, L2 += f3 * Z2, I2 += f3 * X2, S += f3 * tf2, v6 += f3 * rf2, A4 += f3 * ef2, T4 += f3 * nf2, f3 = e14[5], w += f3 * a3, G += f3 * W4, _2 += f3 * H, M += f3 * R2, j += f3 * k2, P2 += f3 * F, O3 += f3 * J, C2 += f3 * V3, z2 += f3 * Q2, L2 += f3 * K2, I2 += f3 * Z2, S += f3 * X2, v6 += f3 * tf2, A4 += f3 * rf2, T4 += f3 * ef2, p4 += f3 * nf2, f3 = e14[6], G += f3 * a3, _2 += f3 * W4, M += f3 * H, j += f3 * R2, P2 += f3 * k2, O3 += f3 * F, C2 += f3 * J, z2 += f3 * V3, L2 += f3 * Q2, I2 += f3 * K2, S += f3 * Z2, v6 += f3 * X2, A4 += f3 * tf2, T4 += f3 * rf2, p4 += f3 * ef2, h3 += f3 * nf2, f3 = e14[7], _2 += f3 * a3, M += f3 * W4, j += f3 * H, P2 += f3 * R2, O3 += f3 * k2, C2 += f3 * F, z2 += f3 * J, L2 += f3 * V3, I2 += f3 * Q2, S += f3 * K2, v6 += f3 * Z2, A4 += f3 * X2, T4 += f3 * tf2, p4 += f3 * rf2, h3 += f3 * ef2, c += f3 * nf2, f3 = e14[8], M += f3 * a3, j += f3 * W4, P2 += f3 * H, O3 += f3 * R2, C2 += f3 * k2, z2 += f3 * F, L2 += f3 * J, I2 += f3 * V3, S += f3 * Q2, v6 += f3 * K2, A4 += f3 * Z2, T4 += f3 * X2, p4 += f3 * tf2, h3 += f3 * rf2, c += f3 * ef2, b2 += f3 * nf2, f3 = e14[9], j += f3 * a3, P2 += f3 * W4, O3 += f3 * H, C2 += f3 * R2, z2 += f3 * k2, L2 += f3 * F, I2 += f3 * J, S += f3 * V3, v6 += f3 * Q2, A4 += f3 * K2, T4 += f3 * Z2, p4 += f3 * X2, h3 += f3 * tf2, c += f3 * rf2, b2 += f3 * ef2, d8 += f3 * nf2, f3 = e14[10], P2 += f3 * a3, O3 += f3 * W4, C2 += f3 * H, z2 += f3 * R2, L2 += f3 * k2, I2 += f3 * F, S += f3 * J, v6 += f3 * V3, A4 += f3 * Q2, T4 += f3 * K2, p4 += f3 * Z2, h3 += f3 * X2, c += f3 * tf2, b2 += f3 * rf2, d8 += f3 * ef2, l3 += f3 * nf2, f3 = e14[11], O3 += f3 * a3, C2 += f3 * W4, z2 += f3 * H, L2 += f3 * R2, I2 += f3 * k2, S += f3 * F, v6 += f3 * J, A4 += f3 * V3, T4 += f3 * Q2, p4 += f3 * K2, h3 += f3 * Z2, c += f3 * X2, b2 += f3 * tf2, d8 += f3 * rf2, l3 += f3 * ef2, y2 += f3 * nf2, f3 = e14[12], C2 += f3 * a3, z2 += f3 * W4, L2 += f3 * H, I2 += f3 * R2, S += f3 * k2, v6 += f3 * F, A4 += f3 * J, T4 += f3 * V3, p4 += f3 * Q2, h3 += f3 * K2, c += f3 * Z2, b2 += f3 * X2, d8 += f3 * tf2, l3 += f3 * rf2, y2 += f3 * ef2, B2 += f3 * nf2, f3 = e14[13], z2 += f3 * a3, L2 += f3 * W4, I2 += f3 * H, S += f3 * R2, v6 += f3 * k2, A4 += f3 * F, T4 += f3 * J, p4 += f3 * V3, h3 += f3 * Q2, c += f3 * K2, b2 += f3 * Z2, d8 += f3 * X2, l3 += f3 * tf2, y2 += f3 * rf2, B2 += f3 * ef2, m += f3 * nf2, f3 = e14[14], L2 += f3 * a3, I2 += f3 * W4, S += f3 * H, v6 += f3 * R2, A4 += f3 * k2, T4 += f3 * F, p4 += f3 * J, h3 += f3 * V3, c += f3 * Q2, b2 += f3 * K2, d8 += f3 * Z2, l3 += f3 * X2, y2 += f3 * tf2, B2 += f3 * rf2, m += f3 * ef2, Y2 += f3 * nf2, f3 = e14[15], I2 += f3 * a3, S += f3 * W4, v6 += f3 * H, A4 += f3 * R2, T4 += f3 * k2, p4 += f3 * F, h3 += f3 * J, c += f3 * V3, b2 += f3 * Q2, d8 += f3 * K2, l3 += f3 * Z2, y2 += f3 * X2, B2 += f3 * tf2, m += f3 * rf2, Y2 += f3 * ef2, q += f3 * nf2, i4 += 38 * S, o16 += 38 * v6, u += 38 * A4, g2 += 38 * T4, U3 += 38 * p4, w += 38 * h3, G += 38 * c, _2 += 38 * b2, M += 38 * d8, j += 38 * l3, P2 += 38 * y2, O3 += 38 * B2, C2 += 38 * m, z2 += 38 * Y2, L2 += 38 * q, n15 = 1, f3 = i4 + n15 + 65535, n15 = Math.floor(f3 / 65536), i4 = f3 - n15 * 65536, f3 = o16 + n15 + 65535, n15 = Math.floor(f3 / 65536), o16 = f3 - n15 * 65536, f3 = u + n15 + 65535, n15 = Math.floor(f3 / 65536), u = f3 - n15 * 65536, f3 = g2 + n15 + 65535, n15 = Math.floor(f3 / 65536), g2 = f3 - n15 * 65536, f3 = U3 + n15 + 65535, n15 = Math.floor(f3 / 65536), U3 = f3 - n15 * 65536, f3 = w + n15 + 65535, n15 = Math.floor(f3 / 65536), w = f3 - n15 * 65536, f3 = G + n15 + 65535, n15 = Math.floor(f3 / 65536), G = f3 - n15 * 65536, f3 = _2 + n15 + 65535, n15 = Math.floor(f3 / 65536), _2 = f3 - n15 * 65536, f3 = M + n15 + 65535, n15 = Math.floor(f3 / 65536), M = f3 - n15 * 65536, f3 = j + n15 + 65535, n15 = Math.floor(f3 / 65536), j = f3 - n15 * 65536, f3 = P2 + n15 + 65535, n15 = Math.floor(f3 / 65536), P2 = f3 - n15 * 65536, f3 = O3 + n15 + 65535, n15 = Math.floor(f3 / 65536), O3 = f3 - n15 * 65536, f3 = C2 + n15 + 65535, n15 = Math.floor(f3 / 65536), C2 = f3 - n15 * 65536, f3 = z2 + n15 + 65535, n15 = Math.floor(f3 / 65536), z2 = f3 - n15 * 65536, f3 = L2 + n15 + 65535, n15 = Math.floor(f3 / 65536), L2 = f3 - n15 * 65536, f3 = I2 + n15 + 65535, n15 = Math.floor(f3 / 65536), I2 = f3 - n15 * 65536, i4 += n15 - 1 + 37 * (n15 - 1), n15 = 1, f3 = i4 + n15 + 65535, n15 = Math.floor(f3 / 65536), i4 = f3 - n15 * 65536, f3 = o16 + n15 + 65535, n15 = Math.floor(f3 / 65536), o16 = f3 - n15 * 65536, f3 = u + n15 + 65535, n15 = Math.floor(f3 / 65536), u = f3 - n15 * 65536, f3 = g2 + n15 + 65535, n15 = Math.floor(f3 / 65536), g2 = f3 - n15 * 65536, f3 = U3 + n15 + 65535, n15 = Math.floor(f3 / 65536), U3 = f3 - n15 * 65536, f3 = w + n15 + 65535, n15 = Math.floor(f3 / 65536), w = f3 - n15 * 65536, f3 = G + n15 + 65535, n15 = Math.floor(f3 / 65536), G = f3 - n15 * 65536, f3 = _2 + n15 + 65535, n15 = Math.floor(f3 / 65536), _2 = f3 - n15 * 65536, f3 = M + n15 + 65535, n15 = Math.floor(f3 / 65536), M = f3 - n15 * 65536, f3 = j + n15 + 65535, n15 = Math.floor(f3 / 65536), j = f3 - n15 * 65536, f3 = P2 + n15 + 65535, n15 = Math.floor(f3 / 65536), P2 = f3 - n15 * 65536, f3 = O3 + n15 + 65535, n15 = Math.floor(f3 / 65536), O3 = f3 - n15 * 65536, f3 = C2 + n15 + 65535, n15 = Math.floor(f3 / 65536), C2 = f3 - n15 * 65536, f3 = z2 + n15 + 65535, n15 = Math.floor(f3 / 65536), z2 = f3 - n15 * 65536, f3 = L2 + n15 + 65535, n15 = Math.floor(f3 / 65536), L2 = f3 - n15 * 65536, f3 = I2 + n15 + 65535, n15 = Math.floor(f3 / 65536), I2 = f3 - n15 * 65536, i4 += n15 - 1 + 37 * (n15 - 1), t11[0] = i4, t11[1] = o16, t11[2] = u, t11[3] = g2, t11[4] = U3, t11[5] = w, t11[6] = G, t11[7] = _2, t11[8] = M, t11[9] = j, t11[10] = P2, t11[11] = O3, t11[12] = C2, t11[13] = z2, t11[14] = L2, t11[15] = I2;
    }
    function hf2(t11, e14) {
      D(t11, e14, e14);
    }
    function wt(t11, e14) {
      var r9 = x(), f3;
      for (f3 = 0; f3 < 16; f3++) r9[f3] = e14[f3];
      for (f3 = 253; f3 >= 0; f3--)
        hf2(r9, r9), f3 !== 2 && f3 !== 4 && D(r9, r9, e14);
      for (f3 = 0; f3 < 16; f3++) t11[f3] = r9[f3];
    }
    function vt(t11, e14) {
      var r9 = x(), f3;
      for (f3 = 0; f3 < 16; f3++) r9[f3] = e14[f3];
      for (f3 = 250; f3 >= 0; f3--)
        hf2(r9, r9), f3 !== 1 && D(r9, r9, e14);
      for (f3 = 0; f3 < 16; f3++) t11[f3] = r9[f3];
    }
    function Lf(t11, e14, r9) {
      var f3 = new Uint8Array(32), n15 = new Float64Array(80), i4, o16, u = x(), g2 = x(), U3 = x(), w = x(), G = x(), _2 = x();
      for (o16 = 0; o16 < 31; o16++) f3[o16] = e14[o16];
      for (f3[31] = e14[31] & 127 | 64, f3[0] &= 248, Kf(n15, r9), o16 = 0; o16 < 16; o16++)
        g2[o16] = n15[o16], w[o16] = u[o16] = U3[o16] = 0;
      for (u[0] = w[0] = 1, o16 = 254; o16 >= 0; --o16)
        i4 = f3[o16 >>> 3] >>> (o16 & 7) & 1, vf(u, g2, i4), vf(U3, w, i4), cf2(G, u, U3), df2(u, u, U3), cf2(U3, g2, w), df2(g2, g2, w), hf2(w, G), hf2(_2, u), D(u, U3, u), D(U3, g2, G), cf2(G, u, U3), df2(u, u, U3), hf2(g2, u), df2(U3, w, _2), D(u, U3, zt), cf2(u, u, w), D(U3, U3, u), D(u, w, _2), D(w, g2, n15), hf2(g2, G), vf(u, g2, i4), vf(U3, w, i4);
      for (o16 = 0; o16 < 16; o16++)
        n15[o16 + 16] = u[o16], n15[o16 + 32] = U3[o16], n15[o16 + 48] = g2[o16], n15[o16 + 64] = w[o16];
      var M = n15.subarray(32), j = n15.subarray(16);
      return wt(M, M), D(j, j, M), _f(t11, j), 0;
    }
    function zf(t11, e14) {
      return Lf(t11, e14, ff2);
    }
    function _t2(t11, e14) {
      return $2(e14, 32), zf(t11, e14);
    }
    function Of(t11, e14, r9) {
      var f3 = new Uint8Array(32);
      return Lf(f3, r9, e14), jf(t11, N2, f3, bf2);
    }
    var Et = Hf, Yt = Rf;
    function kt(t11, e14, r9, f3, n15, i4) {
      var o16 = new Uint8Array(32);
      return Of(o16, n15, i4), Et(t11, e14, r9, f3, o16);
    }
    function Wt2(t11, e14, r9, f3, n15, i4) {
      var o16 = new Uint8Array(32);
      return Of(o16, n15, i4), Yt(t11, e14, r9, f3, o16);
    }
    var It2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function At(t11, e14, r9, f3) {
      for (var n15 = new Int32Array(16), i4 = new Int32Array(16), o16, u, g2, U3, w, G, _2, M, j, P2, O3, C2, z2, L2, I2, S, v6, A4, T4, p4, h3, c, b2, d8, l3, y2, B2 = t11[0], m = t11[1], Y2 = t11[2], q = t11[3], a3 = t11[4], W4 = t11[5], H = t11[6], R2 = t11[7], k2 = e14[0], F = e14[1], J = e14[2], V3 = e14[3], Q2 = e14[4], K2 = e14[5], Z2 = e14[6], X2 = e14[7], tf2 = 0; f3 >= 128; ) {
        for (T4 = 0; T4 < 16; T4++)
          p4 = 8 * T4 + tf2, n15[T4] = r9[p4 + 0] << 24 | r9[p4 + 1] << 16 | r9[p4 + 2] << 8 | r9[p4 + 3], i4[T4] = r9[p4 + 4] << 24 | r9[p4 + 5] << 16 | r9[p4 + 6] << 8 | r9[p4 + 7];
        for (T4 = 0; T4 < 80; T4++)
          if (o16 = B2, u = m, g2 = Y2, U3 = q, w = a3, G = W4, _2 = H, M = R2, j = k2, P2 = F, O3 = J, C2 = V3, z2 = Q2, L2 = K2, I2 = Z2, S = X2, h3 = R2, c = X2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = (a3 >>> 14 | Q2 << 18) ^ (a3 >>> 18 | Q2 << 14) ^ (Q2 >>> 9 | a3 << 23), c = (Q2 >>> 14 | a3 << 18) ^ (Q2 >>> 18 | a3 << 14) ^ (a3 >>> 9 | Q2 << 23), b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, h3 = a3 & W4 ^ ~a3 & H, c = Q2 & K2 ^ ~Q2 & Z2, b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, h3 = It2[T4 * 2], c = It2[T4 * 2 + 1], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, h3 = n15[T4 % 16], c = i4[T4 % 16], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, v6 = l3 & 65535 | y2 << 16, A4 = b2 & 65535 | d8 << 16, h3 = v6, c = A4, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = (B2 >>> 28 | k2 << 4) ^ (k2 >>> 2 | B2 << 30) ^ (k2 >>> 7 | B2 << 25), c = (k2 >>> 28 | B2 << 4) ^ (B2 >>> 2 | k2 << 30) ^ (B2 >>> 7 | k2 << 25), b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, h3 = B2 & m ^ B2 & Y2 ^ m & Y2, c = k2 & F ^ k2 & J ^ F & J, b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, M = l3 & 65535 | y2 << 16, S = b2 & 65535 | d8 << 16, h3 = U3, c = C2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = v6, c = A4, b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, U3 = l3 & 65535 | y2 << 16, C2 = b2 & 65535 | d8 << 16, m = o16, Y2 = u, q = g2, a3 = U3, W4 = w, H = G, R2 = _2, B2 = M, F = j, J = P2, V3 = O3, Q2 = C2, K2 = z2, Z2 = L2, X2 = I2, k2 = S, T4 % 16 === 15)
            for (p4 = 0; p4 < 16; p4++)
              h3 = n15[p4], c = i4[p4], b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = n15[(p4 + 9) % 16], c = i4[(p4 + 9) % 16], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, v6 = n15[(p4 + 1) % 16], A4 = i4[(p4 + 1) % 16], h3 = (v6 >>> 1 | A4 << 31) ^ (v6 >>> 8 | A4 << 24) ^ v6 >>> 7, c = (A4 >>> 1 | v6 << 31) ^ (A4 >>> 8 | v6 << 24) ^ (A4 >>> 7 | v6 << 25), b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, v6 = n15[(p4 + 14) % 16], A4 = i4[(p4 + 14) % 16], h3 = (v6 >>> 19 | A4 << 13) ^ (A4 >>> 29 | v6 << 3) ^ v6 >>> 6, c = (A4 >>> 19 | v6 << 13) ^ (v6 >>> 29 | A4 << 3) ^ (A4 >>> 6 | v6 << 26), b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, n15[p4] = l3 & 65535 | y2 << 16, i4[p4] = b2 & 65535 | d8 << 16;
        h3 = B2, c = k2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[0], c = e14[0], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[0] = B2 = l3 & 65535 | y2 << 16, e14[0] = k2 = b2 & 65535 | d8 << 16, h3 = m, c = F, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[1], c = e14[1], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[1] = m = l3 & 65535 | y2 << 16, e14[1] = F = b2 & 65535 | d8 << 16, h3 = Y2, c = J, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[2], c = e14[2], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[2] = Y2 = l3 & 65535 | y2 << 16, e14[2] = J = b2 & 65535 | d8 << 16, h3 = q, c = V3, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[3], c = e14[3], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[3] = q = l3 & 65535 | y2 << 16, e14[3] = V3 = b2 & 65535 | d8 << 16, h3 = a3, c = Q2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[4], c = e14[4], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[4] = a3 = l3 & 65535 | y2 << 16, e14[4] = Q2 = b2 & 65535 | d8 << 16, h3 = W4, c = K2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[5], c = e14[5], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[5] = W4 = l3 & 65535 | y2 << 16, e14[5] = K2 = b2 & 65535 | d8 << 16, h3 = H, c = Z2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[6], c = e14[6], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[6] = H = l3 & 65535 | y2 << 16, e14[6] = Z2 = b2 & 65535 | d8 << 16, h3 = R2, c = X2, b2 = c & 65535, d8 = c >>> 16, l3 = h3 & 65535, y2 = h3 >>> 16, h3 = t11[7], c = e14[7], b2 += c & 65535, d8 += c >>> 16, l3 += h3 & 65535, y2 += h3 >>> 16, d8 += b2 >>> 16, l3 += d8 >>> 16, y2 += l3 >>> 16, t11[7] = R2 = l3 & 65535 | y2 << 16, e14[7] = X2 = b2 & 65535 | d8 << 16, tf2 += 128, f3 -= 128;
      }
      return f3;
    }
    function yf(t11, e14, r9) {
      var f3 = new Int32Array(8), n15 = new Int32Array(8), i4 = new Uint8Array(256), o16, u = r9;
      for (f3[0] = 1779033703, f3[1] = 3144134277, f3[2] = 1013904242, f3[3] = 2773480762, f3[4] = 1359893119, f3[5] = 2600822924, f3[6] = 528734635, f3[7] = 1541459225, n15[0] = 4089235720, n15[1] = 2227873595, n15[2] = 4271175723, n15[3] = 1595750129, n15[4] = 2917565137, n15[5] = 725511199, n15[6] = 4215389547, n15[7] = 327033209, At(f3, n15, e14, r9), r9 %= 128, o16 = 0; o16 < r9; o16++) i4[o16] = e14[u - r9 + o16];
      for (i4[r9] = 128, r9 = 256 - 128 * (r9 < 112 ? 1 : 0), i4[r9 - 9] = 0, ct(i4, r9 - 8, u / 536870912 | 0, u << 3), At(f3, n15, i4, r9), o16 = 0; o16 < 8; o16++) ct(t11, 8 * o16, f3[o16], n15[o16]);
      return 0;
    }
    function Pf(t11, e14) {
      var r9 = x(), f3 = x(), n15 = x(), i4 = x(), o16 = x(), u = x(), g2 = x(), U3 = x(), w = x();
      df2(r9, t11[1], t11[0]), df2(w, e14[1], e14[0]), D(r9, r9, w), cf2(f3, t11[0], t11[1]), cf2(w, e14[0], e14[1]), D(f3, f3, w), D(n15, t11[3], e14[3]), D(n15, n15, Ot), D(i4, t11[2], e14[2]), cf2(i4, i4, i4), df2(o16, f3, r9), df2(u, i4, n15), cf2(g2, i4, n15), cf2(U3, f3, r9), D(t11[0], o16, u), D(t11[1], U3, g2), D(t11[2], g2, u), D(t11[3], o16, U3);
    }
    function Tt2(t11, e14, r9) {
      var f3;
      for (f3 = 0; f3 < 4; f3++)
        vf(t11[f3], e14[f3], r9);
    }
    function Zf(t11, e14) {
      var r9 = x(), f3 = x(), n15 = x();
      wt(n15, e14[2]), D(r9, e14[0], n15), D(f3, e14[1], n15), _f(t11, f3), t11[31] ^= pt(r9) << 7;
    }
    function Xf(t11, e14, r9) {
      var f3, n15;
      for (uf2(t11[0], of2), uf2(t11[1], wf), uf2(t11[2], wf), uf2(t11[3], of2), n15 = 255; n15 >= 0; --n15)
        f3 = r9[n15 / 8 | 0] >> (n15 & 7) & 1, Tt2(t11, e14, f3), Pf(e14, t11), Pf(t11, t11), Tt2(t11, e14, f3);
    }
    function mf(t11, e14) {
      var r9 = [x(), x(), x(), x()];
      uf2(r9[0], st3), uf2(r9[1], ht), uf2(r9[2], wf), D(r9[3], st3, ht), Xf(t11, r9, e14);
    }
    function Vf(t11, e14, r9) {
      var f3 = new Uint8Array(64), n15 = [x(), x(), x(), x()], i4;
      for (r9 || $2(e14, 32), yf(f3, e14, 32), f3[0] &= 248, f3[31] &= 127, f3[31] |= 64, mf(n15, f3), Zf(t11, n15), i4 = 0; i4 < 32; i4++) e14[i4 + 32] = t11[i4];
      return 0;
    }
    var qf = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function ft(t11, e14) {
      var r9, f3, n15, i4;
      for (f3 = 63; f3 >= 32; --f3) {
        for (r9 = 0, n15 = f3 - 32, i4 = f3 - 12; n15 < i4; ++n15)
          e14[n15] += r9 - 16 * e14[f3] * qf[n15 - (f3 - 32)], r9 = Math.floor((e14[n15] + 128) / 256), e14[n15] -= r9 * 256;
        e14[n15] += r9, e14[f3] = 0;
      }
      for (r9 = 0, n15 = 0; n15 < 32; n15++)
        e14[n15] += r9 - (e14[31] >> 4) * qf[n15], r9 = e14[n15] >> 8, e14[n15] &= 255;
      for (n15 = 0; n15 < 32; n15++) e14[n15] -= r9 * qf[n15];
      for (f3 = 0; f3 < 32; f3++)
        e14[f3 + 1] += e14[f3] >> 8, t11[f3] = e14[f3] & 255;
    }
    function tt(t11) {
      var e14 = new Float64Array(64), r9;
      for (r9 = 0; r9 < 64; r9++) e14[r9] = t11[r9];
      for (r9 = 0; r9 < 64; r9++) t11[r9] = 0;
      ft(t11, e14);
    }
    function Ut(t11, e14, r9, f3) {
      var n15 = new Uint8Array(64), i4 = new Uint8Array(64), o16 = new Uint8Array(64), u, g2, U3 = new Float64Array(64), w = [x(), x(), x(), x()];
      yf(n15, f3, 32), n15[0] &= 248, n15[31] &= 127, n15[31] |= 64;
      var G = r9 + 64;
      for (u = 0; u < r9; u++) t11[64 + u] = e14[u];
      for (u = 0; u < 32; u++) t11[32 + u] = n15[32 + u];
      for (yf(o16, t11.subarray(32), r9 + 32), tt(o16), mf(w, o16), Zf(t11, w), u = 32; u < 64; u++) t11[u] = f3[u];
      for (yf(i4, t11, r9 + 64), tt(i4), u = 0; u < 64; u++) U3[u] = 0;
      for (u = 0; u < 32; u++) U3[u] = o16[u];
      for (u = 0; u < 32; u++)
        for (g2 = 0; g2 < 32; g2++)
          U3[u + g2] += i4[u] * n15[g2];
      return ft(t11.subarray(32), U3), G;
    }
    function Nt(t11, e14) {
      var r9 = x(), f3 = x(), n15 = x(), i4 = x(), o16 = x(), u = x(), g2 = x();
      return uf2(t11[2], wf), Kf(t11[1], e14), hf2(n15, t11[1]), D(i4, n15, xt), df2(n15, n15, t11[2]), cf2(i4, t11[2], i4), hf2(o16, i4), hf2(u, o16), D(g2, u, o16), D(r9, g2, n15), D(r9, r9, i4), vt(r9, r9), D(r9, r9, n15), D(r9, r9, i4), D(r9, r9, i4), D(t11[0], r9, i4), hf2(f3, t11[0]), D(f3, f3, i4), gt(f3, n15) && D(t11[0], t11[0], Pt), hf2(f3, t11[0]), D(f3, f3, i4), gt(f3, n15) ? -1 : (pt(t11[0]) === e14[31] >> 7 && df2(t11[0], of2, t11[0]), D(t11[3], t11[0], t11[1]), 0);
    }
    function rt(t11, e14, r9, f3) {
      var n15, i4 = new Uint8Array(32), o16 = new Uint8Array(64), u = [x(), x(), x(), x()], g2 = [x(), x(), x(), x()];
      if (r9 < 64 || Nt(g2, f3)) return -1;
      for (n15 = 0; n15 < r9; n15++) t11[n15] = e14[n15];
      for (n15 = 0; n15 < 32; n15++) t11[n15 + 32] = f3[n15];
      if (yf(o16, t11, r9), tt(o16), Xf(u, g2, o16), mf(g2, e14.subarray(32)), Pf(u, g2), Zf(i4, u), r9 -= 64, Ff(e14, 0, i4, 0)) {
        for (n15 = 0; n15 < r9; n15++) t11[n15] = 0;
        return -1;
      }
      for (n15 = 0; n15 < r9; n15++) t11[n15] = e14[n15 + 64];
      return r9;
    }
    var et = 32, Yf = 24, Af2 = 32, Ef = 16, Tf = 32, kf = 32, Uf = 32, Sf = 32, nt2 = 32, St2 = Yf, Dt2 = Af2, Ft = Ef, lf2 = 64, gf = 32, If = 64, at = 32, it = 64;
    s5.lowlevel = {
      crypto_core_hsalsa20: jf,
      crypto_stream_xor: Jf,
      crypto_stream: bt,
      crypto_stream_salsa20_xor: ut2,
      crypto_stream_salsa20: lt,
      crypto_onetimeauth: Gf,
      crypto_onetimeauth_verify: yt,
      crypto_verify_16: dt,
      crypto_verify_32: Ff,
      crypto_secretbox: Hf,
      crypto_secretbox_open: Rf,
      crypto_scalarmult: Lf,
      crypto_scalarmult_base: zf,
      crypto_box_beforenm: Of,
      crypto_box_afternm: Et,
      crypto_box: kt,
      crypto_box_open: Wt2,
      crypto_box_keypair: _t2,
      crypto_hash: yf,
      crypto_sign: Ut,
      crypto_sign_keypair: Vf,
      crypto_sign_open: rt,
      crypto_secretbox_KEYBYTES: et,
      crypto_secretbox_NONCEBYTES: Yf,
      crypto_secretbox_ZEROBYTES: Af2,
      crypto_secretbox_BOXZEROBYTES: Ef,
      crypto_scalarmult_BYTES: Tf,
      crypto_scalarmult_SCALARBYTES: kf,
      crypto_box_PUBLICKEYBYTES: Uf,
      crypto_box_SECRETKEYBYTES: Sf,
      crypto_box_BEFORENMBYTES: nt2,
      crypto_box_NONCEBYTES: St2,
      crypto_box_ZEROBYTES: Dt2,
      crypto_box_BOXZEROBYTES: Ft,
      crypto_sign_BYTES: lf2,
      crypto_sign_PUBLICKEYBYTES: gf,
      crypto_sign_SECRETKEYBYTES: If,
      crypto_sign_SEEDBYTES: at,
      crypto_hash_BYTES: it,
      gf: x,
      D: xt,
      L: qf,
      pack25519: _f,
      unpack25519: Kf,
      M: D,
      A: cf2,
      S: hf2,
      Z: df2,
      pow2523: vt,
      add: Pf,
      set25519: uf2,
      modL: ft,
      scalarmult: Xf,
      scalarbase: mf
    };
    function Bt2(t11, e14) {
      if (t11.length !== et) throw new Error("bad key size");
      if (e14.length !== Yf) throw new Error("bad nonce size");
    }
    function Jt(t11, e14) {
      if (t11.length !== Uf) throw new Error("bad public key size");
      if (e14.length !== Sf) throw new Error("bad secret key size");
    }
    function sf2() {
      for (var t11 = 0; t11 < arguments.length; t11++)
        if (!(arguments[t11] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function $t2(t11) {
      for (var e14 = 0; e14 < t11.length; e14++) t11[e14] = 0;
    }
    s5.randomBytes = function(t11) {
      var e14 = new Uint8Array(t11);
      return $2(e14, t11), e14;
    }, s5.secretbox = function(t11, e14, r9) {
      sf2(t11, e14, r9), Bt2(r9, e14);
      for (var f3 = new Uint8Array(Af2 + t11.length), n15 = new Uint8Array(f3.length), i4 = 0; i4 < t11.length; i4++) f3[i4 + Af2] = t11[i4];
      return Hf(n15, f3, f3.length, e14, r9), n15.subarray(Ef);
    }, s5.secretbox.open = function(t11, e14, r9) {
      sf2(t11, e14, r9), Bt2(r9, e14);
      for (var f3 = new Uint8Array(Ef + t11.length), n15 = new Uint8Array(f3.length), i4 = 0; i4 < t11.length; i4++) f3[i4 + Ef] = t11[i4];
      return f3.length < 32 || Rf(n15, f3, f3.length, e14, r9) !== 0 ? null : n15.subarray(Af2);
    }, s5.secretbox.keyLength = et, s5.secretbox.nonceLength = Yf, s5.secretbox.overheadLength = Ef, s5.scalarMult = function(t11, e14) {
      if (sf2(t11, e14), t11.length !== kf) throw new Error("bad n size");
      if (e14.length !== Tf) throw new Error("bad p size");
      var r9 = new Uint8Array(Tf);
      return Lf(r9, t11, e14), r9;
    }, s5.scalarMult.base = function(t11) {
      if (sf2(t11), t11.length !== kf) throw new Error("bad n size");
      var e14 = new Uint8Array(Tf);
      return zf(e14, t11), e14;
    }, s5.scalarMult.scalarLength = kf, s5.scalarMult.groupElementLength = Tf, s5.box = function(t11, e14, r9, f3) {
      var n15 = s5.box.before(r9, f3);
      return s5.secretbox(t11, e14, n15);
    }, s5.box.before = function(t11, e14) {
      sf2(t11, e14), Jt(t11, e14);
      var r9 = new Uint8Array(nt2);
      return Of(r9, t11, e14), r9;
    }, s5.box.after = s5.secretbox, s5.box.open = function(t11, e14, r9, f3) {
      var n15 = s5.box.before(r9, f3);
      return s5.secretbox.open(t11, e14, n15);
    }, s5.box.open.after = s5.secretbox.open, s5.box.keyPair = function() {
      var t11 = new Uint8Array(Uf), e14 = new Uint8Array(Sf);
      return _t2(t11, e14), { publicKey: t11, secretKey: e14 };
    }, s5.box.keyPair.fromSecretKey = function(t11) {
      if (sf2(t11), t11.length !== Sf)
        throw new Error("bad secret key size");
      var e14 = new Uint8Array(Uf);
      return zf(e14, t11), { publicKey: e14, secretKey: new Uint8Array(t11) };
    }, s5.box.publicKeyLength = Uf, s5.box.secretKeyLength = Sf, s5.box.sharedKeyLength = nt2, s5.box.nonceLength = St2, s5.box.overheadLength = s5.secretbox.overheadLength, s5.sign = function(t11, e14) {
      if (sf2(t11, e14), e14.length !== If)
        throw new Error("bad secret key size");
      var r9 = new Uint8Array(lf2 + t11.length);
      return Ut(r9, t11, t11.length, e14), r9;
    }, s5.sign.open = function(t11, e14) {
      if (sf2(t11, e14), e14.length !== gf)
        throw new Error("bad public key size");
      var r9 = new Uint8Array(t11.length), f3 = rt(r9, t11, t11.length, e14);
      if (f3 < 0) return null;
      for (var n15 = new Uint8Array(f3), i4 = 0; i4 < n15.length; i4++) n15[i4] = r9[i4];
      return n15;
    }, s5.sign.detached = function(t11, e14) {
      for (var r9 = s5.sign(t11, e14), f3 = new Uint8Array(lf2), n15 = 0; n15 < f3.length; n15++) f3[n15] = r9[n15];
      return f3;
    }, s5.sign.detached.verify = function(t11, e14, r9) {
      if (sf2(t11, e14, r9), e14.length !== lf2)
        throw new Error("bad signature size");
      if (r9.length !== gf)
        throw new Error("bad public key size");
      var f3 = new Uint8Array(lf2 + t11.length), n15 = new Uint8Array(lf2 + t11.length), i4;
      for (i4 = 0; i4 < lf2; i4++) f3[i4] = e14[i4];
      for (i4 = 0; i4 < t11.length; i4++) f3[i4 + lf2] = t11[i4];
      return rt(n15, f3, f3.length, r9) >= 0;
    }, s5.sign.keyPair = function() {
      var t11 = new Uint8Array(gf), e14 = new Uint8Array(If);
      return Vf(t11, e14), { publicKey: t11, secretKey: e14 };
    }, s5.sign.keyPair.fromSecretKey = function(t11) {
      if (sf2(t11), t11.length !== If)
        throw new Error("bad secret key size");
      for (var e14 = new Uint8Array(gf), r9 = 0; r9 < e14.length; r9++) e14[r9] = t11[32 + r9];
      return { publicKey: e14, secretKey: new Uint8Array(t11) };
    }, s5.sign.keyPair.fromSeed = function(t11) {
      if (sf2(t11), t11.length !== at)
        throw new Error("bad seed size");
      for (var e14 = new Uint8Array(gf), r9 = new Uint8Array(If), f3 = 0; f3 < 32; f3++) r9[f3] = t11[f3];
      return Vf(e14, r9, true), { publicKey: e14, secretKey: r9 };
    }, s5.sign.publicKeyLength = gf, s5.sign.secretKeyLength = If, s5.sign.seedLength = at, s5.sign.signatureLength = lf2, s5.hash = function(t11) {
      sf2(t11);
      var e14 = new Uint8Array(it);
      return yf(e14, t11, t11.length), e14;
    }, s5.hash.hashLength = it, s5.verify = function(t11, e14) {
      return sf2(t11, e14), t11.length === 0 || e14.length === 0 || t11.length !== e14.length ? false : Df(t11, 0, e14, 0, t11.length) === 0;
    }, s5.setPRNG = function(t11) {
      $2 = t11;
    }, function() {
      var t11 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (t11 && t11.getRandomValues) {
        var e14 = 65536;
        s5.setPRNG(function(r9, f3) {
          var n15, i4 = new Uint8Array(f3);
          for (n15 = 0; n15 < f3; n15 += e14)
            t11.getRandomValues(i4.subarray(n15, n15 + Math.min(f3 - n15, e14)));
          for (n15 = 0; n15 < f3; n15++) r9[n15] = i4[n15];
          $t2(i4);
        });
      } else typeof Vt < "u" && (t11 = er, t11 && t11.randomBytes && s5.setPRNG(function(r9, f3) {
        var n15, i4 = t11.randomBytes(f3);
        for (n15 = 0; n15 < f3; n15++) r9[n15] = i4[n15];
        $t2(i4);
      }));
    }();
  })(E2.exports ? E2.exports : self.nacl = self.nacl || {});
})(fr);
function nr(E2, s5) {
  const x = $f.encodeBase64(E2);
  return s5 ? encodeURIComponent(x) : x;
}
function ar(E2, s5) {
  return s5 && (E2 = decodeURIComponent(E2)), $f.decodeBase64(E2);
}
function ir(E2, s5 = false) {
  let x;
  return E2 instanceof Uint8Array ? x = E2 : (typeof E2 != "string" && (E2 = JSON.stringify(E2)), x = $f.decodeUTF8(E2)), nr(x, s5);
}
function or(E2, s5 = false) {
  const x = ar(E2, s5);
  return {
    toString() {
      return $f.encodeUTF8(x);
    },
    toObject() {
      try {
        return JSON.parse($f.encodeUTF8(x));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return x;
    }
  };
}
var Wf = {
  encode: ir,
  decode: or
};
new AbortController();
var xr = (E2) => {
  var x;
  if (!E2) return new Error("JWT Token not found. ");
  const s5 = jwtDecode(E2);
  if ((s5 == null ? void 0 : s5.exp) < Date.now() / 1e3)
    throw new Error("JWT Token expired. Please login again! ");
  if ((x = s5 == null ? void 0 : s5["https://hasura.io/jwt/claims"]) != null && x["x-hasura-user-id"])
    return [s5["https://hasura.io/jwt/claims"]["x-hasura-user-id"], E2];
  throw new Error("User id not found in JWT Token");
};
var sr = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "") {
    tgLogin(appId: $appId, initData: $initData)
  }
`;
var hr = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "", $shortId: String = "") {
    tgLogin(appId: $appId, initData: $initData, shortId: $shortId)
  }
`;
var cr = gql`
  mutation tgWidgetLoginMutation($appId: String = "", $authData: String = "") {
    tgWidgetLogin(appId: $appId, authData: $authData)
  }
`;
var dr = gql`
  mutation tgWidgetLoginMutation(
    $appId: String = ""
    $authData: String = ""
    $shortId: String = ""
  ) {
    tgWidgetLogin(appId: $appId, authData: $authData, shortId: $shortId)
  }
`;
var ur = gql`
  query CheckUserIsExistQueryByTgId {
    telegramUser {
      walletUserId
      tgId
    }
  }
`;
var jt = gql`
  query UserWalletAddressQuery($id: uuid = "") {
    walletUserByPk(id: $id) {
      sub_wallets {
        address
        publicKey
      }
      google_user {
        email
      }
      telegram_user {
        firstName
        lastName
        photoUrl
        userName
      }
      twitter_user {
        name
        userName
      }
    }
  }
`;
var lr = gql`
  mutation CreateOrderQuery($appId: String = "", $payload: String = "") {
    createOrder(appId: $appId, payload: $payload, encode: "base64")
  }
`;
var br = gql`
  mutation createSignatureMutation($appId: String = "", $transactionHex: String = "") {
    createSignature(appId: $appId, transactionHex: $transactionHex)
  }
`;
var yr = gql`
  mutation createSignMessageMutation(
    $appId: String = ""
    $message: String = ""
    $nonce: String = ""
  ) {
    createSignMessage(appId: $appId, nonce: $nonce, message: $message) {
      fullMessage
      message
      nonce
      prefix
      signature
    }
  }
`;
var gr = gql`
  query simulateOrderQuery($payload: String = "") {
    simulateOrder(payload: $payload, encode: "base64")
  }
`;
var pr = gql`
  mutation confirmOrderQuery($orderId: String = "") {
    confirmOrder(orderId: $orderId)
  }
`;
var wr = gql`
  query fetchOrderQuery($id: uuid = "") {
    orderByPk(id: $id) {
      id
      createdAt
      payload
      decodedPayload
      status
      type
      updatedAt
      walletUserId
      applicationId
      hash
      type
      transactions {
        hash
        type
      }
    }
  }
`;
gql`
  query fetchOrderHashQuery($orderId: String = "") {
    getOrderHash(orderId: $orderId)
  }
`;
var vr = gql`
  query fetchOrderListQuery(
    $walletUserId: uuid = ""
    $limit: Int = 10
    $offset: Int = 0
    $status: [Int] = []
  ) {
    order(
      where: { walletUserId: { _eq: $walletUserId } }
      limit: $limit
      offset: $offset
      orderBy: { createdAt: DESC }
    ) {
      applicationId
      createdAt
      id
      payload
      decodedPayload
      status
      transactionSeqNo
      type
      updatedAt
      walletUserId
      hash
      gasFee
      transactions {
        hash
        gasFee
        createdAt
        status
        type
      }
    }
    orderAggregate(where: { walletUserId: { _eq: $walletUserId } }) {
      aggregate {
        count
      }
    }
  }
`;
var _r = gql`
  mutation bindGoogleQuery($address: String = "", $idToken: String = "") {
    googleBind(address: $address, idToken: $idToken)
  }
`;
var Er = gql`
  mutation createOrderWithCodeMutation(
    $appId: String = ""
    $authCode: String = ""
    $payload: String = ""
  ) {
    createOrderWithCode(appId: $appId, authCode: $authCode, payload: $payload, encode: "base64")
  }
`;
var ot3 = (E2) => ({
  function: E2.function,
  functionArguments: E2.functionArguments || E2.arguments,
  typeArguments: E2.typeArguments || E2.type_arguments
});
var Bf = ((E2) => (E2[E2.PENDING = 0] = "PENDING", E2[E2.CONFIRMED = 1] = "CONFIRMED", E2[E2.EXECUTED = 2] = "EXECUTED", E2[E2.SUCCESS = 3] = "SUCCESS", E2[E2.FAIL = 4] = "FAIL", E2[E2.CANCELED = 5] = "CANCELED", E2))(Bf || {});
var Ct = {
  testnet: "https://hasura-wallet.mizu.one/v1/graphql",
  mainnet: "https://api.mz.xyz/v1/graphql/"
};
var Ir = "https://mizu.io/keyless_google";
var Nf = class _Nf {
  /**
   * Initialize MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   */
  constructor(s5) {
    pf(this, "appId");
    pf(this, "network");
    pf(this, "graphqlEndPoint", "");
    pf(this, "userId", "");
    pf(this, "jwtToken", "");
    pf(this, "initialized", false);
    if (!s5.appId) throw new Error("appId is required");
    if (!s5.network) throw new Error("network is required");
    this.appId = s5.appId, this.network = s5.network, this.graphqlEndPoint = Ct[this.network], this.initialized = true;
  }
  /**
   * Check if MizuWallet SDK Core Client is initialized
   */
  checkInitialized() {
    if (!this.initialized) throw new Error("MizuWallet SDK Core Client not initialized");
  }
  /**
   * Check if JWT Token is available
   */
  checkJWTToken() {
    if (!this.jwtToken) throw new Error("JWT Token not found. Please login first.");
  }
  /**
   * Decode JWT Token
   */
  static decodeJWTToken(s5) {
    const [x, $2] = xr(s5);
    return [x, $2];
  }
  /**
   * Clone MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   * @param args.jwtToken - JWT Token
   */
  static clone(s5) {
    if (!s5.appId) throw new Error("appId is required");
    if (!s5.network) throw new Error("network is required");
    if (!s5.jwtToken) throw new Error("jwtToken is required");
    const x = new _Nf({ appId: s5.appId, network: s5.network });
    return [x.userId, x.jwtToken] = _Nf.decodeJWTToken(s5.jwtToken), x;
  }
  /**
   * Update network
   * @param network - Network.MAINNET | Network.TESTNET
   */
  updateNetwork(s5) {
    this.checkInitialized(), this.network = s5, this.graphqlEndPoint = Ct[this.network];
  }
  /**
   * Get network info
   */
  get networkInfo() {
    return {
      name: this.network,
      chainId: this.network === e.MAINNET ? 1 : 2,
      url: this.network === e.MAINNET ? "https://fullnode.mainnet.aptoslabs.com/v1" : "https://fullnode.testnet.aptoslabs.com/v1"
    };
  }
  /**
   *
   *
   */
  login() {
    this.checkInitialized();
  }
  /**
   * Login in TG
   *
   * @param data - initial data of TG, or stringified widget user object
   * @param opt.isWidget - is from login widget
   */
  async loginInTG(s5, x) {
    this.checkInitialized();
    let $2 = "";
    x != null && x.isWidget ? $2 = (await main_default({
      url: this.graphqlEndPoint,
      document: x != null && x.shortID ? dr : cr,
      variables: {
        appId: this.appId,
        authData: Wf.encode(s5),
        ...x != null && x.shortID ? { shortId: x.shortID } : {}
      }
    })).tgWidgetLogin : $2 = (await main_default({
      url: this.graphqlEndPoint,
      document: x != null && x.shortID ? hr : sr,
      variables: {
        appId: this.appId,
        initData: s5,
        ...x != null && x.shortID ? { shortId: x.shortID } : {}
      }
    })).tgLogin;
    try {
      [this.userId, this.jwtToken] = _Nf.decodeJWTToken($2);
    } catch {
      this.logout();
    }
  }
  /**
   * Check if user exist by TG ID
   *
   * @param tgId
   * @returns
   */
  async isUserExistByTgID(s5) {
    var $2;
    if (this.checkInitialized(), !s5) throw new Error("tgId is required");
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: ur,
      variables: {},
      requestHeaders: {
        "x-hasura-tg-id": s5
      }
    });
    return (($2 = x == null ? void 0 : x.telegramUser) == null ? void 0 : $2.length) > 0;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserWalletAddress() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: jt,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk.sub_wallets[0].address;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserInfo() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: jt,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk;
  }
  /**
   * Logout
   */
  logout() {
    this.userId = "", this.jwtToken = "";
  }
  /**
   *
   * @param args.redirect_uri
   */
  async startBindGoogle(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = new URLSearchParams({
      token: this.jwtToken,
      appId: this.appId,
      ...s5
    });
    window.open(`${Ir}?${x.toString()}`, "_blank");
  }
  /**
   *
   * @param args.address keyless address
   * @param args.idToken google jwt
   * @returns
   */
  async bindGoogleAccount(s5) {
    return this.checkInitialized(), this.checkJWTToken(), await main_default({
      url: this.graphqlEndPoint,
      document: _r,
      variables: {
        ...s5
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
  }
  /**
   * Simulate Order
   *
   * @param args.payload TransactionPayload
   */
  async simulateOrder(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: gr,
      variables: {
        payload: Wf.encode(ot3(s5.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return x == null ? void 0 : x.simulateOrder;
  }
  /**
   * Create Order
   *
   * @param args.payload TransactionPayload
   * @returns
   */
  async createOrder(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: lr,
      variables: {
        appId: this.appId,
        payload: Wf.encode(ot3(s5.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return x == null ? void 0 : x.createOrder;
  }
  /**
   * Create Order with Code
   *
   * @param args.payload
   * @param args.code
   * @returns
   */
  async createOrderWithCode(s5) {
    this.checkInitialized();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: Er,
      variables: {
        appId: this.appId,
        authCode: s5.code,
        payload: Wf.encode(ot3(s5.payload))
      },
      requestHeaders: {}
    });
    return x == null ? void 0 : x.createOrderWithCode;
  }
  /**
   * Create Signature
   *
   * @param args.transactionHex AnyRawTransaction.bscToHex().toStringWithoutPrefix()
   * @returns
   */
  async createSignature(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: br,
      variables: {
        appId: this.appId,
        transactionHex: s5.transactionHex
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return x == null ? void 0 : x.createSignature;
  }
  /**
   * Sign Message
   *
   * @param args.message message to sign
   * @param args.nonce nonce
   * @returns
   */
  async signMessage(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: yr,
      variables: {
        appId: this.appId,
        ...s5
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return x == null ? void 0 : x.createSignMessage;
  }
  /**
   * User interactive
   *
   * @param args.orderId Order ID
   * return bool
   */
  async confirmOrder(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: pr,
      variables: {
        orderId: s5.orderId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return x == null ? void 0 : x.confirmOrder;
  }
  /**
   * Fetch Order By ID
   *
   * @param args.id order.id
   * @returns
   */
  async fetchOrder(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const x = await main_default({
      url: this.graphqlEndPoint,
      document: wr,
      variables: {
        id: s5.id
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    if (!x.orderByPk) throw new Error("Order not found");
    return {
      ...x.orderByPk,
      payload: x.orderByPk.decodedPayload
    };
  }
  /**
   * Wait for order
   *
   * @param args.orderId order.id
   * @returns
   */
  async waitForOrder(s5) {
    let x = await this.fetchOrder({
      id: s5.orderId
    }), $2 = 20;
    for (; $2-- > 0 && ![Bf.SUCCESS, Bf.FAIL, Bf.CANCELED].includes(x.status); )
      await new Promise((N2) => setTimeout(N2, 5e3)), x = await this.fetchOrder({
        id: s5.orderId
      });
    if (x.status === Bf.FAIL)
      throw new Error("Order failed");
    return x;
  }
  /**
   * fetch order list
   *
   * @param args.walletUserId
   * @param args.limit
   * @param args.offset
   *
   * @returns
   */
  async fetchOrderList(s5) {
    this.checkInitialized(), this.checkJWTToken();
    const { limit: x = 10, offset: $2 = 0 } = s5 || {}, N2 = await main_default({
      url: this.graphqlEndPoint,
      document: vr,
      variables: {
        walletUserId: this.userId,
        limit: x,
        offset: $2
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return {
      data: N2 == null ? void 0 : N2.order.map((ff2) => {
        let of2 = {};
        try {
          of2 = ff2.decodedPayload;
        } catch (wf) {
          console.error(wf);
        }
        return {
          ...ff2,
          payload: of2
        };
      }),
      pagination: {
        total: N2 == null ? void 0 : N2.orderAggregate.aggregate.count,
        limit: x,
        offset: $2
      }
    };
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/dist/index.js
var import_buffer = __toESM(require_buffer());
var wr2 = Object.defineProperty;
var pr2 = (c, i4, o16) => i4 in c ? wr2(c, i4, { enumerable: true, configurable: true, writable: true, value: o16 }) : c[i4] = o16;
var W3 = (c, i4, o16) => pr2(c, typeof i4 != "symbol" ? i4 + "" : i4, o16);
var Rr = "aptos:devnet";
var Ir2 = "aptos:testnet";
var Cr = "aptos:localnet";
var Sr = "aptos:mainnet";
var Br = [Rr, Ir2, Cr, Sr];
var st2 = ((c) => (c[c.Unauthorized = 4100] = "Unauthorized", c[c.InternalError = -30001] = "InternalError", c))(st2 || {});
var Wt = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });
var Rt = class nr2 extends Error {
  constructor(i4, o16) {
    var h3, u;
    super(o16 ?? ((h3 = Wt[i4]) == null ? void 0 : h3.message) ?? "Unknown error occurred"), this.code = i4, this.status = ((u = Wt[i4]) == null ? void 0 : u.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, nr2.prototype);
  }
};
var Ie2 = ((c) => (c.APPROVED = "Approved", c.REJECTED = "Rejected", c))(Ie2 || {});
var Tr = "https://t.me/mizuwallet_bot/mizuwallet";
var Lr = "https://t.me/mizuwallet_bot/mizuwallet_testnet";
var Or = (c) => c === e.TESTNET ? Lr : Tr;
var Tt = {
  CONNECT: "[Mizu Wallet Connection] ",
  TRANSACTION: "[Mizu Wallet Transaction] "
};
var Mr = "07418a1b-9574-4449-bd34-2146db60b05c";
var Nr = "0c460c1a-5175-4383-b1c2-35b934f5aa71";
var Pr = (c) => c === e.TESTNET ? Nr : Mr;
var Kr = "Mizu Wallet";
var kr = "https://mizu.io";
var Qr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAQCgAwAEAAAAAQAAAQAAAAAAlNB3SgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAALERJREFUeAHtnXm0XUd15rc1z7OeJmu0ZEs2HnFs4yGriWmbxstM6ZA0fyQNTvdqOgSymIIXEBscOg6GhKzQCc2CBuIE0pB0O2YycQx4CBgIOAFPYMlPsgZrtObZRv376px6vnrS0xt0qu559+xa77w7V9X+qvZXu3btqnOG3XTsmHlyBByBRiIwopFSu9COgCMQEHAC8I7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R2BUQ5BXgRGnmE2G9qdKOrlOX/HpWPHzPg7/tIbpCM8HuV6nud6PMT1i/CJ/3MEhoaAE8DQcBvSr6TsL6C9m3fz5Lkyi9G9siqJITCDnsfXetR31WLlNYvHcbw/hivkzUciif2wwn4RBZcnR+BUCDgBnAqdCj8bi4YeRvl/5UyzX3212Yp5KO5IFPZIUcgIlFij/8GjvPcC3+XxIJ/pOnIYZeb11r2Qxz6z3Vzref5vu/gtz+0Ql8wCEcRYrvFmE8aZnUnryuI4TL57IIW9XM4J4OOpBwEngB4o0j7RyDwChX9km9mcx8xmTIQMLjPrmja4co9CDsdQZBHDvgPoPsq/DYtiJ9d68l632ewnm8y+utFsLY8GedgErslmCyAGWQwH+P12Lk0jPDUbgTPsJo07nrIhILQPcm3hmmL28f9k9luvMps2iUEc5R4hW75MZ7Q811u9X8fv9X48hLWwGwthyw6zbkjg0W6zB35u9o+r+aamH5DBqKlmi8cUlsE2yvXUTAScANrQ7hNR7C5sr+cZhdevN7t4ldlfv9Xs3KXFNGAgih5pO7B3pHDyZYA/0bPIW7IYNm01ewIyeOhRsz/+MW8+wzXdbBmXrILNTgQA0qzkBNDm9l7BKPyU5vGMzA9+0OzqiwZOAn1VPZJCfBSh9CaVbfgPHnnS7EsPmH3mQXLCZ3DWLKYGkMBuyICfuL+gL4A76H0ngDY2ZlSyOfgGpG1bmLff/4dmv3wxy3sooRyDVSWRQbAaeNKa7wu8fpSpwee/afanX+NLXWZL8Rl0M43w1PkIOAHUpI2nouzy1T3LnP3HH2NacE71JNAqqshAVysZfJ+pwds+b/YDLIPlrFZ0s7IggvDUuQg4AdSobWdhCWzXyItp8OxHzObOhASkpDIVEqZWa2MvDspP/T+zd91pNn9R4STc5ySQEP32Zl2hkdleQTqhdM2/F2sdH3/AbX+VR/mFW7QCRASTWSp85xtZRnx/4TTUOvEU7yWCqSOTN22NmlUD/Tq89SvnmP0F8/Gv/3NROSlmjiQiiFODG65iteBWs13bg3/Qxie2QnLI52WciIATwImYtO0dWdry1ndDAqMXm934VwT54K2PipmjYnHFQKRz1YXED/wBEYj4JbrkqCQ5DxQ4dMp/J4CataRIQKG7i1getA1md32nqGDw4BdPs/wX6YgErmFF4v/8HpbJWsKXqZPqdzpJocnzIJPl5NV6nUUY8zKupVxLuBZzLWL+oXBm+UamUZ8J/NY77Omgf+Jv3Ql4IiZtf0ejrBx/BAfabvwCz95ROARFAr3X81NWtrW8mz9pdvs/mi1kmXA9qwNDSZLrmIKN8HEYYcsmqwJFDykIzbP4KE3XczkhRIZ65LuzeRzP70bzmWZGCrHexxPtc9BrT4NDwAlgcHhl/bZGxKfXmv3v/272phuLETk67HJVJK5CbNkJCb0HYkLLRqOcUrzBWAPyIRyEOF61yOy1l5itWliQwQH2KoxCobVRSiHMug4wBTrAHofnedx7gIBFCGP7HvY28PgT7aIkzDmEU4skcFoa+ypmEsg0DXIQN4k0dzkbgET/yQmgf4za9o2oNKvYM/C9/2E2lY7eOirnqpimAiKef7gf5f0jTPdlZqtRzsEkDebS18ko+39A+X/9GrN/fwVmvVY9+kna1vwLNDtugNJuyK0QwUasiJ+tN/uXdWbf4ApWhSyFaVgqYDWKArfwuwP8XuUPhrD6qVLHfOwEUPOm1Dx59Rqzb3/Y7N9d2h4rIJKORuvrP8DqADsOJzPiyuweUmJUt01cS83u/W9mr7i8ILZobUhRpbAx9TftOQQZ7cA6WEee//oUm55+ClkR1BSsBFZUlmMlbJB14UQQIe15HGmX3Hprzyt/UjsE0P8wx9XhH9ddhmK0akam2qpMWQFjNAdH8b94DyPsDLYgD5EAJiDUkrmY6vz+818mr+lml6ws/B4SSf4PlRmvKKaISEkPeh5fjwabKYz4C8nzl841e93VZr95ldlFWBprIIWf/ZypAQ6VRdRfZXp6EQG3AF7EopbPsJhtCsqwk1FuEyHC82YVHT83EUQrYCfz77N/nzn5Ic4e0dy9VMqhgKddkUsgg8c4H+HP8HO87Q1DyaUgBLFCrGMrNrv3m33rB2Zv/BIWwLNYA/Pwq2ANOA8UWGta5qnGCLxA3WZqXrsZBxjmrVIc+YpXef5LqVTudM4SuJkR1ggQCpuYTqN4HVv2GNOK884ze/snzf7uviIzWRuDSVQtWAvyU4R68lrTCeUjv8nrXs7Kxe1mH3wN06lunJkQl8jHU+GXcRxqjsBBOrM83d9lpFRqHeGKd/L8j8Sj3YoGM42qSImegASWnW32ax9nZ+IaOiWKPFgSaEVA1dI0Qvmozspr1lSzP3iT2d3vK0KcmQ3YpIrq31r2cHvuFsAwaLHnZAbQgf8ex5ZM2jga5656JJ7lCzHdl2JKMw0YV4ESacAPG46Q8d2fxVRnuhOV93RlVJ0DoYhEuW68hnMXbilCnCfzWVUkdrr1bNfvnQDahfwgypUFsIjlsseeYSaA6a2k/pw7RQLQ8WVvwNmm9fjpFfWgrZDcOSx33sN8/WsPFZJFi6MKOWURHOOSNaBDV77xHgKsWEJcrOkViY8amSpqvkZil1VoRb4Zo/86HFkhtYMBKDia5pcs58U+4nAq6kESby3OOTuToKe/49R0yKUqK4BcQ1IZMc9XvozzGP8zqwQbLIQftwnOomJt/F9R8+WVQMqg+Zu84/GaWr6neHEdwS3TblgK1weUmgUoFPbpjeUXkK+dadkCSq8QYCmgVhRWsMy4dw2bkH5USFelFdAbr5tebXYFy4/dxCVMRpY2Q9q7ellelwZQlrIqKUQVPspIcZR5YuiArZ1QLajXPGpuqkZV2Ko2oIg09JHmm1ImHYmtgzAVJaaw1rqnw6o4yrFmc1FTmbTtSHEaMJflSB0oug8wVZWqINxK5J6OJfv0fWavvAqRIT3lXaW4kkGWzCQChD7862bXvo8VjWWnEdhE/YZrGlYEoMrqJN1LCUI5h86nm2VswSxWyKcUfR+dZzfXZq6tEMQhvMvhXHyRhS51LvUkuYBZfw5x5MyttfNMFoM+3kuHVhy59K1OSUSl+j4BAeimIWMTKMZg5J3OfP1yAm++j09iIlhqSa+KpECdZfgYvvaI2ZPdBPOwOiArIBJPFWUojzM0GpC05fk1VxA5uIYI4gnN20MwrAhAI7mUdBJK+8s03CsJIV1EqOcRFOIFFFdrvyIIna+vG2iIIH7Bo7zKmlMePEhADY8b6bRbiCV/lPn0P2xhXs1lmIGBFFjnnsWSmzaWSOnknKrDLbYUxiri+g511waZsXjMKx8aybK/FBVRdx66YB4EsJF4fp7vB6eqUjiHkLZ+ABIQAYizq07KU1aAiPSma+kHDxNvgRXQtE1Ew4oANEccTRDHdzZxfY7Qz2+a3fFas9f/CoMjDTnYdAQ22YMFsX0ngSKQwJPr2HTzc0Jdn+S9beTGSDQZS6OLvJ/luyIEdRzpYu4k2efRWs9S1wMQmZYF25U0ImsKsgLyVbz9eDbfVJmek/kF7ndBAL9N+2rDUBIrQI1JulQrGpDZdtqY7hWmiHq/Cak0hIaPqJq7j8XkXMA8cT2d7zdu5/owwR1SWJIsAXWW1itGhYnxdekzpTEolAJEVi5hZ9rlZr/7BmLTbybfPzH7p9vM3n99MSVY043S0Tm0Pbf8afh97n+6CagUTrvhlNpVl4ifwpI1tZJlVmXSJqNFmOPfhozXby5yTiFrtGbkz/idC8F1N1aAGKBBadgRgNpGo+FGFFLWwKqVZv/3pxDCBzDl6SwjeU8dVI0brxgVpiUgXbHhlZe+GwlCz5XnmZDLtZdxMOd/ZcT9KDfPeBd37YEonl7HZ3w+s0St4n6v6pwyhaCVcjoTvkh925nmz6R0CBdIKk9x2VPLdCElklUDgtrxSlkBTA8nDUuNKCAayv9hLa7m5k8QjbZMI9E+s/M/hAOQub2UXEo9kCQyiAQRiSGQQmkp6GjuX3sFYbhYGZ95C9tKd7D1lDK1sywQzUAKqeg7gXBQuCNYAXVIk5giGdYYVao8Bb8Lea8uCSC2TeUFlRmevZAnuRk9lTCDyHdYE4B0XB3jaUbFZTjv9jINeMdfoiBYB1JqKehQUiAFkNFjJANtKnnzjWaP38GW09mcUoMzbikdNCcJBEVjuN3K6ThtTaWizMYq0tLkEciy6hT2PzANeHJjQeapCCDmO482Nch+j/pO1cLUOL9hL2srCazCdP/i/WZ/c0+B+BD1/7jmUgeJ0WMyF1ctJVz1FraXEk7aDQksyUgCQc/wWzyHtaMUO2/xKt//Uv9tDLJrk5JiFKruSAclLOTyONO6sJzLy6ES+kCQmcYAcs1cHIEMJgoma0qqut3aglskAe0qW4SCvvlzRcScrICBTgX6q3gkghfomDNYA/9f7+R4rPMIX92J/yGTczAoAC12hClIHdLE8YVvRN5zRV9WmTTLmQCu9zOl23OgypyPzyuS6DhWGlbN4TOwrSq8+fiS6vmqIwhA0MbRXhs+NCn9/DcKwCvulzYSxEQCkxidPvk2ymAJbCPEk2NraZwC6PZdbU0lqONRmmWQoYIzxlQMtHwA0+VdxDN/qCS82MZVyy5i1UrG8kgAFctSdX2rzK9jCCCCoiOrF9OQH/o6R0GtK8zkqqyAWEYkgTlEJD78Vt7dRqwApnnqpCVQBQNtZQogmeLolbrc3vlH/dDUaDJTABFAspUAlF/BWylTJJbZtKcRPCbLsSmp4whADRcalOHyrgeKZkzRniIBjRyXv8Tsg69jysFcVTexSJmCZxxN24UFICuk3UlLpovkCFRocgKQQ3wB5KJgrZCippYvK3so810gAqC8xM1YWbWryKgjCWATyj8er+57IYCtzNE1UqZwIMX++Fs30BRMCY6ilCkBDTpPAfsYFeWQbGeKeM6aRC0ggLBuX3GFgoVDWx5lipUjTZA1g/a3GdocovaUkbK/9hSS+4lGygXyUD9j9uMnitJjh62yLnGpcfFcs1tewf4CVgUUrpsqBcKBzF5glIpOj0hCqcrsL98xOAKlMSmmI2HqRg/dFS2A/ioz1M9L62UGKwGKawiW1lDzGma/60gCUBtom6rhoLrvkaJFNF9NkSKx3PAycmdkTmEKx3pHhdCdc3qmAG1igFjsFNbq5XRNMAMoRmKmGc+VBJCCZIRtrLu2B0dLTu83ISVSi/ZDt4NRaQQE8NF/Y213V1GfqKxV1i52ypVLCBBahS+A+XmqE2c18GuOsQUCULBTW1PJADM1BYAAUjgBQ3sh70GINUcaiYPVIDSdE1H1/oYc9R9KGR1LAPKYK0hHd9hdu6mAJhUBKN/JdJzXX0g5kM2MFNpA1jJqNFw9wZz7aLsJQHUhTcT3oelIJMLwZkX/AsfQQ7WtO0eSLBcyDdC9BVnhbETqWAJQ64UOxL+n1qdty0gsF5xFOVgAVa+Jx9rLOTVBLYZC9EwB4odtegyjJoQXMaiyGqH9ILzkBFDOAXT60IJyWTOFU7NKbKrKq6MJIKybw+prNhZwpRilQs5lB1oyn1fMI1M5kaRk4RhuRv+6EEAIB6YXBWWtqleW+QSLB3LZU64CpGq/svlMpwSNk0Wj6WPFstQ1u46WU3M5KeRjTAF0QlDqDtQ1nfLmsC2ZETqFFSAlQx/CXOCYZGtnKrUmTAFY+Qin+FRcn5BnSQA5xJWjeBr9Jfg0IitULFPdsutoAgjHaDGZe2wbjp3SkZTCVI1uZEXF3QgB6BxC3dq76hQIQPlCZknkGEKFdTybWCmM1kP4/al+EvKkhx6EUHPIq7Mlu+TUxMKS+6gJqeMJYDaj00+fY6twwrXkqOs6X+5cYgK0HJhqR1koCybIoRCnUoAo8yjFPXBVHW6tsoOMFHQYhUyRf6t8Ec/psgAoryl3DOpoApDZOE42M8ofl5JSzFXVkWIHmq/DSbAAUk0BwjSmRhZAOF0X4pO5HklBeFSRQluRqZY8I75V5HuqPEZp6M8x3zhVJTJ+1tEEIBzjMVo74oaSRAwQO+j8ckNJqnXkHiVLJMdg+56OYJO9rENBqt5EEwkgODwzyTsaMku1rDlYbHN8v+MJQP1Ty2Y6EjxHmqnNMXTWVMD26EEPE+SQqu8ywhQAAtiTQ+a+q1HZJzoXIIQ2V5ZjvTNK1U9rI3VQGP7lOkRjotaRZRInQiDovTKviZk6CobV0WgapQPZVih3EBGBFfQULawKsz8uq5j/+HIKUBN+Pa6OKV50PAGEToSTalt5jFYKEEOeZY+ZVW4oCTEIKQqrWc8cC7Znlkojf2CVqR2ihlUNOk07yq4Su4Hm1QwCQMp4rFTqWIDRMiEJC9bW4BSdKOSJRaO4BqVg4RRP8/4vhZMFMKmcN1ft9wiyUU5r0FNqeSeWU4Cq/Rl5G2fgpXU8AQTTDikPl9FkA4dmaN8cI2VgGrADBU2xlBQaDHKJBDC0Wlb7qzNk+yfUzGMiu4T5t6IxQrKI3DKV11p2O553PAEEUDWK4AjMkRQZdxXBJM8zb9VgUnWKBNDu3YClARDCZ3s85xULG8ibgnSvxzhHr7iIE7LrIYATPunMNzqeAAKRI6XuqJsyxanFaCbCIZiEUbpqk1j1D+UgVA8BtHukQkHlB0jhOQ+zHNpuR+v258TyhmVNykxcTMquOKi8O54A4jl6u8tQ4Kiog0JpEF9WPLmOyw7x5IP43UC/GkZeTQGwMOqQNFeeUDoBqya8ICJ46sYvPYSXWOhgzTgBJEY5Y/ZxFNmPBYDeJE86LHRGeUpOCh9AJABNMeqQwsnApeOs6mVAtd1E8NwFAWgakCMpnFtBHKlDj3PIMpAyELWzU1B6pNSGktQHaWqeqhGxS7EAlJdiT3kPAWRSiFP2DsnLF6ZpCy31qZrwpIThdCUcuMktngAs1ozIDCbLMVicEttMH3Y8AURHUs54ct00JNUUIHio6Z3HamABxHny5ETySgm1Q0+3IA8rAQmVotR/C4FA+DRSbG9OWP0hZ93xBBAtAO0oy+ZJLtfFh9wqp/hhJLTUTs1TVOGEj0aUTsATPqjgjbAejzV1lEspkk7xqvr/YXMTPg1ZH5EUqi+lPjl2PAFEqFN3nFiOHsfGcNIEPSgQGibqzoT3y2uVZSDPR0teKUwCecUtmk7tjns5EjfkSBXINEBnSTRBOTpexthfUs//1U9jWeOiQujNilMkgHh/wBRKN9gqp9xAE1YWsN72RQIYbOUG+X05AXU8+M4EPo1BViXL15tBAIxMWYJJSgYIjiQ0NcGAWLAMrRZvmJmll/RRSJxSBR9AInkDhijj85kiOdV2l5arOOLxTk8dTwBJlLCfXhE3lKQAN3AMQh3JpBD9iBo+jsueVccBKPNg8QDkzkybuRQIFG4QAuk0YT9Aij46kD6T7TtRYV6gQaONHk31VJXo2VKagH3iHYJ3JL5bzmCwCT4A/SABsGo2HTm2uby5S6opT2yqENcgCwDmqTquQaLULXU8AQTAad2cp+gGT7J6VAKFOKI8madu2oNvLAyP7e9S4RgttCWBuEVADgSwL7UFUMKoOx4v1KEuLD2mvM1b+1utqEHHE0CI6EIZw8GSUWFS9NSWFg0bSkA2RTFhRKST7sYCSL023iLSKZ+OTxg8E092fpobr4ZzB+NQfcoaDe3D6NPo0pkOiQK5hlazdL/qeAIICoOUW2F0kUCOFI7JStRRw94GRsRtEMCRuDaegmkGAlQp41SZzFglKW6IEiwevHHrOdk5VyzAhPJ+h6mmGwOBNtd3Op4Ags7TUR+FAJKHk5atlnJDifY0TYYAHt7NUeeZlsb66oyR48KyJ0qaInruoMiNvL+BBbA3xj4kIrxoASwoD3YF5o5PHU8AsvqnSEoIIPmGklIjdI+5EE+eoKNqlJ0s7xRz4qPIVIcU7g/I2vkhwK66Q8kCOFOa2HJvhwSwHgfjVFkAkd2O+6TzXlTdXrVDSKPSeEnJslmuHXThdlkoaZh+JEAkbDLCFIjHnKVWiP5E0Nr5cubNz2FupXCcjVH7QXhbdpQ1SSVwqfQz5AREphRTmv6wzP15xxOA+kpYn2a0TL0SEAeNcEAGo1aqLaVh1x2E9hwrASGlUogy+z4fSoFFACs0akIAKW6IEmXcsLXPmlTyQWy/aXICIo8smvheJQXUMJOOJwBhHggAh9nh0mROrS/hjDzmrRpBknUg8t4bb3bSpo4VZZO8k0QAmDwpOlRwBDLFePKZQtDUzrkpyHLBbCwO+kuKezy2qblOWmyK9jppQe18MzhzGJ12JXYiRRl7NpRoThy1JH5YwWNwbOJnWLe9yCy1QvRX5TEQwDLdGRmFCbcv7+8Hg/x8rxw5KOUPuhmVKUPypiDxiONkVjUuX0CZTLN0IEknpw4Xr2i6oIRoTbxDcOoGlRNwIZ1oNx1X/sCqU5ibYmFsi3PiqgsYRH7Rc95VBs+kOARFBNCFBfDVNci8s6xcCgYga8mj/nLhEl6w1DqhwzWkw8UrOksYhDFPj2aKn1dgzEqtjWtOXFSh0v8HNCKiEI9vRibkiiNXpYUMMLOoh9NFAJoCJLB4JG5Y+YDwnnqmqFgkngFWc8Bfi/met5SfMG3s9KXARhAA/TIsy22PTrMBd4fBfTEqos4FHI+CKp48hUKE6DiY5RGcYvvLaU3suIOrcQXfLhkg9dp5kBlSfeinRZ0j1hVIcFwWMd8Vi3m7i2kjJN7JStLJsvU0rEYQUfk2gmeUYiMXr6r/r1DgEB0H86TYIafgmAUQwFNb6KClIzCOxNVLM7Acp0zhe8x3AtYD+8mgvrUVLEcRoHPLw7QjG4PUhilIL/aNeTgB33IRR5IzaMyiPTs1NYMApB004t4cG0ooS+fYLZ5GmTisUqyLqzOOVcshz+boB2gXA5Qmf5fkxerRbcJTJO2CXKz51Dqzf/7XooQUBKCcdXiM4L3hMv7tIpDMCUCwDN8Uwkk5uHI1XvPnadzI8ikkino4Ha918jkksqx7NoUUA8+z1H+bLHlnmm2Q3yO+OfBsBvTNLeRt88xuu7sIgtLW3RQkEPvH5edT3mIwhsjl3Ewk1oBkT/UlEV3Hp7ihZEPGDSU96+KJes1hMQ1z4sfXFc0XO23uxozlTuUo9NfOpXQcrRMSybwPmZdhZfz4SbMv3VtImooAlO8sHJufehU8vslsCdMbQd5pqREEIAtAN+28Fwsghs+mas3YIc9kvioLIJX1GNfGv9fN8iZKJ0VsVweVzML3goXIjFMy1dq5eOVpMF20yOy/fNbsRxCBrIBw2EsizfyP1+LPWYK/Bblmp2rMRHUfSLaNIADNH+fQQcOGktIPkFpZggWQEF0RwFymNfc+jVMMyyak1EKVxfR+iKR3LoopAkjl94ji7UJ2I/Do0o9inrMUqmO8qiYBEap8AdMnm933u5RHOaOowNSEbdob1xyvO0ycviEL81I6Z3KnWWn+ynw0FDQc4dV3tYb8iZRhokYkAmNWry+yiYo45ExP84fLZQFkGCX3oJhz5RDE8nn5h5F/Q0ECMoGqPP05+hheusrswdvNnmXVRSQwrYO0poNEOXXvlcIoracRU6ZS/y1sKWX0OMjyVSqQgx+AOfHDjxcSxfl4SvlOlncsd/F8PoUEdDPPFBGBrWVvxiE4H79DN0u7K95r9q0f8ingR6UVEVRBiGFqRee5+iJWHz7EsiCxF6N5PSNVo7YKmeF5h4jRP1JRWXJuKLm8C/McZUi1oWQ75CJT+DM/YrWKqU3srP2jUe03IgHI6nnX+eSNUs5M3LNU5ib8AbMhQN2K7dpbzG7+JOSzscBBRBDxiGQwVEJQPsrjygshgdtoU6YD2im4QGGCkEEk/WpRzZNb4mbKI8RASpHZqA0lD61pcZrReFWnqAyT8NC/dAG5H0rnFFN03Fl0/u6nOPFodSHJUDv56eIQTe9rLyYngpNSOQJjPUPToXnbIMGjPJ612Oz2e3l8B8FCnzb7IVbRfrBXe0QyiG2jbdqqb7h4Lsz6w015BBK4wOz7TAcOQLgbCRJaCf6prZ0oc4rHxhDAPhp8Ho31rbWcDxidZikQJc94X7kLlvAi8YYSyWVMNf7+AR5J6qjtSFG5Ljyb0ufimsBEz1UVWXdrsAYWEL03n4CkD33d7LJ3m133AbOPfcHs2/9itpalPBGCksKzhVO4eK66x/oX33iRFCI5RIKQs/Gy88x+9hGzaxayRfknBD+1+Wi2WOehPHb6XoceTOgjNqF0mv18Heu684pG7t3wPT84nScqjE517lIeUYSUfrEtdMjFBOB8/D6Wxm4sytRIlZsIAo7IPW+W2fuvMvvDb6KMKOQm5M+VNlIWsNsCpl5aifgu8/Xv/i1v4CzUVOlKFPaKRWZLIaglc5jHQxazubRvYwKDw0Q2celId60qnCyEu7WvnE0+D/yx2d0PmH0O7O/fzMyHthAfq/mHS2oMAahBQkQgjqMHYe3rrjiR9atqtNhRVtBJFLm2ldFJJED/SJJioNOnv2b2J2/Nr/xRKFk+Gl1ffTUEcBcKJW3MnKR8IgKlSawUzMAxKRP9AOAHQljLB7IE8M2ERkHxjT6xGP/FuVhSE5m6zWKqOI9LR7uNYPlYMQ664au2eY9BY3Tik6ybKfouv3ntZfSth83u2QCZ8FnoZ3w+HNIZdlM0boZDdU+vjjpKaxw9ZB+dYfPHiA2YkdAKKKv6jj83+1NGibmUtTkVA1DWWXTONWsZlf4I0/QiyIahSLsS25EUbv1mRsc7IdquKRBgQrkHKp+4SIQ0CUy0jwI9DSO1lmkPUb9tIg3VU5eeQ9rhuRglDuutz3k7fEffw9IxLAlZXfrqcErCoTFJB2l0oSj7Nhbzwt+4Lh0BRDP8lb8EAXyFaTqdJCUBhDh5TNtXf4qoNUhAHvlYh5wNrDK1Gertr4MAHsDyxvQWAUgBpT/tSipbocQi/96mGNW1cWiC7gys57IYFDei50qy6FT/eIX3yvf1fD95SkZlPdxSoywANY6OrBLj6462axmlZmDCyQaKZntVDRjz3IlH/PybMUsP0MGYB8hcV2dMkRbSiddvN3srJvjH317MY6NZnqK8vvKMsn/0b8ze/ddmq5aZPYHZLYxTyd5XXfz9UyMQSe7U3+qgT7V0tgRnz971Zl/EUaWUYhKkzq7RUKGkd9xIIRsol3lkKgXQ6LQec3Q5DrBP3Gf2kTslGaNYWY/iVd7/b/lVLJLLUf7N1AvMAzHkrYKX1g8CI+2SW2/t5zsd97FiyZcwZ/vCg2bXn8/mEkxnLe+k8JyLCBQhdzfz4Sf34HeABPYnYgGVpbP5V+Bv+PJDmLHIdCXr1vIFyCeQ4nSik3WOQH7IKJP6+pdCAKuJVlyLn4Jpieqnzz3VA4HGWQARds3ZRjBaXnnHi7HkUpIqU1AE8pS3+Au/Q86Y5ypjeiLUxSsq8yk83CuWmL3vy2a/92fFqTbBIcgXZJXkSNHy0BTrzveYveYlOClZlnNLIAf6Ay8jUVcceAXa9c0DKMPMUZSOwqy4zeyx7he95lUqSfAMU9aFK1iGwjm3HRKQKZyUBBBLJKDNOZ/AyrnsfWbfwwKRrNHKkYwppj6t7RlkpxydFfDZd7L0uhKy3eYk0IpRu583lgAEvJZ+5uAM1LrwS3DU3fO9ojnUcaUcVSlJHA1fhjn+MGSzi5FQu8pSxcuTtXTdVh9mesPqw9M4Iq98r9l7/gJzvPtFGWUtVClnkfPx/yMJyBfyxd+HBM6hXvgEzgF3la16emofAo30AUS4pQBaGprJXHU8c/NPf4XXu5izEyU2Cx+BPo9K0jpa6r3BJv1GhLKQvK87z+zP72a5manBPMrey3RkKHn2VwflqXsT6G7Ci1iO++pjZv/zHg5FYRSeQvTbNNboNU/X92L5kjNcZebx/f7KOtXnykOyK9ruBpZFu9cRr0BdVhE1KH8Mf57ahEDjlgH7wllrv4tQlDUoh3rkzdcT4XU1nXQpCoSi9k5RUcL7/Ja/IrU+j++1PEoRNCrqNJtLsQa0LLAS5ezGZA87Flu+W/XT+ciHvtu6HfxjM8slq8x+8zLuggMhLV1QkF5fwUN9yltWciBEEWU/iKy330nM/hcocxlkRL3WY42lOjuhahw7KT8ngF6tKSUZiVJqPd0Oml280uyNeLIvPpvz6Eol0U6/HoXv9fvjXmo0Pe6NYnTV2vyokYXz8bc/QRz5Q3xpCRcjZI40l7K1W28N8umUpBDRNt/sTch46Vn4RPAdyFKZiRU0ZWJhJQymXiKL3klvCTM5QSW7Xt/1HbPX/yVPhDXl6468nvIi4ATQB97z6KS6LVRQkp18CT+Bwj0vPdPsZSjICsggbChhaUtHYmtDyXgUOMSP87u+NpScrLivPMiGkn8iOnEz5jnTAZnEJ9Ghk/30tN7T4Z06817Wz8ajiLif7PAXBEKQ1TMbkx0iOHcuG2ww13XNZNqgE4BnMqcfzbRpLEqrTTRS6riRBvEHnHZT5leR/28hwe9ife1CfsmeQ/4BV7KDv+gE0E/jSklm0rkVGnoQzdyEY03n3sk6CBtK1Ns1cjNSzoMMLkAxZCFoQ8kcLs21R2BVjJGycJ2woYTPpUhrNrFU+HD7NpRon4SOupJlQHXDnY0VWPQLySvy0yOvg2ZS33DPM5EEMr6cazJyTOKawXtdYKFbhp9BRqOZc2gDTdhQo9dgGW6fTnnjeC6/gIjjZxuIXfhh++RHkkYmJ4BBNDt9Nhx5rQ0l40pF0c8V3nsYctjKPDZsJGEUG+qGEilDXUY/WQYiQF1jqBf6GuLjJd5R5NVNQMJGH73Reoko+KxnKJdAvV/zVngPf0D4XhePWBd1kl9V7PQEJ3saKALqx4ri0+aP3js/RA4a0TTaSVE0ospq0HMlOcn0nXiF98r39byOG0rklNutSxWUzL2SZNGtwbXHQfvn4YgwnRBx6LlSlDs81+vyCq/1okxaCdERZycpJn7FHxMg4ARQEagiB+0zCDexrCjPumcjmWX9aBCvjdlSd9BqVr9I1DWrllfHEXAEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAv8fTRTpSk+HEsQAAAAASUVORK5CYII=";
var Dr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function or2(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
function jr(c) {
  if (c.__esModule) return c;
  var i4 = c.default;
  if (typeof i4 == "function") {
    var o16 = function h3() {
      return this instanceof h3 ? Reflect.construct(i4, arguments, this.constructor) : i4.apply(this, arguments);
    };
    o16.prototype = i4.prototype;
  } else o16 = {};
  return Object.defineProperty(o16, "__esModule", { value: true }), Object.keys(c).forEach(function(h3) {
    var u = Object.getOwnPropertyDescriptor(c, h3);
    Object.defineProperty(o16, h3, u.get ? u : {
      enumerable: true,
      get: function() {
        return c[h3];
      }
    });
  }), o16;
}
var ir2 = { exports: {} };
(function(c) {
  (function(i4, o16) {
    c.exports ? c.exports = o16() : (i4.nacl || (i4.nacl = {}), i4.nacl.util = o16());
  })(Dr, function() {
    var i4 = {};
    function o16(h3) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(h3))
        throw new TypeError("invalid encoding");
    }
    return i4.decodeUTF8 = function(h3) {
      if (typeof h3 != "string") throw new TypeError("expected string");
      var u, E2 = unescape(encodeURIComponent(h3)), L2 = new Uint8Array(E2.length);
      for (u = 0; u < E2.length; u++) L2[u] = E2.charCodeAt(u);
      return L2;
    }, i4.encodeUTF8 = function(h3) {
      var u, E2 = [];
      for (u = 0; u < h3.length; u++) E2.push(String.fromCharCode(h3[u]));
      return decodeURIComponent(escape(E2.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (i4.encodeBase64 = function(h3) {
      return Buffer.from(h3).toString("base64");
    }, i4.decodeBase64 = function(h3) {
      return o16(h3), new Uint8Array(Array.prototype.slice.call(Buffer.from(h3, "base64"), 0));
    }) : (i4.encodeBase64 = function(h3) {
      return new Buffer(h3).toString("base64");
    }, i4.decodeBase64 = function(h3) {
      return o16(h3), new Uint8Array(Array.prototype.slice.call(new Buffer(h3, "base64"), 0));
    }) : (i4.encodeBase64 = function(h3) {
      var u, E2 = [], L2 = h3.length;
      for (u = 0; u < L2; u++) E2.push(String.fromCharCode(h3[u]));
      return btoa(E2.join(""));
    }, i4.decodeBase64 = function(h3) {
      o16(h3);
      var u, E2 = atob(h3), L2 = new Uint8Array(E2.length);
      for (u = 0; u < E2.length; u++) L2[u] = E2.charCodeAt(u);
      return L2;
    }), i4;
  });
})(ir2);
var Yr = ir2.exports;
var Ve = or2(Yr);
function Hr(c) {
  throw new Error('Could not dynamically require "' + c + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ar2 = { exports: {} };
var zr = {};
var Fr = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: zr
}, Symbol.toStringTag, { value: "Module" }));
var Jr = jr(Fr);
(function(c) {
  (function(i4) {
    var o16 = function(t11) {
      var f3, r9 = new Float64Array(16);
      if (t11) for (f3 = 0; f3 < t11.length; f3++) r9[f3] = t11[f3];
      return r9;
    }, h3 = function() {
      throw new Error("no PRNG");
    }, u = new Uint8Array(16), E2 = new Uint8Array(32);
    E2[0] = 9;
    var L2 = o16(), M = o16([1]), $2 = o16([56129, 1]), te = o16([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), ie = o16([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), le = o16([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), xe = o16([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), se = o16([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function re2(t11, f3, r9, e14) {
      t11[f3] = r9 >> 24 & 255, t11[f3 + 1] = r9 >> 16 & 255, t11[f3 + 2] = r9 >> 8 & 255, t11[f3 + 3] = r9 & 255, t11[f3 + 4] = e14 >> 24 & 255, t11[f3 + 5] = e14 >> 16 & 255, t11[f3 + 6] = e14 >> 8 & 255, t11[f3 + 7] = e14 & 255;
    }
    function ye(t11, f3, r9, e14, n15) {
      var s5, x = 0;
      for (s5 = 0; s5 < n15; s5++) x |= t11[f3 + s5] ^ r9[e14 + s5];
      return (1 & x - 1 >>> 8) - 1;
    }
    function Ce2(t11, f3, r9, e14) {
      return ye(t11, f3, r9, e14, 16);
    }
    function ve2(t11, f3, r9, e14) {
      return ye(t11, f3, r9, e14, 32);
    }
    function Se2(t11, f3, r9, e14) {
      for (var n15 = e14[0] & 255 | (e14[1] & 255) << 8 | (e14[2] & 255) << 16 | (e14[3] & 255) << 24, s5 = r9[0] & 255 | (r9[1] & 255) << 8 | (r9[2] & 255) << 16 | (r9[3] & 255) << 24, x = r9[4] & 255 | (r9[5] & 255) << 8 | (r9[6] & 255) << 16 | (r9[7] & 255) << 24, g2 = r9[8] & 255 | (r9[9] & 255) << 8 | (r9[10] & 255) << 16 | (r9[11] & 255) << 24, b2 = r9[12] & 255 | (r9[13] & 255) << 8 | (r9[14] & 255) << 16 | (r9[15] & 255) << 24, B2 = e14[4] & 255 | (e14[5] & 255) << 8 | (e14[6] & 255) << 16 | (e14[7] & 255) << 24, m = f3[0] & 255 | (f3[1] & 255) << 8 | (f3[2] & 255) << 16 | (f3[3] & 255) << 24, X2 = f3[4] & 255 | (f3[5] & 255) << 8 | (f3[6] & 255) << 16 | (f3[7] & 255) << 24, R2 = f3[8] & 255 | (f3[9] & 255) << 8 | (f3[10] & 255) << 16 | (f3[11] & 255) << 24, N2 = f3[12] & 255 | (f3[13] & 255) << 8 | (f3[14] & 255) << 16 | (f3[15] & 255) << 24, P2 = e14[8] & 255 | (e14[9] & 255) << 8 | (e14[10] & 255) << 16 | (e14[11] & 255) << 24, j = r9[16] & 255 | (r9[17] & 255) << 8 | (r9[18] & 255) << 16 | (r9[19] & 255) << 24, D = r9[20] & 255 | (r9[21] & 255) << 8 | (r9[22] & 255) << 16 | (r9[23] & 255) << 24, K2 = r9[24] & 255 | (r9[25] & 255) << 8 | (r9[26] & 255) << 16 | (r9[27] & 255) << 24, Q2 = r9[28] & 255 | (r9[29] & 255) << 8 | (r9[30] & 255) << 16 | (r9[31] & 255) << 24, k2 = e14[12] & 255 | (e14[13] & 255) << 8 | (e14[14] & 255) << 16 | (e14[15] & 255) << 24, I2 = n15, T4 = s5, U3 = x, C2 = g2, S = b2, v6 = B2, l3 = m, A4 = X2, w = R2, d8 = N2, y2 = P2, p4 = j, O3 = D, Y2 = K2, z2 = Q2, H = k2, a3, J = 0; J < 20; J += 2)
        a3 = I2 + O3 | 0, S ^= a3 << 7 | a3 >>> 25, a3 = S + I2 | 0, w ^= a3 << 9 | a3 >>> 23, a3 = w + S | 0, O3 ^= a3 << 13 | a3 >>> 19, a3 = O3 + w | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = v6 + T4 | 0, d8 ^= a3 << 7 | a3 >>> 25, a3 = d8 + v6 | 0, Y2 ^= a3 << 9 | a3 >>> 23, a3 = Y2 + d8 | 0, T4 ^= a3 << 13 | a3 >>> 19, a3 = T4 + Y2 | 0, v6 ^= a3 << 18 | a3 >>> 14, a3 = y2 + l3 | 0, z2 ^= a3 << 7 | a3 >>> 25, a3 = z2 + y2 | 0, U3 ^= a3 << 9 | a3 >>> 23, a3 = U3 + z2 | 0, l3 ^= a3 << 13 | a3 >>> 19, a3 = l3 + U3 | 0, y2 ^= a3 << 18 | a3 >>> 14, a3 = H + p4 | 0, C2 ^= a3 << 7 | a3 >>> 25, a3 = C2 + H | 0, A4 ^= a3 << 9 | a3 >>> 23, a3 = A4 + C2 | 0, p4 ^= a3 << 13 | a3 >>> 19, a3 = p4 + A4 | 0, H ^= a3 << 18 | a3 >>> 14, a3 = I2 + C2 | 0, T4 ^= a3 << 7 | a3 >>> 25, a3 = T4 + I2 | 0, U3 ^= a3 << 9 | a3 >>> 23, a3 = U3 + T4 | 0, C2 ^= a3 << 13 | a3 >>> 19, a3 = C2 + U3 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = v6 + S | 0, l3 ^= a3 << 7 | a3 >>> 25, a3 = l3 + v6 | 0, A4 ^= a3 << 9 | a3 >>> 23, a3 = A4 + l3 | 0, S ^= a3 << 13 | a3 >>> 19, a3 = S + A4 | 0, v6 ^= a3 << 18 | a3 >>> 14, a3 = y2 + d8 | 0, p4 ^= a3 << 7 | a3 >>> 25, a3 = p4 + y2 | 0, w ^= a3 << 9 | a3 >>> 23, a3 = w + p4 | 0, d8 ^= a3 << 13 | a3 >>> 19, a3 = d8 + w | 0, y2 ^= a3 << 18 | a3 >>> 14, a3 = H + z2 | 0, O3 ^= a3 << 7 | a3 >>> 25, a3 = O3 + H | 0, Y2 ^= a3 << 9 | a3 >>> 23, a3 = Y2 + O3 | 0, z2 ^= a3 << 13 | a3 >>> 19, a3 = z2 + Y2 | 0, H ^= a3 << 18 | a3 >>> 14;
      I2 = I2 + n15 | 0, T4 = T4 + s5 | 0, U3 = U3 + x | 0, C2 = C2 + g2 | 0, S = S + b2 | 0, v6 = v6 + B2 | 0, l3 = l3 + m | 0, A4 = A4 + X2 | 0, w = w + R2 | 0, d8 = d8 + N2 | 0, y2 = y2 + P2 | 0, p4 = p4 + j | 0, O3 = O3 + D | 0, Y2 = Y2 + K2 | 0, z2 = z2 + Q2 | 0, H = H + k2 | 0, t11[0] = I2 >>> 0 & 255, t11[1] = I2 >>> 8 & 255, t11[2] = I2 >>> 16 & 255, t11[3] = I2 >>> 24 & 255, t11[4] = T4 >>> 0 & 255, t11[5] = T4 >>> 8 & 255, t11[6] = T4 >>> 16 & 255, t11[7] = T4 >>> 24 & 255, t11[8] = U3 >>> 0 & 255, t11[9] = U3 >>> 8 & 255, t11[10] = U3 >>> 16 & 255, t11[11] = U3 >>> 24 & 255, t11[12] = C2 >>> 0 & 255, t11[13] = C2 >>> 8 & 255, t11[14] = C2 >>> 16 & 255, t11[15] = C2 >>> 24 & 255, t11[16] = S >>> 0 & 255, t11[17] = S >>> 8 & 255, t11[18] = S >>> 16 & 255, t11[19] = S >>> 24 & 255, t11[20] = v6 >>> 0 & 255, t11[21] = v6 >>> 8 & 255, t11[22] = v6 >>> 16 & 255, t11[23] = v6 >>> 24 & 255, t11[24] = l3 >>> 0 & 255, t11[25] = l3 >>> 8 & 255, t11[26] = l3 >>> 16 & 255, t11[27] = l3 >>> 24 & 255, t11[28] = A4 >>> 0 & 255, t11[29] = A4 >>> 8 & 255, t11[30] = A4 >>> 16 & 255, t11[31] = A4 >>> 24 & 255, t11[32] = w >>> 0 & 255, t11[33] = w >>> 8 & 255, t11[34] = w >>> 16 & 255, t11[35] = w >>> 24 & 255, t11[36] = d8 >>> 0 & 255, t11[37] = d8 >>> 8 & 255, t11[38] = d8 >>> 16 & 255, t11[39] = d8 >>> 24 & 255, t11[40] = y2 >>> 0 & 255, t11[41] = y2 >>> 8 & 255, t11[42] = y2 >>> 16 & 255, t11[43] = y2 >>> 24 & 255, t11[44] = p4 >>> 0 & 255, t11[45] = p4 >>> 8 & 255, t11[46] = p4 >>> 16 & 255, t11[47] = p4 >>> 24 & 255, t11[48] = O3 >>> 0 & 255, t11[49] = O3 >>> 8 & 255, t11[50] = O3 >>> 16 & 255, t11[51] = O3 >>> 24 & 255, t11[52] = Y2 >>> 0 & 255, t11[53] = Y2 >>> 8 & 255, t11[54] = Y2 >>> 16 & 255, t11[55] = Y2 >>> 24 & 255, t11[56] = z2 >>> 0 & 255, t11[57] = z2 >>> 8 & 255, t11[58] = z2 >>> 16 & 255, t11[59] = z2 >>> 24 & 255, t11[60] = H >>> 0 & 255, t11[61] = H >>> 8 & 255, t11[62] = H >>> 16 & 255, t11[63] = H >>> 24 & 255;
    }
    function Pe2(t11, f3, r9, e14) {
      for (var n15 = e14[0] & 255 | (e14[1] & 255) << 8 | (e14[2] & 255) << 16 | (e14[3] & 255) << 24, s5 = r9[0] & 255 | (r9[1] & 255) << 8 | (r9[2] & 255) << 16 | (r9[3] & 255) << 24, x = r9[4] & 255 | (r9[5] & 255) << 8 | (r9[6] & 255) << 16 | (r9[7] & 255) << 24, g2 = r9[8] & 255 | (r9[9] & 255) << 8 | (r9[10] & 255) << 16 | (r9[11] & 255) << 24, b2 = r9[12] & 255 | (r9[13] & 255) << 8 | (r9[14] & 255) << 16 | (r9[15] & 255) << 24, B2 = e14[4] & 255 | (e14[5] & 255) << 8 | (e14[6] & 255) << 16 | (e14[7] & 255) << 24, m = f3[0] & 255 | (f3[1] & 255) << 8 | (f3[2] & 255) << 16 | (f3[3] & 255) << 24, X2 = f3[4] & 255 | (f3[5] & 255) << 8 | (f3[6] & 255) << 16 | (f3[7] & 255) << 24, R2 = f3[8] & 255 | (f3[9] & 255) << 8 | (f3[10] & 255) << 16 | (f3[11] & 255) << 24, N2 = f3[12] & 255 | (f3[13] & 255) << 8 | (f3[14] & 255) << 16 | (f3[15] & 255) << 24, P2 = e14[8] & 255 | (e14[9] & 255) << 8 | (e14[10] & 255) << 16 | (e14[11] & 255) << 24, j = r9[16] & 255 | (r9[17] & 255) << 8 | (r9[18] & 255) << 16 | (r9[19] & 255) << 24, D = r9[20] & 255 | (r9[21] & 255) << 8 | (r9[22] & 255) << 16 | (r9[23] & 255) << 24, K2 = r9[24] & 255 | (r9[25] & 255) << 8 | (r9[26] & 255) << 16 | (r9[27] & 255) << 24, Q2 = r9[28] & 255 | (r9[29] & 255) << 8 | (r9[30] & 255) << 16 | (r9[31] & 255) << 24, k2 = e14[12] & 255 | (e14[13] & 255) << 8 | (e14[14] & 255) << 16 | (e14[15] & 255) << 24, I2 = n15, T4 = s5, U3 = x, C2 = g2, S = b2, v6 = B2, l3 = m, A4 = X2, w = R2, d8 = N2, y2 = P2, p4 = j, O3 = D, Y2 = K2, z2 = Q2, H = k2, a3, J = 0; J < 20; J += 2)
        a3 = I2 + O3 | 0, S ^= a3 << 7 | a3 >>> 25, a3 = S + I2 | 0, w ^= a3 << 9 | a3 >>> 23, a3 = w + S | 0, O3 ^= a3 << 13 | a3 >>> 19, a3 = O3 + w | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = v6 + T4 | 0, d8 ^= a3 << 7 | a3 >>> 25, a3 = d8 + v6 | 0, Y2 ^= a3 << 9 | a3 >>> 23, a3 = Y2 + d8 | 0, T4 ^= a3 << 13 | a3 >>> 19, a3 = T4 + Y2 | 0, v6 ^= a3 << 18 | a3 >>> 14, a3 = y2 + l3 | 0, z2 ^= a3 << 7 | a3 >>> 25, a3 = z2 + y2 | 0, U3 ^= a3 << 9 | a3 >>> 23, a3 = U3 + z2 | 0, l3 ^= a3 << 13 | a3 >>> 19, a3 = l3 + U3 | 0, y2 ^= a3 << 18 | a3 >>> 14, a3 = H + p4 | 0, C2 ^= a3 << 7 | a3 >>> 25, a3 = C2 + H | 0, A4 ^= a3 << 9 | a3 >>> 23, a3 = A4 + C2 | 0, p4 ^= a3 << 13 | a3 >>> 19, a3 = p4 + A4 | 0, H ^= a3 << 18 | a3 >>> 14, a3 = I2 + C2 | 0, T4 ^= a3 << 7 | a3 >>> 25, a3 = T4 + I2 | 0, U3 ^= a3 << 9 | a3 >>> 23, a3 = U3 + T4 | 0, C2 ^= a3 << 13 | a3 >>> 19, a3 = C2 + U3 | 0, I2 ^= a3 << 18 | a3 >>> 14, a3 = v6 + S | 0, l3 ^= a3 << 7 | a3 >>> 25, a3 = l3 + v6 | 0, A4 ^= a3 << 9 | a3 >>> 23, a3 = A4 + l3 | 0, S ^= a3 << 13 | a3 >>> 19, a3 = S + A4 | 0, v6 ^= a3 << 18 | a3 >>> 14, a3 = y2 + d8 | 0, p4 ^= a3 << 7 | a3 >>> 25, a3 = p4 + y2 | 0, w ^= a3 << 9 | a3 >>> 23, a3 = w + p4 | 0, d8 ^= a3 << 13 | a3 >>> 19, a3 = d8 + w | 0, y2 ^= a3 << 18 | a3 >>> 14, a3 = H + z2 | 0, O3 ^= a3 << 7 | a3 >>> 25, a3 = O3 + H | 0, Y2 ^= a3 << 9 | a3 >>> 23, a3 = Y2 + O3 | 0, z2 ^= a3 << 13 | a3 >>> 19, a3 = z2 + Y2 | 0, H ^= a3 << 18 | a3 >>> 14;
      t11[0] = I2 >>> 0 & 255, t11[1] = I2 >>> 8 & 255, t11[2] = I2 >>> 16 & 255, t11[3] = I2 >>> 24 & 255, t11[4] = v6 >>> 0 & 255, t11[5] = v6 >>> 8 & 255, t11[6] = v6 >>> 16 & 255, t11[7] = v6 >>> 24 & 255, t11[8] = y2 >>> 0 & 255, t11[9] = y2 >>> 8 & 255, t11[10] = y2 >>> 16 & 255, t11[11] = y2 >>> 24 & 255, t11[12] = H >>> 0 & 255, t11[13] = H >>> 8 & 255, t11[14] = H >>> 16 & 255, t11[15] = H >>> 24 & 255, t11[16] = l3 >>> 0 & 255, t11[17] = l3 >>> 8 & 255, t11[18] = l3 >>> 16 & 255, t11[19] = l3 >>> 24 & 255, t11[20] = A4 >>> 0 & 255, t11[21] = A4 >>> 8 & 255, t11[22] = A4 >>> 16 & 255, t11[23] = A4 >>> 24 & 255, t11[24] = w >>> 0 & 255, t11[25] = w >>> 8 & 255, t11[26] = w >>> 16 & 255, t11[27] = w >>> 24 & 255, t11[28] = d8 >>> 0 & 255, t11[29] = d8 >>> 8 & 255, t11[30] = d8 >>> 16 & 255, t11[31] = d8 >>> 24 & 255;
    }
    function me3(t11, f3, r9, e14) {
      Se2(t11, f3, r9, e14);
    }
    function Be(t11, f3, r9, e14) {
      Pe2(t11, f3, r9, e14);
    }
    var we2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Le2(t11, f3, r9, e14, n15, s5, x) {
      var g2 = new Uint8Array(16), b2 = new Uint8Array(64), B2, m;
      for (m = 0; m < 16; m++) g2[m] = 0;
      for (m = 0; m < 8; m++) g2[m] = s5[m];
      for (; n15 >= 64; ) {
        for (me3(b2, g2, x, we2), m = 0; m < 64; m++) t11[f3 + m] = r9[e14 + m] ^ b2[m];
        for (B2 = 1, m = 8; m < 16; m++)
          B2 = B2 + (g2[m] & 255) | 0, g2[m] = B2 & 255, B2 >>>= 8;
        n15 -= 64, f3 += 64, e14 += 64;
      }
      if (n15 > 0)
        for (me3(b2, g2, x, we2), m = 0; m < n15; m++) t11[f3 + m] = r9[e14 + m] ^ b2[m];
      return 0;
    }
    function pe3(t11, f3, r9, e14, n15) {
      var s5 = new Uint8Array(16), x = new Uint8Array(64), g2, b2;
      for (b2 = 0; b2 < 16; b2++) s5[b2] = 0;
      for (b2 = 0; b2 < 8; b2++) s5[b2] = e14[b2];
      for (; r9 >= 64; ) {
        for (me3(x, s5, n15, we2), b2 = 0; b2 < 64; b2++) t11[f3 + b2] = x[b2];
        for (g2 = 1, b2 = 8; b2 < 16; b2++)
          g2 = g2 + (s5[b2] & 255) | 0, s5[b2] = g2 & 255, g2 >>>= 8;
        r9 -= 64, f3 += 64;
      }
      if (r9 > 0)
        for (me3(x, s5, n15, we2), b2 = 0; b2 < r9; b2++) t11[f3 + b2] = x[b2];
      return 0;
    }
    function Ot(t11, f3, r9, e14, n15) {
      var s5 = new Uint8Array(32);
      Be(s5, e14, n15, we2);
      for (var x = new Uint8Array(8), g2 = 0; g2 < 8; g2++) x[g2] = e14[g2 + 16];
      return pe3(t11, f3, r9, x, s5);
    }
    function ct(t11, f3, r9, e14, n15, s5, x) {
      var g2 = new Uint8Array(32);
      Be(g2, s5, x, we2);
      for (var b2 = new Uint8Array(8), B2 = 0; B2 < 8; B2++) b2[B2] = s5[B2 + 16];
      return Le2(t11, f3, r9, e14, n15, b2, g2);
    }
    var $e = function(t11) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var f3, r9, e14, n15, s5, x, g2, b2;
      f3 = t11[0] & 255 | (t11[1] & 255) << 8, this.r[0] = f3 & 8191, r9 = t11[2] & 255 | (t11[3] & 255) << 8, this.r[1] = (f3 >>> 13 | r9 << 3) & 8191, e14 = t11[4] & 255 | (t11[5] & 255) << 8, this.r[2] = (r9 >>> 10 | e14 << 6) & 7939, n15 = t11[6] & 255 | (t11[7] & 255) << 8, this.r[3] = (e14 >>> 7 | n15 << 9) & 8191, s5 = t11[8] & 255 | (t11[9] & 255) << 8, this.r[4] = (n15 >>> 4 | s5 << 12) & 255, this.r[5] = s5 >>> 1 & 8190, x = t11[10] & 255 | (t11[11] & 255) << 8, this.r[6] = (s5 >>> 14 | x << 2) & 8191, g2 = t11[12] & 255 | (t11[13] & 255) << 8, this.r[7] = (x >>> 11 | g2 << 5) & 8065, b2 = t11[14] & 255 | (t11[15] & 255) << 8, this.r[8] = (g2 >>> 8 | b2 << 8) & 8191, this.r[9] = b2 >>> 5 & 127, this.pad[0] = t11[16] & 255 | (t11[17] & 255) << 8, this.pad[1] = t11[18] & 255 | (t11[19] & 255) << 8, this.pad[2] = t11[20] & 255 | (t11[21] & 255) << 8, this.pad[3] = t11[22] & 255 | (t11[23] & 255) << 8, this.pad[4] = t11[24] & 255 | (t11[25] & 255) << 8, this.pad[5] = t11[26] & 255 | (t11[27] & 255) << 8, this.pad[6] = t11[28] & 255 | (t11[29] & 255) << 8, this.pad[7] = t11[30] & 255 | (t11[31] & 255) << 8;
    };
    $e.prototype.blocks = function(t11, f3, r9) {
      for (var e14 = this.fin ? 0 : 2048, n15, s5, x, g2, b2, B2, m, X2, R2, N2, P2, j, D, K2, Q2, k2, I2, T4, U3, C2 = this.h[0], S = this.h[1], v6 = this.h[2], l3 = this.h[3], A4 = this.h[4], w = this.h[5], d8 = this.h[6], y2 = this.h[7], p4 = this.h[8], O3 = this.h[9], Y2 = this.r[0], z2 = this.r[1], H = this.r[2], a3 = this.r[3], J = this.r[4], V3 = this.r[5], _2 = this.r[6], F = this.r[7], q = this.r[8], G = this.r[9]; r9 >= 16; )
        n15 = t11[f3 + 0] & 255 | (t11[f3 + 1] & 255) << 8, C2 += n15 & 8191, s5 = t11[f3 + 2] & 255 | (t11[f3 + 3] & 255) << 8, S += (n15 >>> 13 | s5 << 3) & 8191, x = t11[f3 + 4] & 255 | (t11[f3 + 5] & 255) << 8, v6 += (s5 >>> 10 | x << 6) & 8191, g2 = t11[f3 + 6] & 255 | (t11[f3 + 7] & 255) << 8, l3 += (x >>> 7 | g2 << 9) & 8191, b2 = t11[f3 + 8] & 255 | (t11[f3 + 9] & 255) << 8, A4 += (g2 >>> 4 | b2 << 12) & 8191, w += b2 >>> 1 & 8191, B2 = t11[f3 + 10] & 255 | (t11[f3 + 11] & 255) << 8, d8 += (b2 >>> 14 | B2 << 2) & 8191, m = t11[f3 + 12] & 255 | (t11[f3 + 13] & 255) << 8, y2 += (B2 >>> 11 | m << 5) & 8191, X2 = t11[f3 + 14] & 255 | (t11[f3 + 15] & 255) << 8, p4 += (m >>> 8 | X2 << 8) & 8191, O3 += X2 >>> 5 | e14, R2 = 0, N2 = R2, N2 += C2 * Y2, N2 += S * (5 * G), N2 += v6 * (5 * q), N2 += l3 * (5 * F), N2 += A4 * (5 * _2), R2 = N2 >>> 13, N2 &= 8191, N2 += w * (5 * V3), N2 += d8 * (5 * J), N2 += y2 * (5 * a3), N2 += p4 * (5 * H), N2 += O3 * (5 * z2), R2 += N2 >>> 13, N2 &= 8191, P2 = R2, P2 += C2 * z2, P2 += S * Y2, P2 += v6 * (5 * G), P2 += l3 * (5 * q), P2 += A4 * (5 * F), R2 = P2 >>> 13, P2 &= 8191, P2 += w * (5 * _2), P2 += d8 * (5 * V3), P2 += y2 * (5 * J), P2 += p4 * (5 * a3), P2 += O3 * (5 * H), R2 += P2 >>> 13, P2 &= 8191, j = R2, j += C2 * H, j += S * z2, j += v6 * Y2, j += l3 * (5 * G), j += A4 * (5 * q), R2 = j >>> 13, j &= 8191, j += w * (5 * F), j += d8 * (5 * _2), j += y2 * (5 * V3), j += p4 * (5 * J), j += O3 * (5 * a3), R2 += j >>> 13, j &= 8191, D = R2, D += C2 * a3, D += S * H, D += v6 * z2, D += l3 * Y2, D += A4 * (5 * G), R2 = D >>> 13, D &= 8191, D += w * (5 * q), D += d8 * (5 * F), D += y2 * (5 * _2), D += p4 * (5 * V3), D += O3 * (5 * J), R2 += D >>> 13, D &= 8191, K2 = R2, K2 += C2 * J, K2 += S * a3, K2 += v6 * H, K2 += l3 * z2, K2 += A4 * Y2, R2 = K2 >>> 13, K2 &= 8191, K2 += w * (5 * G), K2 += d8 * (5 * q), K2 += y2 * (5 * F), K2 += p4 * (5 * _2), K2 += O3 * (5 * V3), R2 += K2 >>> 13, K2 &= 8191, Q2 = R2, Q2 += C2 * V3, Q2 += S * J, Q2 += v6 * a3, Q2 += l3 * H, Q2 += A4 * z2, R2 = Q2 >>> 13, Q2 &= 8191, Q2 += w * Y2, Q2 += d8 * (5 * G), Q2 += y2 * (5 * q), Q2 += p4 * (5 * F), Q2 += O3 * (5 * _2), R2 += Q2 >>> 13, Q2 &= 8191, k2 = R2, k2 += C2 * _2, k2 += S * V3, k2 += v6 * J, k2 += l3 * a3, k2 += A4 * H, R2 = k2 >>> 13, k2 &= 8191, k2 += w * z2, k2 += d8 * Y2, k2 += y2 * (5 * G), k2 += p4 * (5 * q), k2 += O3 * (5 * F), R2 += k2 >>> 13, k2 &= 8191, I2 = R2, I2 += C2 * F, I2 += S * _2, I2 += v6 * V3, I2 += l3 * J, I2 += A4 * a3, R2 = I2 >>> 13, I2 &= 8191, I2 += w * H, I2 += d8 * z2, I2 += y2 * Y2, I2 += p4 * (5 * G), I2 += O3 * (5 * q), R2 += I2 >>> 13, I2 &= 8191, T4 = R2, T4 += C2 * q, T4 += S * F, T4 += v6 * _2, T4 += l3 * V3, T4 += A4 * J, R2 = T4 >>> 13, T4 &= 8191, T4 += w * a3, T4 += d8 * H, T4 += y2 * z2, T4 += p4 * Y2, T4 += O3 * (5 * G), R2 += T4 >>> 13, T4 &= 8191, U3 = R2, U3 += C2 * G, U3 += S * q, U3 += v6 * F, U3 += l3 * _2, U3 += A4 * V3, R2 = U3 >>> 13, U3 &= 8191, U3 += w * J, U3 += d8 * a3, U3 += y2 * H, U3 += p4 * z2, U3 += O3 * Y2, R2 += U3 >>> 13, U3 &= 8191, R2 = (R2 << 2) + R2 | 0, R2 = R2 + N2 | 0, N2 = R2 & 8191, R2 = R2 >>> 13, P2 += R2, C2 = N2, S = P2, v6 = j, l3 = D, A4 = K2, w = Q2, d8 = k2, y2 = I2, p4 = T4, O3 = U3, f3 += 16, r9 -= 16;
      this.h[0] = C2, this.h[1] = S, this.h[2] = v6, this.h[3] = l3, this.h[4] = A4, this.h[5] = w, this.h[6] = d8, this.h[7] = y2, this.h[8] = p4, this.h[9] = O3;
    }, $e.prototype.finish = function(t11, f3) {
      var r9 = new Uint16Array(10), e14, n15, s5, x;
      if (this.leftover) {
        for (x = this.leftover, this.buffer[x++] = 1; x < 16; x++) this.buffer[x] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (e14 = this.h[1] >>> 13, this.h[1] &= 8191, x = 2; x < 10; x++)
        this.h[x] += e14, e14 = this.h[x] >>> 13, this.h[x] &= 8191;
      for (this.h[0] += e14 * 5, e14 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += e14, e14 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += e14, r9[0] = this.h[0] + 5, e14 = r9[0] >>> 13, r9[0] &= 8191, x = 1; x < 10; x++)
        r9[x] = this.h[x] + e14, e14 = r9[x] >>> 13, r9[x] &= 8191;
      for (r9[9] -= 8192, n15 = (e14 ^ 1) - 1, x = 0; x < 10; x++) r9[x] &= n15;
      for (n15 = ~n15, x = 0; x < 10; x++) this.h[x] = this.h[x] & n15 | r9[x];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, s5 = this.h[0] + this.pad[0], this.h[0] = s5 & 65535, x = 1; x < 8; x++)
        s5 = (this.h[x] + this.pad[x] | 0) + (s5 >>> 16) | 0, this.h[x] = s5 & 65535;
      t11[f3 + 0] = this.h[0] >>> 0 & 255, t11[f3 + 1] = this.h[0] >>> 8 & 255, t11[f3 + 2] = this.h[1] >>> 0 & 255, t11[f3 + 3] = this.h[1] >>> 8 & 255, t11[f3 + 4] = this.h[2] >>> 0 & 255, t11[f3 + 5] = this.h[2] >>> 8 & 255, t11[f3 + 6] = this.h[3] >>> 0 & 255, t11[f3 + 7] = this.h[3] >>> 8 & 255, t11[f3 + 8] = this.h[4] >>> 0 & 255, t11[f3 + 9] = this.h[4] >>> 8 & 255, t11[f3 + 10] = this.h[5] >>> 0 & 255, t11[f3 + 11] = this.h[5] >>> 8 & 255, t11[f3 + 12] = this.h[6] >>> 0 & 255, t11[f3 + 13] = this.h[6] >>> 8 & 255, t11[f3 + 14] = this.h[7] >>> 0 & 255, t11[f3 + 15] = this.h[7] >>> 8 & 255;
    }, $e.prototype.update = function(t11, f3, r9) {
      var e14, n15;
      if (this.leftover) {
        for (n15 = 16 - this.leftover, n15 > r9 && (n15 = r9), e14 = 0; e14 < n15; e14++)
          this.buffer[this.leftover + e14] = t11[f3 + e14];
        if (r9 -= n15, f3 += n15, this.leftover += n15, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (r9 >= 16 && (n15 = r9 - r9 % 16, this.blocks(t11, f3, n15), f3 += n15, r9 -= n15), r9) {
        for (e14 = 0; e14 < r9; e14++)
          this.buffer[this.leftover + e14] = t11[f3 + e14];
        this.leftover += r9;
      }
    };
    function xt(t11, f3, r9, e14, n15, s5) {
      var x = new $e(s5);
      return x.update(r9, e14, n15), x.finish(t11, f3), 0;
    }
    function Mt(t11, f3, r9, e14, n15, s5) {
      var x = new Uint8Array(16);
      return xt(x, 0, r9, e14, n15, s5), Ce2(t11, f3, x, 0);
    }
    function lt(t11, f3, r9, e14, n15) {
      var s5;
      if (r9 < 32) return -1;
      for (ct(t11, 0, f3, 0, r9, e14, n15), xt(t11, 16, t11, 32, r9 - 32, t11), s5 = 0; s5 < 16; s5++) t11[s5] = 0;
      return 0;
    }
    function At(t11, f3, r9, e14, n15) {
      var s5, x = new Uint8Array(32);
      if (r9 < 32 || (Ot(x, 0, 32, e14, n15), Mt(f3, 16, f3, 32, r9 - 32, x) !== 0)) return -1;
      for (ct(t11, 0, f3, 0, r9, e14, n15), s5 = 0; s5 < 32; s5++) t11[s5] = 0;
      return 0;
    }
    function Ue2(t11, f3) {
      var r9;
      for (r9 = 0; r9 < 16; r9++) t11[r9] = f3[r9] | 0;
    }
    function ht(t11) {
      var f3, r9, e14 = 1;
      for (f3 = 0; f3 < 16; f3++)
        r9 = t11[f3] + e14 + 65535, e14 = Math.floor(r9 / 65536), t11[f3] = r9 - e14 * 65536;
      t11[0] += e14 - 1 + 37 * (e14 - 1);
    }
    function Ke(t11, f3, r9) {
      for (var e14, n15 = ~(r9 - 1), s5 = 0; s5 < 16; s5++)
        e14 = n15 & (t11[s5] ^ f3[s5]), t11[s5] ^= e14, f3[s5] ^= e14;
    }
    function ke2(t11, f3) {
      var r9, e14, n15, s5 = o16(), x = o16();
      for (r9 = 0; r9 < 16; r9++) x[r9] = f3[r9];
      for (ht(x), ht(x), ht(x), e14 = 0; e14 < 2; e14++) {
        for (s5[0] = x[0] - 65517, r9 = 1; r9 < 15; r9++)
          s5[r9] = x[r9] - 65535 - (s5[r9 - 1] >> 16 & 1), s5[r9 - 1] &= 65535;
        s5[15] = x[15] - 32767 - (s5[14] >> 16 & 1), n15 = s5[15] >> 16 & 1, s5[14] &= 65535, Ke(x, s5, 1 - n15);
      }
      for (r9 = 0; r9 < 16; r9++)
        t11[2 * r9] = x[r9] & 255, t11[2 * r9 + 1] = x[r9] >> 8;
    }
    function Nt(t11, f3) {
      var r9 = new Uint8Array(32), e14 = new Uint8Array(32);
      return ke2(r9, t11), ke2(e14, f3), ve2(r9, 0, e14, 0);
    }
    function Pt(t11) {
      var f3 = new Uint8Array(32);
      return ke2(f3, t11), f3[0] & 1;
    }
    function ut2(t11, f3) {
      var r9;
      for (r9 = 0; r9 < 16; r9++) t11[r9] = f3[2 * r9] + (f3[2 * r9 + 1] << 8);
      t11[15] &= 32767;
    }
    function be(t11, f3, r9) {
      for (var e14 = 0; e14 < 16; e14++) t11[e14] = f3[e14] + r9[e14];
    }
    function Ee2(t11, f3, r9) {
      for (var e14 = 0; e14 < 16; e14++) t11[e14] = f3[e14] - r9[e14];
    }
    function Z2(t11, f3, r9) {
      var e14, n15, s5 = 0, x = 0, g2 = 0, b2 = 0, B2 = 0, m = 0, X2 = 0, R2 = 0, N2 = 0, P2 = 0, j = 0, D = 0, K2 = 0, Q2 = 0, k2 = 0, I2 = 0, T4 = 0, U3 = 0, C2 = 0, S = 0, v6 = 0, l3 = 0, A4 = 0, w = 0, d8 = 0, y2 = 0, p4 = 0, O3 = 0, Y2 = 0, z2 = 0, H = 0, a3 = r9[0], J = r9[1], V3 = r9[2], _2 = r9[3], F = r9[4], q = r9[5], G = r9[6], ae2 = r9[7], ee = r9[8], fe = r9[9], ne2 = r9[10], oe2 = r9[11], ce = r9[12], Ae2 = r9[13], he2 = r9[14], ue2 = r9[15];
      e14 = f3[0], s5 += e14 * a3, x += e14 * J, g2 += e14 * V3, b2 += e14 * _2, B2 += e14 * F, m += e14 * q, X2 += e14 * G, R2 += e14 * ae2, N2 += e14 * ee, P2 += e14 * fe, j += e14 * ne2, D += e14 * oe2, K2 += e14 * ce, Q2 += e14 * Ae2, k2 += e14 * he2, I2 += e14 * ue2, e14 = f3[1], x += e14 * a3, g2 += e14 * J, b2 += e14 * V3, B2 += e14 * _2, m += e14 * F, X2 += e14 * q, R2 += e14 * G, N2 += e14 * ae2, P2 += e14 * ee, j += e14 * fe, D += e14 * ne2, K2 += e14 * oe2, Q2 += e14 * ce, k2 += e14 * Ae2, I2 += e14 * he2, T4 += e14 * ue2, e14 = f3[2], g2 += e14 * a3, b2 += e14 * J, B2 += e14 * V3, m += e14 * _2, X2 += e14 * F, R2 += e14 * q, N2 += e14 * G, P2 += e14 * ae2, j += e14 * ee, D += e14 * fe, K2 += e14 * ne2, Q2 += e14 * oe2, k2 += e14 * ce, I2 += e14 * Ae2, T4 += e14 * he2, U3 += e14 * ue2, e14 = f3[3], b2 += e14 * a3, B2 += e14 * J, m += e14 * V3, X2 += e14 * _2, R2 += e14 * F, N2 += e14 * q, P2 += e14 * G, j += e14 * ae2, D += e14 * ee, K2 += e14 * fe, Q2 += e14 * ne2, k2 += e14 * oe2, I2 += e14 * ce, T4 += e14 * Ae2, U3 += e14 * he2, C2 += e14 * ue2, e14 = f3[4], B2 += e14 * a3, m += e14 * J, X2 += e14 * V3, R2 += e14 * _2, N2 += e14 * F, P2 += e14 * q, j += e14 * G, D += e14 * ae2, K2 += e14 * ee, Q2 += e14 * fe, k2 += e14 * ne2, I2 += e14 * oe2, T4 += e14 * ce, U3 += e14 * Ae2, C2 += e14 * he2, S += e14 * ue2, e14 = f3[5], m += e14 * a3, X2 += e14 * J, R2 += e14 * V3, N2 += e14 * _2, P2 += e14 * F, j += e14 * q, D += e14 * G, K2 += e14 * ae2, Q2 += e14 * ee, k2 += e14 * fe, I2 += e14 * ne2, T4 += e14 * oe2, U3 += e14 * ce, C2 += e14 * Ae2, S += e14 * he2, v6 += e14 * ue2, e14 = f3[6], X2 += e14 * a3, R2 += e14 * J, N2 += e14 * V3, P2 += e14 * _2, j += e14 * F, D += e14 * q, K2 += e14 * G, Q2 += e14 * ae2, k2 += e14 * ee, I2 += e14 * fe, T4 += e14 * ne2, U3 += e14 * oe2, C2 += e14 * ce, S += e14 * Ae2, v6 += e14 * he2, l3 += e14 * ue2, e14 = f3[7], R2 += e14 * a3, N2 += e14 * J, P2 += e14 * V3, j += e14 * _2, D += e14 * F, K2 += e14 * q, Q2 += e14 * G, k2 += e14 * ae2, I2 += e14 * ee, T4 += e14 * fe, U3 += e14 * ne2, C2 += e14 * oe2, S += e14 * ce, v6 += e14 * Ae2, l3 += e14 * he2, A4 += e14 * ue2, e14 = f3[8], N2 += e14 * a3, P2 += e14 * J, j += e14 * V3, D += e14 * _2, K2 += e14 * F, Q2 += e14 * q, k2 += e14 * G, I2 += e14 * ae2, T4 += e14 * ee, U3 += e14 * fe, C2 += e14 * ne2, S += e14 * oe2, v6 += e14 * ce, l3 += e14 * Ae2, A4 += e14 * he2, w += e14 * ue2, e14 = f3[9], P2 += e14 * a3, j += e14 * J, D += e14 * V3, K2 += e14 * _2, Q2 += e14 * F, k2 += e14 * q, I2 += e14 * G, T4 += e14 * ae2, U3 += e14 * ee, C2 += e14 * fe, S += e14 * ne2, v6 += e14 * oe2, l3 += e14 * ce, A4 += e14 * Ae2, w += e14 * he2, d8 += e14 * ue2, e14 = f3[10], j += e14 * a3, D += e14 * J, K2 += e14 * V3, Q2 += e14 * _2, k2 += e14 * F, I2 += e14 * q, T4 += e14 * G, U3 += e14 * ae2, C2 += e14 * ee, S += e14 * fe, v6 += e14 * ne2, l3 += e14 * oe2, A4 += e14 * ce, w += e14 * Ae2, d8 += e14 * he2, y2 += e14 * ue2, e14 = f3[11], D += e14 * a3, K2 += e14 * J, Q2 += e14 * V3, k2 += e14 * _2, I2 += e14 * F, T4 += e14 * q, U3 += e14 * G, C2 += e14 * ae2, S += e14 * ee, v6 += e14 * fe, l3 += e14 * ne2, A4 += e14 * oe2, w += e14 * ce, d8 += e14 * Ae2, y2 += e14 * he2, p4 += e14 * ue2, e14 = f3[12], K2 += e14 * a3, Q2 += e14 * J, k2 += e14 * V3, I2 += e14 * _2, T4 += e14 * F, U3 += e14 * q, C2 += e14 * G, S += e14 * ae2, v6 += e14 * ee, l3 += e14 * fe, A4 += e14 * ne2, w += e14 * oe2, d8 += e14 * ce, y2 += e14 * Ae2, p4 += e14 * he2, O3 += e14 * ue2, e14 = f3[13], Q2 += e14 * a3, k2 += e14 * J, I2 += e14 * V3, T4 += e14 * _2, U3 += e14 * F, C2 += e14 * q, S += e14 * G, v6 += e14 * ae2, l3 += e14 * ee, A4 += e14 * fe, w += e14 * ne2, d8 += e14 * oe2, y2 += e14 * ce, p4 += e14 * Ae2, O3 += e14 * he2, Y2 += e14 * ue2, e14 = f3[14], k2 += e14 * a3, I2 += e14 * J, T4 += e14 * V3, U3 += e14 * _2, C2 += e14 * F, S += e14 * q, v6 += e14 * G, l3 += e14 * ae2, A4 += e14 * ee, w += e14 * fe, d8 += e14 * ne2, y2 += e14 * oe2, p4 += e14 * ce, O3 += e14 * Ae2, Y2 += e14 * he2, z2 += e14 * ue2, e14 = f3[15], I2 += e14 * a3, T4 += e14 * J, U3 += e14 * V3, C2 += e14 * _2, S += e14 * F, v6 += e14 * q, l3 += e14 * G, A4 += e14 * ae2, w += e14 * ee, d8 += e14 * fe, y2 += e14 * ne2, p4 += e14 * oe2, O3 += e14 * ce, Y2 += e14 * Ae2, z2 += e14 * he2, H += e14 * ue2, s5 += 38 * T4, x += 38 * U3, g2 += 38 * C2, b2 += 38 * S, B2 += 38 * v6, m += 38 * l3, X2 += 38 * A4, R2 += 38 * w, N2 += 38 * d8, P2 += 38 * y2, j += 38 * p4, D += 38 * O3, K2 += 38 * Y2, Q2 += 38 * z2, k2 += 38 * H, n15 = 1, e14 = s5 + n15 + 65535, n15 = Math.floor(e14 / 65536), s5 = e14 - n15 * 65536, e14 = x + n15 + 65535, n15 = Math.floor(e14 / 65536), x = e14 - n15 * 65536, e14 = g2 + n15 + 65535, n15 = Math.floor(e14 / 65536), g2 = e14 - n15 * 65536, e14 = b2 + n15 + 65535, n15 = Math.floor(e14 / 65536), b2 = e14 - n15 * 65536, e14 = B2 + n15 + 65535, n15 = Math.floor(e14 / 65536), B2 = e14 - n15 * 65536, e14 = m + n15 + 65535, n15 = Math.floor(e14 / 65536), m = e14 - n15 * 65536, e14 = X2 + n15 + 65535, n15 = Math.floor(e14 / 65536), X2 = e14 - n15 * 65536, e14 = R2 + n15 + 65535, n15 = Math.floor(e14 / 65536), R2 = e14 - n15 * 65536, e14 = N2 + n15 + 65535, n15 = Math.floor(e14 / 65536), N2 = e14 - n15 * 65536, e14 = P2 + n15 + 65535, n15 = Math.floor(e14 / 65536), P2 = e14 - n15 * 65536, e14 = j + n15 + 65535, n15 = Math.floor(e14 / 65536), j = e14 - n15 * 65536, e14 = D + n15 + 65535, n15 = Math.floor(e14 / 65536), D = e14 - n15 * 65536, e14 = K2 + n15 + 65535, n15 = Math.floor(e14 / 65536), K2 = e14 - n15 * 65536, e14 = Q2 + n15 + 65535, n15 = Math.floor(e14 / 65536), Q2 = e14 - n15 * 65536, e14 = k2 + n15 + 65535, n15 = Math.floor(e14 / 65536), k2 = e14 - n15 * 65536, e14 = I2 + n15 + 65535, n15 = Math.floor(e14 / 65536), I2 = e14 - n15 * 65536, s5 += n15 - 1 + 37 * (n15 - 1), n15 = 1, e14 = s5 + n15 + 65535, n15 = Math.floor(e14 / 65536), s5 = e14 - n15 * 65536, e14 = x + n15 + 65535, n15 = Math.floor(e14 / 65536), x = e14 - n15 * 65536, e14 = g2 + n15 + 65535, n15 = Math.floor(e14 / 65536), g2 = e14 - n15 * 65536, e14 = b2 + n15 + 65535, n15 = Math.floor(e14 / 65536), b2 = e14 - n15 * 65536, e14 = B2 + n15 + 65535, n15 = Math.floor(e14 / 65536), B2 = e14 - n15 * 65536, e14 = m + n15 + 65535, n15 = Math.floor(e14 / 65536), m = e14 - n15 * 65536, e14 = X2 + n15 + 65535, n15 = Math.floor(e14 / 65536), X2 = e14 - n15 * 65536, e14 = R2 + n15 + 65535, n15 = Math.floor(e14 / 65536), R2 = e14 - n15 * 65536, e14 = N2 + n15 + 65535, n15 = Math.floor(e14 / 65536), N2 = e14 - n15 * 65536, e14 = P2 + n15 + 65535, n15 = Math.floor(e14 / 65536), P2 = e14 - n15 * 65536, e14 = j + n15 + 65535, n15 = Math.floor(e14 / 65536), j = e14 - n15 * 65536, e14 = D + n15 + 65535, n15 = Math.floor(e14 / 65536), D = e14 - n15 * 65536, e14 = K2 + n15 + 65535, n15 = Math.floor(e14 / 65536), K2 = e14 - n15 * 65536, e14 = Q2 + n15 + 65535, n15 = Math.floor(e14 / 65536), Q2 = e14 - n15 * 65536, e14 = k2 + n15 + 65535, n15 = Math.floor(e14 / 65536), k2 = e14 - n15 * 65536, e14 = I2 + n15 + 65535, n15 = Math.floor(e14 / 65536), I2 = e14 - n15 * 65536, s5 += n15 - 1 + 37 * (n15 - 1), t11[0] = s5, t11[1] = x, t11[2] = g2, t11[3] = b2, t11[4] = B2, t11[5] = m, t11[6] = X2, t11[7] = R2, t11[8] = N2, t11[9] = P2, t11[10] = j, t11[11] = D, t11[12] = K2, t11[13] = Q2, t11[14] = k2, t11[15] = I2;
    }
    function ge(t11, f3) {
      Z2(t11, f3, f3);
    }
    function Kt2(t11, f3) {
      var r9 = o16(), e14;
      for (e14 = 0; e14 < 16; e14++) r9[e14] = f3[e14];
      for (e14 = 253; e14 >= 0; e14--)
        ge(r9, r9), e14 !== 2 && e14 !== 4 && Z2(r9, r9, f3);
      for (e14 = 0; e14 < 16; e14++) t11[e14] = r9[e14];
    }
    function kt(t11, f3) {
      var r9 = o16(), e14;
      for (e14 = 0; e14 < 16; e14++) r9[e14] = f3[e14];
      for (e14 = 250; e14 >= 0; e14--)
        ge(r9, r9), e14 !== 1 && Z2(r9, r9, f3);
      for (e14 = 0; e14 < 16; e14++) t11[e14] = r9[e14];
    }
    function et(t11, f3, r9) {
      var e14 = new Uint8Array(32), n15 = new Float64Array(80), s5, x, g2 = o16(), b2 = o16(), B2 = o16(), m = o16(), X2 = o16(), R2 = o16();
      for (x = 0; x < 31; x++) e14[x] = f3[x];
      for (e14[31] = f3[31] & 127 | 64, e14[0] &= 248, ut2(n15, r9), x = 0; x < 16; x++)
        b2[x] = n15[x], m[x] = g2[x] = B2[x] = 0;
      for (g2[0] = m[0] = 1, x = 254; x >= 0; --x)
        s5 = e14[x >>> 3] >>> (x & 7) & 1, Ke(g2, b2, s5), Ke(B2, m, s5), be(X2, g2, B2), Ee2(g2, g2, B2), be(B2, b2, m), Ee2(b2, b2, m), ge(m, X2), ge(R2, g2), Z2(g2, B2, g2), Z2(B2, b2, X2), be(X2, g2, B2), Ee2(g2, g2, B2), ge(b2, g2), Ee2(B2, m, R2), Z2(g2, B2, $2), be(g2, g2, m), Z2(B2, B2, g2), Z2(g2, m, R2), Z2(m, b2, n15), ge(b2, X2), Ke(g2, b2, s5), Ke(B2, m, s5);
      for (x = 0; x < 16; x++)
        n15[x + 16] = g2[x], n15[x + 32] = B2[x], n15[x + 48] = b2[x], n15[x + 64] = m[x];
      var N2 = n15.subarray(32), P2 = n15.subarray(16);
      return Kt2(N2, N2), Z2(P2, P2, N2), ke2(t11, P2), 0;
    }
    function tt(t11, f3) {
      return et(t11, f3, E2);
    }
    function Qt2(t11, f3) {
      return h3(f3, 32), tt(t11, f3);
    }
    function rt(t11, f3, r9) {
      var e14 = new Uint8Array(32);
      return et(e14, r9, f3), Be(t11, u, e14, we2);
    }
    var Dt2 = lt, lr2 = At;
    function Ar(t11, f3, r9, e14, n15, s5) {
      var x = new Uint8Array(32);
      return rt(x, n15, s5), Dt2(t11, f3, r9, e14, x);
    }
    function hr2(t11, f3, r9, e14, n15, s5) {
      var x = new Uint8Array(32);
      return rt(x, n15, s5), lr2(t11, f3, r9, e14, x);
    }
    var jt2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Yt(t11, f3, r9, e14) {
      for (var n15 = new Int32Array(16), s5 = new Int32Array(16), x, g2, b2, B2, m, X2, R2, N2, P2, j, D, K2, Q2, k2, I2, T4, U3, C2, S, v6, l3, A4, w, d8, y2, p4, O3 = t11[0], Y2 = t11[1], z2 = t11[2], H = t11[3], a3 = t11[4], J = t11[5], V3 = t11[6], _2 = t11[7], F = f3[0], q = f3[1], G = f3[2], ae2 = f3[3], ee = f3[4], fe = f3[5], ne2 = f3[6], oe2 = f3[7], ce = 0; e14 >= 128; ) {
        for (S = 0; S < 16; S++)
          v6 = 8 * S + ce, n15[S] = r9[v6 + 0] << 24 | r9[v6 + 1] << 16 | r9[v6 + 2] << 8 | r9[v6 + 3], s5[S] = r9[v6 + 4] << 24 | r9[v6 + 5] << 16 | r9[v6 + 6] << 8 | r9[v6 + 7];
        for (S = 0; S < 80; S++)
          if (x = O3, g2 = Y2, b2 = z2, B2 = H, m = a3, X2 = J, R2 = V3, N2 = _2, P2 = F, j = q, D = G, K2 = ae2, Q2 = ee, k2 = fe, I2 = ne2, T4 = oe2, l3 = _2, A4 = oe2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = (a3 >>> 14 | ee << 18) ^ (a3 >>> 18 | ee << 14) ^ (ee >>> 9 | a3 << 23), A4 = (ee >>> 14 | a3 << 18) ^ (ee >>> 18 | a3 << 14) ^ (a3 >>> 9 | ee << 23), w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, l3 = a3 & J ^ ~a3 & V3, A4 = ee & fe ^ ~ee & ne2, w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, l3 = jt2[S * 2], A4 = jt2[S * 2 + 1], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, l3 = n15[S % 16], A4 = s5[S % 16], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, U3 = y2 & 65535 | p4 << 16, C2 = w & 65535 | d8 << 16, l3 = U3, A4 = C2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = (O3 >>> 28 | F << 4) ^ (F >>> 2 | O3 << 30) ^ (F >>> 7 | O3 << 25), A4 = (F >>> 28 | O3 << 4) ^ (O3 >>> 2 | F << 30) ^ (O3 >>> 7 | F << 25), w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, l3 = O3 & Y2 ^ O3 & z2 ^ Y2 & z2, A4 = F & q ^ F & G ^ q & G, w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, N2 = y2 & 65535 | p4 << 16, T4 = w & 65535 | d8 << 16, l3 = B2, A4 = K2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = U3, A4 = C2, w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, B2 = y2 & 65535 | p4 << 16, K2 = w & 65535 | d8 << 16, Y2 = x, z2 = g2, H = b2, a3 = B2, J = m, V3 = X2, _2 = R2, O3 = N2, q = P2, G = j, ae2 = D, ee = K2, fe = Q2, ne2 = k2, oe2 = I2, F = T4, S % 16 === 15)
            for (v6 = 0; v6 < 16; v6++)
              l3 = n15[v6], A4 = s5[v6], w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = n15[(v6 + 9) % 16], A4 = s5[(v6 + 9) % 16], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, U3 = n15[(v6 + 1) % 16], C2 = s5[(v6 + 1) % 16], l3 = (U3 >>> 1 | C2 << 31) ^ (U3 >>> 8 | C2 << 24) ^ U3 >>> 7, A4 = (C2 >>> 1 | U3 << 31) ^ (C2 >>> 8 | U3 << 24) ^ (C2 >>> 7 | U3 << 25), w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, U3 = n15[(v6 + 14) % 16], C2 = s5[(v6 + 14) % 16], l3 = (U3 >>> 19 | C2 << 13) ^ (C2 >>> 29 | U3 << 3) ^ U3 >>> 6, A4 = (C2 >>> 19 | U3 << 13) ^ (U3 >>> 29 | C2 << 3) ^ (C2 >>> 6 | U3 << 26), w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, n15[v6] = y2 & 65535 | p4 << 16, s5[v6] = w & 65535 | d8 << 16;
        l3 = O3, A4 = F, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[0], A4 = f3[0], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[0] = O3 = y2 & 65535 | p4 << 16, f3[0] = F = w & 65535 | d8 << 16, l3 = Y2, A4 = q, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[1], A4 = f3[1], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[1] = Y2 = y2 & 65535 | p4 << 16, f3[1] = q = w & 65535 | d8 << 16, l3 = z2, A4 = G, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[2], A4 = f3[2], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[2] = z2 = y2 & 65535 | p4 << 16, f3[2] = G = w & 65535 | d8 << 16, l3 = H, A4 = ae2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[3], A4 = f3[3], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[3] = H = y2 & 65535 | p4 << 16, f3[3] = ae2 = w & 65535 | d8 << 16, l3 = a3, A4 = ee, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[4], A4 = f3[4], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[4] = a3 = y2 & 65535 | p4 << 16, f3[4] = ee = w & 65535 | d8 << 16, l3 = J, A4 = fe, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[5], A4 = f3[5], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[5] = J = y2 & 65535 | p4 << 16, f3[5] = fe = w & 65535 | d8 << 16, l3 = V3, A4 = ne2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[6], A4 = f3[6], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[6] = V3 = y2 & 65535 | p4 << 16, f3[6] = ne2 = w & 65535 | d8 << 16, l3 = _2, A4 = oe2, w = A4 & 65535, d8 = A4 >>> 16, y2 = l3 & 65535, p4 = l3 >>> 16, l3 = t11[7], A4 = f3[7], w += A4 & 65535, d8 += A4 >>> 16, y2 += l3 & 65535, p4 += l3 >>> 16, d8 += w >>> 16, y2 += d8 >>> 16, p4 += y2 >>> 16, t11[7] = _2 = y2 & 65535 | p4 << 16, f3[7] = oe2 = w & 65535 | d8 << 16, ce += 128, e14 -= 128;
      }
      return e14;
    }
    function Oe2(t11, f3, r9) {
      var e14 = new Int32Array(8), n15 = new Int32Array(8), s5 = new Uint8Array(256), x, g2 = r9;
      for (e14[0] = 1779033703, e14[1] = 3144134277, e14[2] = 1013904242, e14[3] = 2773480762, e14[4] = 1359893119, e14[5] = 2600822924, e14[6] = 528734635, e14[7] = 1541459225, n15[0] = 4089235720, n15[1] = 2227873595, n15[2] = 4271175723, n15[3] = 1595750129, n15[4] = 2917565137, n15[5] = 725511199, n15[6] = 4215389547, n15[7] = 327033209, Yt(e14, n15, f3, r9), r9 %= 128, x = 0; x < r9; x++) s5[x] = f3[g2 - r9 + x];
      for (s5[r9] = 128, r9 = 256 - 128 * (r9 < 112 ? 1 : 0), s5[r9 - 9] = 0, re2(s5, r9 - 8, g2 / 536870912 | 0, g2 << 3), Yt(e14, n15, s5, r9), x = 0; x < 8; x++) re2(t11, 8 * x, e14[x], n15[x]);
      return 0;
    }
    function ft(t11, f3) {
      var r9 = o16(), e14 = o16(), n15 = o16(), s5 = o16(), x = o16(), g2 = o16(), b2 = o16(), B2 = o16(), m = o16();
      Ee2(r9, t11[1], t11[0]), Ee2(m, f3[1], f3[0]), Z2(r9, r9, m), be(e14, t11[0], t11[1]), be(m, f3[0], f3[1]), Z2(e14, e14, m), Z2(n15, t11[3], f3[3]), Z2(n15, n15, ie), Z2(s5, t11[2], f3[2]), be(s5, s5, s5), Ee2(x, e14, r9), Ee2(g2, s5, n15), be(b2, s5, n15), be(B2, e14, r9), Z2(t11[0], x, g2), Z2(t11[1], B2, b2), Z2(t11[2], b2, g2), Z2(t11[3], x, B2);
    }
    function Ht2(t11, f3, r9) {
      var e14;
      for (e14 = 0; e14 < 4; e14++)
        Ke(t11[e14], f3[e14], r9);
    }
    function dt(t11, f3) {
      var r9 = o16(), e14 = o16(), n15 = o16();
      Kt2(n15, f3[2]), Z2(r9, f3[0], n15), Z2(e14, f3[1], n15), ke2(t11, e14), t11[31] ^= Pt(r9) << 7;
    }
    function gt(t11, f3, r9) {
      var e14, n15;
      for (Ue2(t11[0], L2), Ue2(t11[1], M), Ue2(t11[2], M), Ue2(t11[3], L2), n15 = 255; n15 >= 0; --n15)
        e14 = r9[n15 / 8 | 0] >> (n15 & 7) & 1, Ht2(t11, f3, e14), ft(f3, t11), ft(t11, t11), Ht2(t11, f3, e14);
    }
    function nt2(t11, f3) {
      var r9 = [o16(), o16(), o16(), o16()];
      Ue2(r9[0], le), Ue2(r9[1], xe), Ue2(r9[2], M), Z2(r9[3], le, xe), gt(t11, r9, f3);
    }
    function yt(t11, f3, r9) {
      var e14 = new Uint8Array(64), n15 = [o16(), o16(), o16(), o16()], s5;
      for (r9 || h3(f3, 32), Oe2(e14, f3, 32), e14[0] &= 248, e14[31] &= 127, e14[31] |= 64, nt2(n15, e14), dt(t11, n15), s5 = 0; s5 < 32; s5++) f3[s5 + 32] = t11[s5];
      return 0;
    }
    var ot4 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function wt(t11, f3) {
      var r9, e14, n15, s5;
      for (e14 = 63; e14 >= 32; --e14) {
        for (r9 = 0, n15 = e14 - 32, s5 = e14 - 12; n15 < s5; ++n15)
          f3[n15] += r9 - 16 * f3[e14] * ot4[n15 - (e14 - 32)], r9 = Math.floor((f3[n15] + 128) / 256), f3[n15] -= r9 * 256;
        f3[n15] += r9, f3[e14] = 0;
      }
      for (r9 = 0, n15 = 0; n15 < 32; n15++)
        f3[n15] += r9 - (f3[31] >> 4) * ot4[n15], r9 = f3[n15] >> 8, f3[n15] &= 255;
      for (n15 = 0; n15 < 32; n15++) f3[n15] -= r9 * ot4[n15];
      for (e14 = 0; e14 < 32; e14++)
        f3[e14 + 1] += f3[e14] >> 8, t11[e14] = f3[e14] & 255;
    }
    function pt(t11) {
      var f3 = new Float64Array(64), r9;
      for (r9 = 0; r9 < 64; r9++) f3[r9] = t11[r9];
      for (r9 = 0; r9 < 64; r9++) t11[r9] = 0;
      wt(t11, f3);
    }
    function zt(t11, f3, r9, e14) {
      var n15 = new Uint8Array(64), s5 = new Uint8Array(64), x = new Uint8Array(64), g2, b2, B2 = new Float64Array(64), m = [o16(), o16(), o16(), o16()];
      Oe2(n15, e14, 32), n15[0] &= 248, n15[31] &= 127, n15[31] |= 64;
      var X2 = r9 + 64;
      for (g2 = 0; g2 < r9; g2++) t11[64 + g2] = f3[g2];
      for (g2 = 0; g2 < 32; g2++) t11[32 + g2] = n15[32 + g2];
      for (Oe2(x, t11.subarray(32), r9 + 32), pt(x), nt2(m, x), dt(t11, m), g2 = 32; g2 < 64; g2++) t11[g2] = e14[g2];
      for (Oe2(s5, t11, r9 + 64), pt(s5), g2 = 0; g2 < 64; g2++) B2[g2] = 0;
      for (g2 = 0; g2 < 32; g2++) B2[g2] = x[g2];
      for (g2 = 0; g2 < 32; g2++)
        for (b2 = 0; b2 < 32; b2++)
          B2[g2 + b2] += s5[g2] * n15[b2];
      return wt(t11.subarray(32), B2), X2;
    }
    function ur2(t11, f3) {
      var r9 = o16(), e14 = o16(), n15 = o16(), s5 = o16(), x = o16(), g2 = o16(), b2 = o16();
      return Ue2(t11[2], M), ut2(t11[1], f3), ge(n15, t11[1]), Z2(s5, n15, te), Ee2(n15, n15, t11[2]), be(s5, t11[2], s5), ge(x, s5), ge(g2, x), Z2(b2, g2, x), Z2(r9, b2, n15), Z2(r9, r9, s5), kt(r9, r9), Z2(r9, r9, n15), Z2(r9, r9, s5), Z2(r9, r9, s5), Z2(t11[0], r9, s5), ge(e14, t11[0]), Z2(e14, e14, s5), Nt(e14, n15) && Z2(t11[0], t11[0], se), ge(e14, t11[0]), Z2(e14, e14, s5), Nt(e14, n15) ? -1 : (Pt(t11[0]) === f3[31] >> 7 && Ee2(t11[0], L2, t11[0]), Z2(t11[3], t11[0], t11[1]), 0);
    }
    function bt(t11, f3, r9, e14) {
      var n15, s5 = new Uint8Array(32), x = new Uint8Array(64), g2 = [o16(), o16(), o16(), o16()], b2 = [o16(), o16(), o16(), o16()];
      if (r9 < 64 || ur2(b2, e14)) return -1;
      for (n15 = 0; n15 < r9; n15++) t11[n15] = f3[n15];
      for (n15 = 0; n15 < 32; n15++) t11[n15 + 32] = e14[n15];
      if (Oe2(x, t11, r9), pt(x), gt(g2, b2, x), nt2(b2, f3.subarray(32)), ft(g2, b2), dt(s5, g2), r9 -= 64, ve2(f3, 0, s5, 0)) {
        for (n15 = 0; n15 < r9; n15++) t11[n15] = 0;
        return -1;
      }
      for (n15 = 0; n15 < r9; n15++) t11[n15] = f3[n15 + 64];
      return r9;
    }
    var Et = 32, it = 24, He = 32, Qe = 16, ze = 32, at = 32, Fe = 32, Je = 32, vt = 32, Ft = it, dr2 = He, gr2 = Qe, Re2 = 64, Me = 32, De = 64, mt = 32, Ut = 64;
    i4.lowlevel = {
      crypto_core_hsalsa20: Be,
      crypto_stream_xor: ct,
      crypto_stream: Ot,
      crypto_stream_salsa20_xor: Le2,
      crypto_stream_salsa20: pe3,
      crypto_onetimeauth: xt,
      crypto_onetimeauth_verify: Mt,
      crypto_verify_16: Ce2,
      crypto_verify_32: ve2,
      crypto_secretbox: lt,
      crypto_secretbox_open: At,
      crypto_scalarmult: et,
      crypto_scalarmult_base: tt,
      crypto_box_beforenm: rt,
      crypto_box_afternm: Dt2,
      crypto_box: Ar,
      crypto_box_open: hr2,
      crypto_box_keypair: Qt2,
      crypto_hash: Oe2,
      crypto_sign: zt,
      crypto_sign_keypair: yt,
      crypto_sign_open: bt,
      crypto_secretbox_KEYBYTES: Et,
      crypto_secretbox_NONCEBYTES: it,
      crypto_secretbox_ZEROBYTES: He,
      crypto_secretbox_BOXZEROBYTES: Qe,
      crypto_scalarmult_BYTES: ze,
      crypto_scalarmult_SCALARBYTES: at,
      crypto_box_PUBLICKEYBYTES: Fe,
      crypto_box_SECRETKEYBYTES: Je,
      crypto_box_BEFORENMBYTES: vt,
      crypto_box_NONCEBYTES: Ft,
      crypto_box_ZEROBYTES: dr2,
      crypto_box_BOXZEROBYTES: gr2,
      crypto_sign_BYTES: Re2,
      crypto_sign_PUBLICKEYBYTES: Me,
      crypto_sign_SECRETKEYBYTES: De,
      crypto_sign_SEEDBYTES: mt,
      crypto_hash_BYTES: Ut,
      gf: o16,
      D: te,
      L: ot4,
      pack25519: ke2,
      unpack25519: ut2,
      M: Z2,
      A: be,
      S: ge,
      Z: Ee2,
      pow2523: kt,
      add: ft,
      set25519: Ue2,
      modL: wt,
      scalarmult: gt,
      scalarbase: nt2
    };
    function Jt(t11, f3) {
      if (t11.length !== Et) throw new Error("bad key size");
      if (f3.length !== it) throw new Error("bad nonce size");
    }
    function yr2(t11, f3) {
      if (t11.length !== Fe) throw new Error("bad public key size");
      if (f3.length !== Je) throw new Error("bad secret key size");
    }
    function de2() {
      for (var t11 = 0; t11 < arguments.length; t11++)
        if (!(arguments[t11] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Zt2(t11) {
      for (var f3 = 0; f3 < t11.length; f3++) t11[f3] = 0;
    }
    i4.randomBytes = function(t11) {
      var f3 = new Uint8Array(t11);
      return h3(f3, t11), f3;
    }, i4.secretbox = function(t11, f3, r9) {
      de2(t11, f3, r9), Jt(r9, f3);
      for (var e14 = new Uint8Array(He + t11.length), n15 = new Uint8Array(e14.length), s5 = 0; s5 < t11.length; s5++) e14[s5 + He] = t11[s5];
      return lt(n15, e14, e14.length, f3, r9), n15.subarray(Qe);
    }, i4.secretbox.open = function(t11, f3, r9) {
      de2(t11, f3, r9), Jt(r9, f3);
      for (var e14 = new Uint8Array(Qe + t11.length), n15 = new Uint8Array(e14.length), s5 = 0; s5 < t11.length; s5++) e14[s5 + Qe] = t11[s5];
      return e14.length < 32 || At(n15, e14, e14.length, f3, r9) !== 0 ? null : n15.subarray(He);
    }, i4.secretbox.keyLength = Et, i4.secretbox.nonceLength = it, i4.secretbox.overheadLength = Qe, i4.scalarMult = function(t11, f3) {
      if (de2(t11, f3), t11.length !== at) throw new Error("bad n size");
      if (f3.length !== ze) throw new Error("bad p size");
      var r9 = new Uint8Array(ze);
      return et(r9, t11, f3), r9;
    }, i4.scalarMult.base = function(t11) {
      if (de2(t11), t11.length !== at) throw new Error("bad n size");
      var f3 = new Uint8Array(ze);
      return tt(f3, t11), f3;
    }, i4.scalarMult.scalarLength = at, i4.scalarMult.groupElementLength = ze, i4.box = function(t11, f3, r9, e14) {
      var n15 = i4.box.before(r9, e14);
      return i4.secretbox(t11, f3, n15);
    }, i4.box.before = function(t11, f3) {
      de2(t11, f3), yr2(t11, f3);
      var r9 = new Uint8Array(vt);
      return rt(r9, t11, f3), r9;
    }, i4.box.after = i4.secretbox, i4.box.open = function(t11, f3, r9, e14) {
      var n15 = i4.box.before(r9, e14);
      return i4.secretbox.open(t11, f3, n15);
    }, i4.box.open.after = i4.secretbox.open, i4.box.keyPair = function() {
      var t11 = new Uint8Array(Fe), f3 = new Uint8Array(Je);
      return Qt2(t11, f3), { publicKey: t11, secretKey: f3 };
    }, i4.box.keyPair.fromSecretKey = function(t11) {
      if (de2(t11), t11.length !== Je)
        throw new Error("bad secret key size");
      var f3 = new Uint8Array(Fe);
      return tt(f3, t11), { publicKey: f3, secretKey: new Uint8Array(t11) };
    }, i4.box.publicKeyLength = Fe, i4.box.secretKeyLength = Je, i4.box.sharedKeyLength = vt, i4.box.nonceLength = Ft, i4.box.overheadLength = i4.secretbox.overheadLength, i4.sign = function(t11, f3) {
      if (de2(t11, f3), f3.length !== De)
        throw new Error("bad secret key size");
      var r9 = new Uint8Array(Re2 + t11.length);
      return zt(r9, t11, t11.length, f3), r9;
    }, i4.sign.open = function(t11, f3) {
      if (de2(t11, f3), f3.length !== Me)
        throw new Error("bad public key size");
      var r9 = new Uint8Array(t11.length), e14 = bt(r9, t11, t11.length, f3);
      if (e14 < 0) return null;
      for (var n15 = new Uint8Array(e14), s5 = 0; s5 < n15.length; s5++) n15[s5] = r9[s5];
      return n15;
    }, i4.sign.detached = function(t11, f3) {
      for (var r9 = i4.sign(t11, f3), e14 = new Uint8Array(Re2), n15 = 0; n15 < e14.length; n15++) e14[n15] = r9[n15];
      return e14;
    }, i4.sign.detached.verify = function(t11, f3, r9) {
      if (de2(t11, f3, r9), f3.length !== Re2)
        throw new Error("bad signature size");
      if (r9.length !== Me)
        throw new Error("bad public key size");
      var e14 = new Uint8Array(Re2 + t11.length), n15 = new Uint8Array(Re2 + t11.length), s5;
      for (s5 = 0; s5 < Re2; s5++) e14[s5] = f3[s5];
      for (s5 = 0; s5 < t11.length; s5++) e14[s5 + Re2] = t11[s5];
      return bt(n15, e14, e14.length, r9) >= 0;
    }, i4.sign.keyPair = function() {
      var t11 = new Uint8Array(Me), f3 = new Uint8Array(De);
      return yt(t11, f3), { publicKey: t11, secretKey: f3 };
    }, i4.sign.keyPair.fromSecretKey = function(t11) {
      if (de2(t11), t11.length !== De)
        throw new Error("bad secret key size");
      for (var f3 = new Uint8Array(Me), r9 = 0; r9 < f3.length; r9++) f3[r9] = t11[32 + r9];
      return { publicKey: f3, secretKey: new Uint8Array(t11) };
    }, i4.sign.keyPair.fromSeed = function(t11) {
      if (de2(t11), t11.length !== mt)
        throw new Error("bad seed size");
      for (var f3 = new Uint8Array(Me), r9 = new Uint8Array(De), e14 = 0; e14 < 32; e14++) r9[e14] = t11[e14];
      return yt(f3, r9, true), { publicKey: f3, secretKey: r9 };
    }, i4.sign.publicKeyLength = Me, i4.sign.secretKeyLength = De, i4.sign.seedLength = mt, i4.sign.signatureLength = Re2, i4.hash = function(t11) {
      de2(t11);
      var f3 = new Uint8Array(Ut);
      return Oe2(f3, t11, t11.length), f3;
    }, i4.hash.hashLength = Ut, i4.verify = function(t11, f3) {
      return de2(t11, f3), t11.length === 0 || f3.length === 0 || t11.length !== f3.length ? false : ye(t11, 0, f3, 0, t11.length) === 0;
    }, i4.setPRNG = function(t11) {
      h3 = t11;
    }, function() {
      var t11 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (t11 && t11.getRandomValues) {
        var f3 = 65536;
        i4.setPRNG(function(r9, e14) {
          var n15, s5 = new Uint8Array(e14);
          for (n15 = 0; n15 < e14; n15 += f3)
            t11.getRandomValues(s5.subarray(n15, n15 + Math.min(e14 - n15, f3)));
          for (n15 = 0; n15 < e14; n15++) r9[n15] = s5[n15];
          Zt2(s5);
        });
      } else typeof Hr < "u" && (t11 = Jr, t11 && t11.randomBytes && i4.setPRNG(function(r9, e14) {
        var n15, s5 = t11.randomBytes(e14);
        for (n15 = 0; n15 < e14; n15++) r9[n15] = s5[n15];
        Zt2(s5);
      }));
    }();
  })(c.exports ? c.exports : self.nacl = self.nacl || {});
})(ar2);
var Zr = ar2.exports;
var Ze = or2(Zr);
var Wr = Object.defineProperty;
var qr = (c, i4, o16) => i4 in c ? Wr(c, i4, { enumerable: true, configurable: true, writable: true, value: o16 }) : c[i4] = o16;
var Ne2 = (c, i4, o16) => qr(c, typeof i4 != "symbol" ? i4 + "" : i4, o16);
async function Gr(c, i4) {
  const o16 = c.getReader();
  let h3;
  for (; !(h3 = await o16.read()).done; )
    i4(h3.value);
}
function Xr(c) {
  let i4, o16, h3, u = false;
  return function(E2) {
    i4 === void 0 ? (i4 = E2, o16 = 0, h3 = -1) : i4 = _r2(i4, E2);
    const L2 = i4.length;
    let M = 0;
    for (; o16 < L2; ) {
      u && (i4[o16] === 10 && (M = ++o16), u = false);
      let $2 = -1;
      for (; o16 < L2 && $2 === -1; ++o16)
        switch (i4[o16]) {
          case 58:
            h3 === -1 && (h3 = o16 - M);
            break;
          case 13:
            u = true;
          case 10:
            $2 = o16;
            break;
        }
      if ($2 === -1)
        break;
      c(i4.subarray(M, $2), h3), M = o16, h3 = -1;
    }
    M === L2 ? i4 = void 0 : M !== 0 && (i4 = i4.subarray(M), o16 -= M);
  };
}
function Vr(c, i4, o16) {
  let h3 = qt();
  const u = new TextDecoder();
  return function(E2, L2) {
    if (E2.length === 0)
      o16 == null || o16(h3), h3 = qt();
    else if (L2 > 0) {
      const M = u.decode(E2.subarray(0, L2)), $2 = L2 + (E2[L2 + 1] === 32 ? 2 : 1), te = u.decode(E2.subarray($2));
      switch (M) {
        case "data":
          h3.data = h3.data ? h3.data + `
` + te : te;
          break;
        case "event":
          h3.event = te;
          break;
        case "id":
          c(h3.id = te);
          break;
        case "retry":
          const ie = parseInt(te, 10);
          isNaN(ie) || i4(h3.retry = ie);
          break;
      }
    }
  };
}
function _r2(c, i4) {
  const o16 = new Uint8Array(c.length + i4.length);
  return o16.set(c), o16.set(i4, c.length), o16;
}
function qt() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var $r = function(c, i4) {
  var o16 = {};
  for (var h3 in c) Object.prototype.hasOwnProperty.call(c, h3) && i4.indexOf(h3) < 0 && (o16[h3] = c[h3]);
  if (c != null && typeof Object.getOwnPropertySymbols == "function")
    for (var u = 0, h3 = Object.getOwnPropertySymbols(c); u < h3.length; u++)
      i4.indexOf(h3[u]) < 0 && Object.prototype.propertyIsEnumerable.call(c, h3[u]) && (o16[h3[u]] = c[h3[u]]);
  return o16;
};
var St = "text/event-stream";
var ef = 1e3;
var Gt3 = "last-event-id";
function sr2(c, i4) {
  var { signal: o16, headers: h3, onopen: u, onmessage: E2, onclose: L2, onerror: M, openWhenHidden: $2, fetch: te } = i4, ie = $r(i4, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((le, xe) => {
    const se = Object.assign({}, h3);
    se.accept || (se.accept = St);
    let re2;
    function ye() {
      re2.abort(), document.hidden || Be();
    }
    $2 || document.addEventListener("visibilitychange", ye);
    let Ce2 = ef, ve2 = 0;
    function Se2() {
      document.removeEventListener("visibilitychange", ye), window.clearTimeout(ve2), re2.abort();
    }
    o16 == null || o16.addEventListener("abort", () => {
      Se2(), le();
    });
    const Pe2 = te ?? window.fetch, me3 = u ?? tf;
    async function Be() {
      var we2;
      re2 = new AbortController();
      try {
        const Le2 = await Pe2(c, Object.assign(Object.assign({}, ie), { headers: se, signal: re2.signal }));
        await me3(Le2), await Gr(Le2.body, Xr(Vr((pe3) => {
          pe3 ? se[Gt3] = pe3 : delete se[Gt3];
        }, (pe3) => {
          Ce2 = pe3;
        }, E2))), L2 == null || L2(), Se2(), le();
      } catch (Le2) {
        if (!re2.signal.aborted)
          try {
            const pe3 = (we2 = M == null ? void 0 : M(Le2)) !== null && we2 !== void 0 ? we2 : Ce2;
            window.clearTimeout(ve2), ve2 = window.setTimeout(Be, pe3);
          } catch (pe3) {
            Se2(), xe(pe3);
          }
      }
    }
    Be();
  });
}
function tf(c) {
  const i4 = c.headers.get("content-type");
  if (!(i4 != null && i4.startsWith(St)))
    throw new Error(`Expected content-type to be ${St}, Actual: ${i4}`);
}
function rf(c, i4) {
  const o16 = Ve.encodeBase64(c);
  return i4 ? encodeURIComponent(o16) : o16;
}
function ff(c, i4) {
  return i4 && (c = decodeURIComponent(c)), Ve.decodeBase64(c);
}
function nf(c, i4 = false) {
  let o16;
  return c instanceof Uint8Array ? o16 = c : (typeof c != "string" && (c = JSON.stringify(c)), o16 = Ve.decodeUTF8(c)), rf(o16, i4);
}
function of(c, i4 = false) {
  const o16 = ff(c, i4);
  return {
    toString() {
      return Ve.encodeUTF8(o16);
    },
    toObject() {
      try {
        return JSON.parse(Ve.encodeUTF8(o16));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return o16;
    }
  };
}
var Xt2 = {
  encode: nf,
  decode: of
};
function af(c, i4) {
  const o16 = new Uint8Array(c.length + i4.length);
  return o16.set(c), o16.set(i4, c.length), o16;
}
function sf(c, i4) {
  if (i4 >= c.length)
    throw new Error("Index is out of buffer");
  const o16 = c.slice(0, i4), h3 = c.slice(i4);
  return [o16, h3];
}
function je(c) {
  let i4 = "";
  return c.forEach((o16) => {
    i4 += ("0" + (o16 & 255).toString(16)).slice(-2);
  }), i4;
}
function _e2(c) {
  if (c.length % 2 !== 0)
    throw new Error(`Cannot convert ${c} to bytesArray`);
  const i4 = new Uint8Array(c.length / 2);
  for (let o16 = 0; o16 < c.length; o16 += 2)
    i4[o16 / 2] = parseInt(c.slice(o16, o16 + 2), 16);
  return i4;
}
var Ye = class {
  constructor(i4) {
    Ne2(this, "nonceLength", 24), Ne2(this, "keyPair"), Ne2(this, "sessionId"), this.keyPair = i4 ? this.createKeypairFromString(i4) : this.createKeypair(), this.sessionId = je(this.keyPair.publicKey);
  }
  createKeypair() {
    return Ze.box.keyPair();
  }
  createKeypairFromString(i4) {
    return {
      publicKey: _e2(i4.publicKey),
      secretKey: _e2(i4.secretKey)
    };
  }
  createNonce() {
    return Ze.randomBytes(this.nonceLength);
  }
  encrypt(i4, o16) {
    const h3 = new TextEncoder().encode(i4), u = this.createNonce(), E2 = Ze.box(h3, u, o16, this.keyPair.secretKey);
    return af(u, E2);
  }
  decrypt(i4, o16) {
    const [h3, u] = sf(i4, this.nonceLength), E2 = Ze.box.open(
      u,
      h3,
      o16,
      this.keyPair.secretKey
    );
    if (!E2)
      throw new Error(
        `Decryption error: 
 message: ${i4.toString()} 
 sender pubkey: ${o16.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`
      );
    return new TextDecoder().decode(E2);
  }
  stringifyKeypair() {
    return {
      publicKey: je(this.keyPair.publicKey),
      secretKey: je(this.keyPair.secretKey)
    };
  }
  static async generateKeyPairByString(i4) {
    const o16 = new TextEncoder().encode(i4), h3 = await crypto.subtle.digest("SHA-256", o16), u = new Uint8Array(h3), E2 = Ze.box.keyPair.fromSecretKey(u.slice(0, 32));
    return {
      publicKey: je(E2.publicKey),
      secretKey: je(E2.secretKey)
    };
  }
  static isSameKeypair(i4, o16) {
    return !i4 || !o16 ? false : i4.publicKey === o16.publicKey && i4.secretKey === o16.secretKey;
  }
};
var cr2 = "https://bridge.mz.xyz";
var Vt2 = {
  CONNECT: "[MizuWallet SSE Connect]"
};
var Bt = ((c) => (c[c.SUCCESS = 0] = "SUCCESS", c[c.ERROR = 1] = "ERROR", c))(Bt || {});
var Xe = ((c) => (c[c.MIZU = 0] = "MIZU", c[c.MIZU_PC = 1] = "MIZU_PC", c[c.THIRD_PARTY = 2] = "THIRD_PARTY", c))(Xe || {});
var Te2 = ((c) => (c[c.START = 0] = "START", c[c.DATA = 1] = "DATA", c[c.FULFILLED = 2] = "FULFILLED", c[c.REJECT = 3] = "REJECT", c[c.CANCEL = 4] = "CANCEL", c[c.CLOSE = 5] = "CLOSE", c))(Te2 || {});
var _t = async (c) => {
  const i4 = new URLSearchParams(), o16 = new Ye(c.keypair), h3 = new AbortController();
  i4.append("client_id", o16.sessionId.toString()), i4.append("to", c.to.toString()), i4.append("ttl", c.ttl.toString());
  const u = JSON.stringify(c.content), E2 = _e2(c.to.toString()), L2 = o16.encrypt(u, E2), M = je(L2);
  return await sr2(`${cr2}/bridge/message?${i4.toString()}`, {
    method: "POST",
    openWhenHidden: false,
    headers: {
      Accept: "text/event-stream"
    },
    onopen($2) {
      var te, ie, le, xe;
      return $2.ok && $2.status === 200 ? ((te = console.group) == null || te.call(console, "[SessionPost]"), console.log(`The connection from ${o16.sessionId} to ${c.to}`), (ie = console.groupEnd) == null || ie.call(console), Promise.resolve()) : ((le = console.group) == null || le.call(console, "[SessionPost]"), console.log(`The connection from ${o16.sessionId} to ${c.to}`), console.log("Client side error ", $2), (xe = console.groupEnd) == null || xe.call(console), Promise.reject());
    },
    onmessage() {
    },
    onclose() {
      var $2, te;
      ($2 = console.group) == null || $2.call(console, "[SessionPost]"), console.log(`The connection from ${o16.sessionId} to ${c.to} is closed by the server`), (te = console.groupEnd) == null || te.call(console), console.log("abort"), h3 == null || h3.abort();
    },
    onerror($2) {
      var te, ie;
      (te = console.group) == null || te.call(console, "[SessionPost]"), console.log(`The connection from ${o16.sessionId} to ${c.to}`), console.log("There was an error from server", $2.message || $2), (ie = console.groupEnd) == null || ie.call(console), h3 == null || h3.abort();
    },
    body: M,
    signal: h3.signal
  }), {
    ctrl: h3
  };
};
var $t = async (c) => {
  const i4 = new URLSearchParams(), o16 = c.keypair.publicKey.toString();
  i4.append("client_id", o16);
  const h3 = new AbortController();
  return sr2(`${cr2}/bridge/events?${i4.toString()}`, {
    openWhenHidden: false,
    onopen(u) {
      return u.status === 200 ? (console.info(`${Vt2.CONNECT} Opened`), Promise.resolve()) : (console.error(`${Vt2.CONNECT} Failed to open`), Promise.reject());
    },
    onmessage(u) {
      var E2, L2;
      try {
        if (u.data && u.data.startsWith("{")) {
          const M = JSON.parse(u.data);
          if (M.message) {
            const $2 = new Ye({
              ...c.keypair
            }), te = M.message, ie = _e2(te), le = $2.decrypt(
              ie,
              _e2(M.from.toString())
            ), xe = JSON.parse(le);
            (c.nonce && xe.nonce == c.nonce || !c.nonce) && ((E2 = c.callback) == null || E2.call(c, {
              status: 0,
              message: xe
            }));
          }
        }
      } catch (M) {
        console.error(M), (L2 = c.callback) == null || L2.call(c, {
          status: 1,
          error: M
        });
      }
    },
    onclose() {
      var u, E2;
      (u = console.group) == null || u.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${o16}`), console.log("Close abort"), (E2 = console.groupEnd) == null || E2.call(console), h3 == null || h3.abort();
    },
    onerror(u) {
      var E2, L2;
      (E2 = console.group) == null || E2.call(console, "[SessionListenerLong]"), console.log(`Listening channel: ${o16}`), console.log("There was an error from server", u.message || u), console.log("Error abort"), (L2 = console.groupEnd) == null || L2.call(console), h3 == null || h3.abort();
    },
    signal: h3.signal
  }), {
    ctrl: h3
  };
};
var er2 = class {
  constructor(i4) {
    Ne2(this, "from", ""), Ne2(this, "nonce", ""), Ne2(this, "body"), Ne2(this, "type", ""), Object.assign(this, i4), this.body = i4.body;
  }
};
var We = typeof window < "u" && !!(window != null && window.TelegramWebviewProxy);
var tr2;
var rr2;
typeof window < "u" && ((rr2 = (tr2 = window == null ? void 0 : window.Telegram) == null ? void 0 : tr2.WebApp) != null && rr2.openTelegramLink);
var cf = typeof window < "u" && (window == null ? void 0 : window.parent) != null && window != (window == null ? void 0 : window.parent);
function xf(c, i4, o16) {
  if (i4 || (i4 = function() {
  }), o16 === void 0 && (o16 = ""), console.log("[Telegram.WebView] > postEvent", c, o16), (window == null ? void 0 : window.TelegramWebviewProxy) !== void 0)
    window == null || window.TelegramWebviewProxy.postEvent(c, JSON.stringify(o16)), i4();
  else if (cf)
    try {
      var h3 = "https://web.telegram.org";
      h3 = "*", window == null || window.parent.postMessage(
        JSON.stringify({ eventType: c, eventData: o16 }),
        h3
      ), i4();
    } catch (u) {
      i4(u);
    }
  else
    i4({ notAvailable: true });
}
var lf = function(c) {
  var h3, u, E2, L2;
  if (typeof window < "u" && ((u = (h3 = window == null ? void 0 : window.Telegram) == null ? void 0 : h3.WebApp) != null && u.openTelegramLink)) {
    (L2 = (E2 = window == null ? void 0 : window.Telegram) == null ? void 0 : E2.WebApp) == null || L2.openTelegramLink(c);
    return;
  }
  let i4 = document.createElement("A");
  if (i4.href = c, i4.protocol != "http:" && i4.protocol != "https:")
    throw console.error("[Telegram.WebApp] Url protocol is not supported", c), Error("WebAppTgUrlInvalid");
  if (i4.hostname != "t.me")
    throw console.error("[Telegram.WebApp] Url host is not supported", c), Error("WebAppTgUrlInvalid");
  var o16 = i4.pathname + i4.search;
  xf("web_app_open_tg_link", false, { path_full: o16 });
};
var It = (c) => {
  var i4, o16, h3;
  return ((h3 = (o16 = (i4 = c == null ? void 0 : c.response) == null ? void 0 : i4.errors) == null ? void 0 : o16[0]) == null ? void 0 : h3.message) || c.message || c;
};
var Lt2 = class _Lt {
  static buildAction(i4) {
    return `${i4.prefix}${i4.action}_${i4.params.map((o16) => _Lt.actionParamsEncode(o16)).join("_")}`;
  }
  static actionParamsEncode(i4) {
    return encodeURIComponent(i4).replace(/\./g, "%2E").replace(/%/g, "--");
  }
  static actionParamsDecode(i4) {
    return decodeURIComponent(i4.replace(/--/g, "%"));
  }
};
var Ct2 = "mizuwallet-address";
var xr2 = class {
  constructor() {
    W3(this, "manifestURL", "");
    W3(this, "miniAppURL", "");
    W3(this, "origin", "");
    W3(this, "mizuClient", null);
    W3(this, "network", "");
  }
  async startWebChannel(i4) {
    var te;
    const o16 = new Ye(), h3 = Date.now().toString(), u = await Ye.generateKeyPairByString(
      `${i4.address || ""}+${h3}`
    ), E2 = Xt2.encode(u, true), L2 = new URLSearchParams();
    L2.append("network", this.network), L2.append("sessionId", o16.sessionId), L2.append("nonce", h3.toString()), L2.append("k", E2), i4.redirectURL && L2.append("redirect_url", i4.redirectURL), document.querySelector(".mizu-wallet-frame") && ((te = document.querySelector(".mizu-wallet-frame")) == null || te.remove());
    const M = document.createElement("iframe");
    M.setAttribute("class", "mizu-wallet-frame"), M.setAttribute("src", `${this.origin}/walletv2/${i4.url}?${L2.toString()}`), document.body.appendChild(M);
    const { ctrl: $2 } = await _t({
      to: u.publicKey,
      ttl: 300,
      content: new er2({
        from: Xe.THIRD_PARTY,
        type: Te2.DATA,
        // put all data here
        body: {
          manifestURL: this.manifestURL,
          address: window == null ? void 0 : window.localStorage.getItem(Ct2),
          ...i4.metadata
        },
        nonce: h3
      })
    });
    return new Promise(async (ie, le) => {
      const { ctrl: xe } = await $t({
        keypair: o16.stringifyKeypair(),
        callback: (se) => {
          var Ce2, ve2, Se2, Pe2, me3;
          const { message: re2, status: ye } = se;
          if ((re2 == null ? void 0 : re2.from) === Xe.MIZU_PC) {
            if (ye === Bt.ERROR) {
              (Ce2 = M.parentNode) == null || Ce2.removeChild(M), $2.abort(), xe.abort(), le(se.error);
              return;
            }
            if ((re2 == null ? void 0 : re2.type) == Te2.CLOSE) {
              (ve2 = M.parentNode) == null || ve2.removeChild(M), $2.abort(), xe.abort(), ie({});
              return;
            }
            if ((re2 == null ? void 0 : re2.type) == Te2.CANCEL) {
              (Se2 = M.parentNode) == null || Se2.removeChild(M), $2.abort(), xe.abort(), le("User Canceled");
              return;
            }
            if (re2.type === Te2.FULFILLED) {
              (Pe2 = M.parentNode) == null || Pe2.removeChild(M), $2.abort(), xe.abort(), i4.returnKey ? ie({
                [i4.returnKey]: (me3 = re2.body) == null ? void 0 : me3[i4.returnKey]
              }) : ie({});
              return;
            }
          }
        }
      });
    });
  }
  async startChannel(i4) {
    const o16 = window == null ? void 0 : window.localStorage.getItem(Ct2);
    if (o16 && i4.isAddressRequired || !i4.isAddressRequired) {
      const h3 = new Ye(), u = Date.now().toString(), E2 = await Ye.generateKeyPairByString(
        `${o16 || ""}+${u}`
      ), L2 = Xt2.encode(E2, true), M = Lt2.buildAction({
        prefix: "R_",
        action: i4.buildAction.actions,
        params: [h3.sessionId, u, L2]
      });
      lf(`${this.miniAppURL}?startapp=${M}`);
      const { ctrl: $2 } = await _t({
        to: E2.publicKey,
        ttl: 300,
        content: new er2({
          from: Xe.THIRD_PARTY,
          type: Te2.DATA,
          // put all data here
          body: {
            manifestURL: this.manifestURL,
            address: window == null ? void 0 : window.localStorage.getItem(Ct2),
            ...i4.metadata
          },
          nonce: u
        })
      });
      return new Promise(async (te, ie) => {
        const { ctrl: le } = await $t({
          keypair: h3.stringifyKeypair(),
          callback: (xe) => {
            var ye;
            const { message: se, status: re2 } = xe;
            if ((se == null ? void 0 : se.from) === Xe.MIZU) {
              if (re2 === Bt.ERROR) {
                $2.abort(), le.abort(), ie(xe.error);
                return;
              }
              if ((se == null ? void 0 : se.type) == Te2.CANCEL) {
                $2.abort(), le.abort(), ie("User Canceled");
                return;
              }
              if (se.type === Te2.FULFILLED) {
                $2.abort(), le.abort(), i4.returnKey ? te({
                  [i4.returnKey]: (ye = se.body) == null ? void 0 : ye[i4.returnKey]
                }) : te({});
                return;
              }
            }
          }
        });
      });
    } else
      throw new Error(`${Tt.TRANSACTION} No address found`);
  }
};
var qe2 = "mizuwallet-address";
var Ge2 = "mizuwallet-publickey";
var Af = class extends xr2 {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(o16) {
    super();
    W3(this, "manifestURL");
    W3(this, "miniAppURL");
    if (!o16.manifestURL) throw new Error("manifestURL is required");
    this.manifestURL = o16.manifestURL, this.miniAppURL = Or(o16.network);
  }
  /**
   * Connect
   *
   * Open MizuWallet MiniApp to connect
   * Try to get Address info back
   *
   *
   * @returns
   */
  async connect() {
    var h3, u, E2, L2;
    if (window != null && window.localStorage && ((h3 = window.localStorage) != null && h3.getItem(qe2)) && ((u = window.localStorage) != null && u.getItem(Ge2)))
      return {
        address: ((E2 = window.localStorage.getItem(qe2)) == null ? void 0 : E2.toString()) || "",
        publicKey: ((L2 = window.localStorage.getItem(Ge2)) == null ? void 0 : L2.toString()) || ""
      };
    const { account: o16 } = await this.startChannel({
      buildAction: {
        actions: "miniapp-connectv2"
      },
      metadata: {},
      returnKey: "account"
    });
    if (window != null && window.localStorage && (o16 != null && o16.address) && l.isValid({
      input: o16 == null ? void 0 : o16.address,
      strict: true
    }))
      return window.localStorage.setItem(qe2, o16 == null ? void 0 : o16.address), window.localStorage.setItem(Ge2, o16 == null ? void 0 : o16.publicKey), {
        address: o16 == null ? void 0 : o16.address,
        publicKey: o16 == null ? void 0 : o16.publicKey
      };
    throw new Error(`${Tt.CONNECT} Error`);
  }
  disconnect() {
    window != null && window.localStorage.getItem(qe2) && (window == null || window.localStorage.removeItem(qe2)), window != null && window.localStorage.getItem(Ge2) && (window == null || window.localStorage.removeItem(Ge2));
  }
  async signAndSubmitTransaction(o16) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-transactionv2"
      },
      metadata: {
        transaction: o16
      },
      returnKey: "hash",
      isAddressRequired: true
    });
  }
  async signTransaction(o16) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-signtransactionv2"
      },
      metadata: {
        transaction: o16.bcsToHex().toStringWithoutPrefix()
      },
      returnKey: "signature",
      isAddressRequired: true
    });
  }
  async signMessage(o16) {
    return await this.startChannel({
      buildAction: {
        actions: "miniapp-signmessagev2"
      },
      metadata: {
        args: o16
      },
      returnKey: "data",
      isAddressRequired: true
    });
  }
};
var hf = "https://mizu.io";
var uf = () => {
  const c = document.createElement("style");
  c.innerHTML = `
	  .mizu-wallet-frame {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		border: none;
		z-index: 999999999;
		inset: 0px;
    color-scheme: light;
    pointer-events: auto;
	  }
	`, document.head.appendChild(c);
};
var df = class extends xr2 {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(o16) {
    super();
    W3(this, "authCode");
    W3(this, "address");
    W3(this, "manifestURL");
    W3(this, "network");
    W3(this, "mizuClient");
    W3(this, "provider");
    W3(this, "origin");
    if (!o16.manifestURL) throw new Error("manifestURL is required");
    this.authCode = "", this.manifestURL = o16.manifestURL, this.network = o16.network, this.mizuClient = o16.mizuClient, this.origin = hf, this.address = "", uf();
  }
  async connect() {
    var h3, u, E2, L2;
    const o16 = await this.startWebChannel({
      url: "checkLogin",
      metadata: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      },
      returnKey: "account"
    });
    return o16.account ? (this.authCode = (h3 = o16.account) == null ? void 0 : h3.code, this.address = (u = o16.account) == null ? void 0 : u.address, Promise.resolve({
      address: (E2 = o16.account) == null ? void 0 : E2.address,
      publicKey: ((L2 = o16.account) == null ? void 0 : L2.publicKey) || ""
    })) : Promise.reject("User Canceled");
  }
  async disconnect() {
    var o16;
    await this.startWebChannel({
      url: "checkLogin",
      redirectURL: "/walletv2/logout",
      metadata: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      },
      returnKey: ""
    }), await ((o16 = this.mizuClient) == null ? void 0 : o16.logout());
  }
  async signAndSubmitTransaction(o16) {
    var h3;
    try {
      const u = await ((h3 = this.mizuClient) == null ? void 0 : h3.createOrderWithCode({
        code: this.authCode,
        payload: o16
      }));
      if (!u) throw new Error("Transaction creation failed");
      return await this.startWebChannel({
        url: "checkLogin",
        redirectURL: "/walletv2/transaction",
        metadata: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          orderId: u,
          transaction: o16
        },
        returnKey: "hash"
      });
    } catch (u) {
      throw console.error(u), new Error(It(u));
    }
  }
  async signTransaction(o16) {
    try {
      return {
        signature: (await this.startWebChannel({
          url: "checkLogin",
          redirectURL: "/walletv2/sign_transaction",
          metadata: {
            manifestURL: this.manifestURL,
            network: this.network,
            appId: this.mizuClient.appId,
            transaction: o16.bcsToHex().toStringWithoutPrefix()
          },
          returnKey: "signature"
        })).signature
      };
    } catch (h3) {
      throw console.error(h3), new Error(It(h3));
    }
  }
  async signMessage(o16) {
    try {
      return {
        data: {
          ...(await this.startWebChannel({
            url: "checkLogin",
            redirectURL: "/walletv2/sign_message",
            metadata: {
              manifestURL: this.manifestURL,
              network: this.network,
              appId: this.mizuClient.appId,
              messageInfo: {
                ...o16
              }
            },
            returnKey: "message"
          })).message
        }
      };
    } catch (h3) {
      throw console.error(h3), new Error(It(h3));
    }
  }
};
var bf = class {
  constructor(i4) {
    W3(this, "url", kr);
    W3(this, "version", "1.0.0");
    W3(this, "name", Kr);
    W3(this, "icon", Qr);
    W3(this, "chains", Br);
    W3(this, "accounts", []);
    W3(this, "provider");
    W3(this, "mizuClient");
    W3(this, "telegramMiniAppHelper");
    W3(this, "websiteHelper");
    W3(this, "accountInfo");
    W3(this, "account", async () => this.accountInfo || {
      address: "",
      publicKey: ""
    });
    W3(this, "connect", async () => {
      var i5;
      try {
        if (We)
          if (this.telegramMiniAppHelper)
            this.accountInfo = await this.telegramMiniAppHelper.connect();
          else
            throw new Error(`${Tt.CONNECT} Please pass a valid manifestURL`);
        else
          this.accountInfo = await ((i5 = this.websiteHelper) == null ? void 0 : i5.connect());
        return {
          args: {
            ...this.accountInfo
          },
          status: Ie2.APPROVED
        };
      } catch (o16) {
        return console.error(o16), {
          status: Ie2.REJECTED
        };
      }
    });
    W3(this, "network", async () => ({
      name: this.provider.network,
      chainId: this.provider.network === "mainnet" ? 1 : 2
    }));
    W3(this, "disconnect", async () => {
      var i5, o16;
      try {
        We ? await ((i5 = this.telegramMiniAppHelper) == null ? void 0 : i5.disconnect()) : await ((o16 = this.websiteHelper) == null ? void 0 : o16.disconnect());
      } catch (h3) {
        throw h3;
      }
    });
    W3(this, "signTransaction", async (i5, o16) => {
      var h3, u;
      try {
        console.log(o16);
        let E2 = {};
        if (We ? E2 = await ((h3 = this.telegramMiniAppHelper) == null ? void 0 : h3.signTransaction(i5)) : E2 = await ((u = this.websiteHelper) == null ? void 0 : u.signTransaction(i5)), E2.signature) {
          const L2 = new a2(import_buffer.Buffer.from(E2.signature, "hex"));
          return {
            args: V.deserialize(L2),
            status: Ie2.APPROVED
          };
        } else
          return {
            status: Ie2.REJECTED
          };
      } catch (E2) {
        throw E2.message || E2 ? new Error(E2.message || E2) : new Rt(st2.InternalError);
      }
    });
    W3(this, "signAndSubmitTransaction", async (i5) => {
      var o16, h3;
      try {
        let u = {};
        return We ? u = await ((o16 = this.telegramMiniAppHelper) == null ? void 0 : o16.signAndSubmitTransaction(i5.payload)) : u = await ((h3 = this.websiteHelper) == null ? void 0 : h3.signAndSubmitTransaction(i5.payload)), u != null && u.hash ? {
          args: u,
          status: Ie2.APPROVED
        } : {
          status: Ie2.REJECTED
        };
      } catch (u) {
        throw u.message || u ? new Error(u.message || u) : new Rt(st2.InternalError);
      }
    });
    W3(this, "signMessage", async (i5) => {
      var o16, h3;
      try {
        const { message: u, nonce: E2, ...L2 } = i5;
        let M = {};
        return We ? M = await ((o16 = this.telegramMiniAppHelper) == null ? void 0 : o16.signMessage({
          message: u,
          nonce: E2
        })) : M = await ((h3 = this.websiteHelper) == null ? void 0 : h3.signMessage({
          message: u,
          nonce: E2
        })), M != null && M.data ? {
          args: {
            ...M == null ? void 0 : M.data,
            ...L2
          },
          status: Ie2.APPROVED
        } : {
          status: Ie2.REJECTED
        };
      } catch (u) {
        throw u.message || u ? new Error(u.message || u) : new Rt(st2.InternalError);
      }
    });
    W3(this, "onAccountChange", async () => Promise.resolve());
    W3(this, "onNetworkChange", async () => Promise.resolve());
    if (!i4.network) throw new Error("MizuWallet: network is required");
    if (this.mizuClient = new Nf({
      appId: i4.appId || Pr(i4.network),
      network: i4.network
    }), this.provider = {
      network: i4.network,
      address: ""
    }, i4.manifestURL.indexOf("_") > -1)
      throw new Error('manifestURL can not contain underscore: "_"');
    i4 != null && i4.manifestURL && (this.telegramMiniAppHelper = new Af({
      manifestURL: i4 == null ? void 0 : i4.manifestURL,
      network: i4.network
    })), this.websiteHelper = new df({
      manifestURL: i4.manifestURL,
      network: i4.network,
      mizuClient: this.mizuClient
    });
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.1.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
};

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter32 = __toESM(require_eventemitter3(), 1);
var import_buffer2 = __toESM(require_buffer(), 1);
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);
var WALLET_ADAPTER_CORE_VERSION = "4.25.0";
function getSDKWallets(dappConfig) {
  const sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(
      new AptosConnectGoogleWallet({
        network: dappConfig == null ? void 0 : dappConfig.network,
        dappId: dappConfig == null ? void 0 : dappConfig.aptosConnectDappId,
        ...dappConfig == null ? void 0 : dappConfig.aptosConnect
      }),
      new AptosConnectAppleWallet({
        network: dappConfig == null ? void 0 : dappConfig.network,
        dappId: dappConfig == null ? void 0 : dappConfig.aptosConnectDappId,
        ...dappConfig == null ? void 0 : dappConfig.aptosConnect
      })
    );
    if ((dappConfig == null ? void 0 : dappConfig.mizuwallet) && (dappConfig == null ? void 0 : dappConfig.network) && [e.MAINNET, e.TESTNET].includes(dappConfig.network)) {
      sdkWallets.push(
        new bf({
          network: dappConfig.network,
          manifestURL: dappConfig.mizuwallet.manifestURL,
          appId: dappConfig.mizuwallet.appId
        })
      );
    }
  }
  if ((dappConfig == null ? void 0 : dappConfig.network) === e.MAINNET) {
    sdkWallets.push(new h2());
  } else {
    sdkWallets.push(new W2());
  }
  return sdkWallets;
}
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName2 = ((NetworkName22) => {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
})(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
var WalletChangeNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletChangeNetworkError";
  }
};
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    case "local":
      return e.LOCAL;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
function convertV2TransactionPayloadToV1BCSPayload(payload) {
  const deserializer = new bcs_exports.Deserializer(payload.bcsToBytes());
  return aptos_types_exports.TransactionPayload.deserialize(deserializer);
}
function convertV2PayloadToV1JSONPayload(payload) {
  var _a, _b;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  } else if ("multisigAddress" in payload) {
    const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
      (typeTag) => {
        if (typeTag instanceof U) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "multisig_payload",
      multisig_address: payload.multisigAddress.toString(),
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  } else {
    const stringTypeTags = (_b = payload.typeArguments) == null ? void 0 : _b.map(
      (typeTag) => {
        if (typeTag instanceof U) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "entry_function_payload",
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  }
}
function convertPayloadInputV1ToV2(inputV1) {
  if ("function" in inputV1) {
    const inputV2 = {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
    return inputV2;
  }
  throw new Error("Payload type not supported");
}
async function generateTransactionPayloadFromV1Input(aptosConfig, inputV1) {
  if ("function" in inputV1) {
    const inputV2 = convertPayloadInputV1ToV2(inputV1);
    return Wn({ ...inputV2, aptosConfig });
  }
  throw new Error("Payload type not supported");
}
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return typeof error === "object" && "message" in error ? error.message : error;
}
var areBCSArguments = (args) => {
  if (args.length === 0)
    return false;
  return args.every(
    (arg) => arg instanceof B
  );
};
var getAptosConfig = (networkInfo, dappConfig) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  if (isAptosNetwork(networkInfo)) {
    const currentNetwork = convertNetwork(networkInfo);
    if (isAptosLiveNetwork(currentNetwork)) {
      const apiKey = dappConfig == null ? void 0 : dappConfig.aptosApiKeys;
      return new s({
        network: currentNetwork,
        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : void 0 }
      });
    }
    return new s({
      network: currentNetwork
    });
  }
  throw new Error(
    "Invalid network, custom network not supported with Aptos wallet adapter to prevent user from using an unexpected network."
  );
};
var isAptosNetwork = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return o[networkInfo.name] !== void 0;
};
var isAptosLiveNetwork = (networkInfo) => {
  return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = async () => {
  const aptos = new W();
  return await aptos.getChainId();
};
var handlePublishPackageTransaction = (transactionInput) => {
  let metadataBytes = transactionInput.data.functionArguments[0];
  if (typeof metadataBytes === "string") {
    metadataBytes = a.fromHexInput(metadataBytes).toUint8Array();
  }
  let byteCode = transactionInput.data.functionArguments[1];
  if (Array.isArray(byteCode)) {
    byteCode = byteCode.map((byte) => {
      if (typeof byte === "string") {
        return a.fromHexInput(byte).toUint8Array();
      }
      return byte;
    });
  } else {
    throw new WalletSignAndSubmitMessageError(
      "The bytecode argument must be an array."
    ).message;
  }
  return { metadataBytes, byteCode };
};
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
function partitionWallets(wallets, partitionFunction = isInstalledOrLoadable) {
  const defaultWallets = [];
  const moreWallets = [];
  for (const wallet of wallets) {
    if (partitionFunction(wallet))
      defaultWallets.push(wallet);
    else
      moreWallets.push(wallet);
  }
  return { defaultWallets, moreWallets };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed" || wallet.readyState === "Loadable";
}
function isInstallRequired(wallet) {
  const isWalletReady = isInstalledOrLoadable(wallet);
  const isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
  if (!address)
    return;
  return `${address.slice(0, 6)}...${address.slice(-5)}`;
}
function isAptosConnectWallet(wallet) {
  if (!wallet.url)
    return false;
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);
}
function getAptosConnectWallets(wallets) {
  const { defaultWallets, moreWallets } = partitionWallets(
    wallets,
    isAptosConnectWallet
  );
  return { aptosConnectWallets: defaultWallets, otherWallets: moreWallets };
}
function groupAndSortWallets(wallets, options) {
  const { aptosConnectWallets, otherWallets } = getAptosConnectWallets(wallets);
  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);
  if (options == null ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options == null ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options == null ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    aptosConnectWallets,
    availableWallets: defaultWallets,
    installableWallets: moreWallets
  };
}
var WalletCoreV1 = class extends import_eventemitter32.default {
  async connect(wallet) {
    const account = await wallet.connect();
    return account;
  }
  async resolveSignAndSubmitTransaction(payloadData, network, wallet, transactionInput, dappConfig) {
    var _a, _b, _c, _d, _e3, _f, _g, _h;
    if (areBCSArguments(payloadData.functionArguments)) {
      const aptosConfig = getAptosConfig(network, dappConfig);
      const newPayload = await Wn({
        ...payloadData,
        aptosConfig
      });
      const oldTransactionPayload2 = convertV2TransactionPayloadToV1BCSPayload(newPayload);
      return await this.signAndSubmitBCSTransaction(
        oldTransactionPayload2,
        wallet,
        {
          max_gas_amount: ((_a = transactionInput.options) == null ? void 0 : _a.maxGasAmount) ? BigInt((_b = transactionInput.options) == null ? void 0 : _b.maxGasAmount) : void 0,
          gas_unit_price: ((_c = transactionInput.options) == null ? void 0 : _c.gasUnitPrice) ? BigInt((_d = transactionInput.options) == null ? void 0 : _d.gasUnitPrice) : void 0
        }
      );
    }
    const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);
    return await this.signAndSubmitTransaction(oldTransactionPayload, wallet, {
      max_gas_amount: ((_e3 = transactionInput.options) == null ? void 0 : _e3.maxGasAmount) ? BigInt((_f = transactionInput.options) == null ? void 0 : _f.maxGasAmount) : void 0,
      gas_unit_price: ((_g = transactionInput.options) == null ? void 0 : _g.gasUnitPrice) ? BigInt((_h = transactionInput.options) == null ? void 0 : _h.gasUnitPrice) : void 0
    });
  }
  async signAndSubmitTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, wallet, options) {
    if (!("signAndSubmitBCSTransaction" in wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${wallet.name}`
      ).message;
    }
    try {
      const response = await wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet, account) {
    try {
      const response = await wallet.signMessage(message);
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      console.log("signMessageAndVerify signMessage response", response);
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n15) => Array.from({ length: 8 }).map((_2, i4) => n15 >> i4 & 1)
            );
            const index = bits.map((_2, i4) => i4).filter((i4) => bits[i4]);
            const publicKeys = account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_2, i4) => index.includes(i4)
            );
            verified = true;
            for (let i4 = 0; i4 < signature.length; i4++) {
              const isSigVerified = import_tweetnacl3.default.sign.detached.verify(
                import_buffer2.Buffer.from(fullMessage),
                import_buffer2.Buffer.from(signature[i4], "hex"),
                import_buffer2.Buffer.from(matchedPublicKeys[i4], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          account.publicKey
        );
        const signature = new HexString(
          response.signature
        );
        verified = import_tweetnacl3.default.sign.detached.verify(
          import_buffer2.Buffer.from(response.fullMessage),
          import_buffer2.Buffer.from(signature.noPrefix(), "hex"),
          import_buffer2.Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var WalletStandardCore = class {
  async connect(wallet) {
    const response = await wallet.connect();
    if (response.status === r3.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signAndSubmitTransaction(transactionInput, aptos, account, wallet, standardWallets) {
    var _a, _b, _c;
    try {
      const standardWallet = standardWallets.find(
        (standardWallet2) => wallet.name === standardWallet2.name
      );
      if (((_a = standardWallet == null ? void 0 : standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.version) !== "1.1.0") {
        const transaction2 = await aptos.transaction.build.simple({
          sender: account.address.toString(),
          data: transactionInput.data,
          options: transactionInput.options
        });
        const response2 = await wallet.signAndSubmitTransaction(
          transaction2
        );
        if (response2.status === r3.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response2.args;
      }
      const transaction = {
        gasUnitPrice: (_b = transactionInput.options) == null ? void 0 : _b.gasUnitPrice,
        maxGasAmount: (_c = transactionInput.options) == null ? void 0 : _c.maxGasAmount,
        payload: transactionInput.data
      };
      const response = await wallet.signAndSubmitTransaction(
        transaction
      );
      if (response.status === r3.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrInput, wallet, asFeePayer) {
    const response = await wallet.signTransaction(
      transactionOrInput,
      asFeePayer
    );
    if (response.status === r3.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signMessage(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      if (response.status === r3.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      const account = await wallet.account();
      if (response.status === r3.REJECTED) {
        throw new WalletConnectionError("Failed to sign a message").message;
      }
      if (account.publicKey instanceof k && account.publicKey.variant === v.Keyless) {
        return true;
      }
      let verified = false;
      if (response.args.signature instanceof _e) {
        if (!(account.publicKey instanceof Dt)) {
          throw new WalletSignMessageAndVerifyError(
            "Public key and Signature type mismatch"
          ).message;
        }
        const { fullMessage, signature } = response.args;
        const bitmap = signature.bitmap;
        if (bitmap) {
          const minKeysRequired = account.publicKey.threshold;
          if (signature.signatures.length < minKeysRequired) {
            verified = false;
          } else {
            verified = account.publicKey.verifySignature({
              message: new TextEncoder().encode(fullMessage),
              signature
            });
          }
        }
      } else {
        verified = account.publicKey.verifySignature({
          message: new TextEncoder().encode(response.args.fullMessage),
          signature: response.args.signature
        });
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var GA4 = class {
  constructor() {
    this.aptosGAID = "G-GNVVWBL3J9";
    this.injectGA(this.aptosGAID);
  }
  gtag(a3, b2, c) {
    let dataLayer = window.dataLayer || [];
    dataLayer.push(arguments);
  }
  injectGA(gaID) {
    if (typeof window === "undefined")
      return;
    if (!gaID)
      return;
    const head = document.getElementsByTagName("head")[0];
    var myScript = document.createElement("script");
    myScript.setAttribute(
      "src",
      `https://www.googletagmanager.com/gtag/js?id=${gaID}`
    );
    const that = this;
    myScript.onload = function() {
      that.gtag("js", /* @__PURE__ */ new Date());
      that.gtag("config", `${gaID}`, {
        send_page_view: false
      });
    };
    head.insertBefore(myScript, head.children[1]);
  }
};
var aptosStandardSupportedWalletList = [
  {
    name: "Nightly",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWbSURBVHgB7Z09c9NYFIaPlFSpUqQNK6rQhbSkWJghLZP9BesxfwAqytg1xe7+AY+3go5ACzObBkpwSqrVQkuRCiqkva8UZW1je22wpHPveZ8ZRU6wwwznueee+6FLJCuSdzrb7nZTNjaOJc9/ctdNiaJESPPkeeq+phLH5/L162k0HJ7JikTLvtEFPnFBf+D+0l/dt9tCNJK6xnjmZOg7GdJlPvC/AhQtPo5P3MsHQvwhiobLiLBQABf82y74z4Qt3ldSybKHToLTeW+I5/1B3u2euOD/JQy+zyRowEUs5zAzA1x+oCckJHrRYNCf/uE3AjD4QfONBBMC5PfvY2j3TEi4ZNmd8eHilQDFMK/s8xMhIXPhJLjuJLjAN/8VgRsbPWHwLbAtm5tXRWGRAS5b/99C7FBmgbTMAGXrJ5aIomJir8wA3S5afyLEEkUtEBezfQy+RYpFvdilgmMhNnGxRw2wL8QqScy1fMNE0T4yQCLEKkksxDQUwDj2BNjbK69pdndn/zxwNsUCCOyNGyJ374psbYkMBiLv30++59o1kW5X5NMnkdFI5OXL8nXghCsAAn10NL/Fz2NnpxQFFyR5/bq8BypDWAIg6AcHIoeH60nn4/K8e1deECIgwhAAQULQEXxIUAf43bju3ZvMDJ7jrwDT/XpToIvABeECqBf8EuB7+/W6CKBe0C/Auvv1uvC0XtArQBP9el14VC/oEqCtfr0uPKgX2hdAW79eF0rrhfYFQPCRKi1RyY4ZyZYF4GKQcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcShAm3z+LG1DAdqEAhjn40dpGwrQFtgIwgxgGAWtH1CAtsC2cQVQgLZQsk2cArSBoqeHKEAbKHpiiAI0DVq+kv4fUICmQetXMPyroABNgtb/5o1oggI0icJzBChAUyDwr16JNihAUzx+LBqhAE3w5InaU0MoQN08f64y9VdQgDrBkO/FC9EMBagLBB/P/yvHxlGxTYPh3tOn4gMUYN2g4FPc509DAdYFqvxZh1ArhwKsg6rSVzTHvywU4EeoqnyPTxKnAKuCVo4iD4s6ARwhTwGWoTrk8e3bIE4IH4cCVCDI1U6dL1/K73Eh4B727ctCASoQ6MBa9zJwJtA4FMA4FMA4FMA4FMA4FMA4FMA4FMA47Qtg4P/n1Uz7AgQ8zeoD7Qug5KQMq+joApgFWkNHEWhwEUYLFMA4OgRQdGCCNXQIUG28II2jZyKIWaAV9Aig7OgUK+gRAMH36ImaUNC1FoDt1swCjaJLAAQfT9mQxtC3GohugCOCxtC5HIyHLNkVNIJOATAv4Mnz9b6jd0MIhoWsB2pH944gPHmLkQGpDf1bwtAVUILa8GNPICRgd1AL/mwKRXfA0cHa8WtXMArDfp8bSdeIf9vCEfxHj8psQBF+GH/PB0A2wIzhrVsih4ciOztCVsfvAyKQAVAbYPr44EDk6Ehkd1fI8oRxQggKQ2QEXMgEe3ulELhvbQmZT3hHxFRn+1Tn/UAAZAWIUXUTHz4IKQn/jCBkB6Pn/ywDHw41DgUwDgRIhVgljSWKzoXYJM+dAFmWCrHKeewsOBViExd71AAjd10IsUYaDYdnsfty4Uz4U4g1zvClHAbm+e9CbJFlfdwKAVwWSJ0EfwixwrCIuYxPBOV5T1gLWCCtWj+4EqCoBbLsFyFhk2UPq9YPJqaCURW6W19IqPRdjCeG/dGsd+Xdbs/dToSERD8aDHrTP4zmvZsSBMXM4INo0afyTudY4vg39zIR4iNFXXfZtc9k4XJw0V9k2R1OFHkIhvVZdn1R8MHCDDDx+zqdxK0c9tz1szAjaKWc1XUTe+OV/iKWFmAcJ8NtJ8Kxe7kvkCGKEiHN45Zz3b/9yN3/uVzUGxXD+RX4F56985hsqA6SAAAAAElFTkSuQmCC",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://petra.app/explore?link="
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var WalletCore = class extends import_eventemitter3.default {
  constructor(plugins, optInWallets, dappConfig, disableTelemetry) {
    super();
    this._wallets = [];
    this._optInWallets = [];
    this._standard_wallets = [];
    this._all_wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this.walletCoreV1 = new WalletCoreV1();
    this.walletStandardCore = new WalletStandardCore();
    this._connecting = false;
    this._connected = false;
    this.ga4 = null;
    this._disableTelemetry = false;
    this.standardizeStandardWalletToPluginWalletType = (standardWallet) => {
      var _a, _b, _c, _d;
      let standardWalletConvertedToWallet = {
        name: standardWallet.name,
        url: standardWallet.url,
        icon: standardWallet.icon,
        provider: standardWallet,
        connect: standardWallet.features["aptos:connect"].connect,
        disconnect: standardWallet.features["aptos:disconnect"].disconnect,
        network: standardWallet.features["aptos:network"].network,
        account: standardWallet.features["aptos:account"].account,
        signAndSubmitTransaction: (_a = standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.signAndSubmitTransaction,
        signMessage: standardWallet.features["aptos:signMessage"].signMessage,
        onAccountChange: standardWallet.features["aptos:onAccountChange"].onAccountChange,
        onNetworkChange: standardWallet.features["aptos:onNetworkChange"].onNetworkChange,
        signTransaction: standardWallet.features["aptos:signTransaction"].signTransaction,
        openInMobileApp: (_b = standardWallet.features["aptos:openInMobileApp"]) == null ? void 0 : _b.openInMobileApp,
        changeNetwork: (_c = standardWallet.features["aptos:changeNetwork"]) == null ? void 0 : _c.changeNetwork,
        readyState: "Installed",
        isAIP62Standard: true,
        isSignTransactionV1_1: ((_d = standardWallet.features["aptos:signTransaction"]) == null ? void 0 : _d.version) === "1.1"
      };
      this._all_wallets = this._all_wallets.filter(
        (item) => item.name !== standardWalletConvertedToWallet.name
      );
      this._all_wallets.push(standardWalletConvertedToWallet);
      this.emit("standardWalletsAdded", standardWalletConvertedToWallet);
    };
    this._wallets = plugins;
    this._optInWallets = optInWallets;
    this._dappConfig = dappConfig;
    this._disableTelemetry = disableTelemetry;
    this._sdkWallets = getSDKWallets(this._dappConfig);
    if (!this._disableTelemetry) {
      this.ga4 = new GA4();
    }
    this.fetchExtensionAIP62AptosWallets();
    this.fetchSDKAIP62AptosWallets();
    this.scopePollingDetectionStrategy();
    this.appendNotDetectedStandardSupportedWallets();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      const existingStandardPontemWallet = this._standard_wallets.find(
        (wallet2) => wallet2.name == "Pontem Wallet"
      );
      if (wallet.name === "Pontem" && existingStandardPontemWallet) {
        return;
      }
      const existingWalletIndex = this._standard_wallets.findIndex(
        (standardWallet) => standardWallet.name == wallet.name
      );
      if (existingWalletIndex !== -1)
        return;
      this._all_wallets.push(wallet);
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" : "NotDetected";
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed";
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  fetchExtensionAIP62AptosWallets() {
    let { aptosWallets, on } = d();
    this.setExtensionAIP62Wallets(aptosWallets);
    if (typeof window === "undefined")
      return;
    const that = this;
    const removeRegisterListener = on("register", function() {
      let { aptosWallets: aptosWallets2 } = d();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
    const removeUnregisterListener = on("unregister", function() {
      let { aptosWallets: aptosWallets2 } = d();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
  }
  appendNotDetectedStandardSupportedWallets() {
    aptosStandardSupportedWalletList.map((supportedWallet) => {
      const existingPluginWalletIndex = this.wallets.findIndex(
        (wallet) => wallet.name === supportedWallet.name
      );
      if (existingPluginWalletIndex !== -1)
        return;
      const existingStandardPontemWallet = this.wallets.find(
        (wallet) => wallet.name == "Pontem"
      );
      if (supportedWallet.name === "Pontem Wallet" && existingStandardPontemWallet) {
        return;
      }
      const existingStandardWallet = this._standard_wallets.find(
        (wallet) => wallet.name == supportedWallet.name
      );
      if (existingStandardWallet && this.excludeWallet(existingStandardWallet)) {
        return;
      }
      if (!existingStandardWallet) {
        this._all_wallets.push(supportedWallet);
        this.emit("standardWalletsAdded", supportedWallet);
      }
    });
  }
  fetchSDKAIP62AptosWallets() {
    this._sdkWallets.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
    });
  }
  setExtensionAIP62Wallets(extensionwWallets) {
    const wallets = extensionwWallets.filter(
      (wallet) => wallet.name !== "Dev T wallet" && wallet.name !== "T wallet"
    );
    wallets.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
      this._standard_wallets.push(wallet);
    });
  }
  excludeWallet(wallet) {
    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
      return true;
    }
    return false;
  }
  standardizeAIP62WalletType(wallet) {
    if (this.excludeWallet(wallet)) {
      return;
    }
    const isValid = i(wallet);
    if (isValid) {
      wallet.readyState = "Installed";
      this.standardizeStandardWalletToPluginWalletType(wallet);
      this._standard_wallets.push(wallet);
    }
  }
  recordEvent(eventName, additionalInfo) {
    var _a, _b, _c, _d;
    (_d = this.ga4) == null ? void 0 : _d.gtag("event", `wallet_adapter_${eventName}`, {
      wallet: (_a = this._wallet) == null ? void 0 : _a.name,
      network: (_b = this._network) == null ? void 0 : _b.name,
      network_url: (_c = this._network) == null ? void 0 : _c.url,
      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
      send_to: "G-GNVVWBL3J9",
      ...additionalInfo
    });
  }
  ensureWalletExists(wallet) {
    if (!wallet) {
      throw new WalletNotConnectedError().name;
    }
    if (!(wallet.readyState === "Loadable" || wallet.readyState === "Installed"))
      throw new WalletNotReadyError("Wallet is not set").name;
  }
  ensureAccountExists(account) {
    if (!account) {
      throw new WalletAccountError("Account is not set").name;
    }
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isAptosNetwork(this._network)) {
        this._account.ansName = void 0;
        return;
      }
      const aptosConfig = getAptosConfig(this._network, this._dappConfig);
      const aptos = new W(aptosConfig);
      const name = await aptos.ans.getPrimaryName({
        address: this._account.address.toString()
      });
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    var _a;
    if (account === null) {
      this._account = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      if ("status" in account) {
        const connectStandardAccount = account;
        if (connectStandardAccount.status === r3.REJECTED) {
          this._connecting = false;
          throw new WalletConnectionError("User has rejected the request").message;
        }
        this._account = {
          address: connectStandardAccount.args.address.toString(),
          publicKey: connectStandardAccount.args.publicKey.toString(),
          ansName: connectStandardAccount.args.ansName
        };
        return;
      } else {
        const standardAccount = account;
        this._account = {
          address: standardAccount.address.toString(),
          publicKey: standardAccount.publicKey.toString(),
          ansName: standardAccount.ansName
        };
        return;
      }
    }
    this._account = { ...account };
    return;
  }
  setNetwork(network) {
    var _a, _b, _c;
    if (network === null) {
      this._network = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      const standardizeNetwork = network;
      this.recordEvent("network_change", {
        from: (_b = this._network) == null ? void 0 : _b.name,
        to: standardizeNetwork.name
      });
      this._network = {
        name: standardizeNetwork.name.toLowerCase(),
        chainId: standardizeNetwork.chainId.toString(),
        url: standardizeNetwork.url
      };
      return;
    }
    this.recordEvent("network_change", {
      from: (_c = this._network) == null ? void 0 : _c.name,
      to: network.name
    });
    this._network = {
      ...network,
      name: network.name.toLowerCase()
    };
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._all_wallets;
  }
  get pluginWallets() {
    return this._wallets;
  }
  get standardWallets() {
    return this._standard_wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a;
    const allDetectedWallets = this._all_wallets;
    const selectedWallet = allDetectedWallets.find(
      (wallet) => wallet.name === walletName
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (((_a = this._wallet) == null ? void 0 : _a.name) === walletName)
        throw new WalletConnectionError(
          `${walletName} wallet is already connected`
        ).message;
    }
    if (isRedirectable() && selectedWallet.readyState !== "Installed") {
      if (selectedWallet.isAIP62Standard) {
        if (selectedWallet.openInMobileApp) {
          selectedWallet.openInMobileApp();
          return;
        }
        const uninstalledWallet = selectedWallet;
        if (uninstalledWallet.deeplinkProvider) {
          const url = encodeURIComponent(window.location.href);
          const location = uninstalledWallet.deeplinkProvider.concat(url);
          window.location.href = location;
          return;
        }
      }
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
      return;
    }
    if (selectedWallet.readyState !== "Installed" && selectedWallet.readyState !== "Loadable") {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      let account;
      if (selectedWallet.isAIP62Standard) {
        account = await this.walletStandardCore.connect(selectedWallet);
      } else {
        account = await this.walletCoreV1.connect(selectedWallet);
      }
      this.setAccount(account);
      const network = await selectedWallet.network();
      this.setNetwork(network);
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.recordEvent("wallet_connect");
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = generalizedErrorMessage(error);
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.disconnect();
      this.clearData();
      this.recordEvent("wallet_disconnect");
      this.emit("disconnect");
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transactionInput) {
    try {
      if ("function" in transactionInput.data) {
        if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
          throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
        }
        if (transactionInput.data.function === "0x1::code::publish_package_txn") {
          ({
            metadataBytes: transactionInput.data.functionArguments[0],
            byteCode: transactionInput.data.functionArguments[1]
          } = handlePublishPackageTransaction(transactionInput));
        }
      }
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_and_submit_transaction");
      const payloadData = transactionInput.data;
      const aptosConfig = getAptosConfig(this._network, this._dappConfig);
      const aptos = new W(aptosConfig);
      if (this._wallet.signAndSubmitTransaction) {
        if (this._wallet.isAIP62Standard) {
          const { hash, ...output } = await this.walletStandardCore.signAndSubmitTransaction(
            transactionInput,
            aptos,
            this._account,
            this._wallet,
            this._standard_wallets
          );
          return { hash, output };
        } else {
          const { hash, ...output } = await this.walletCoreV1.resolveSignAndSubmitTransaction(
            payloadData,
            this._network,
            this._wallet,
            transactionInput,
            this._dappConfig
          );
          return { hash, output };
        }
      }
      const transaction = await aptos.transaction.build.simple({
        sender: this._account.address,
        data: transactionInput.data,
        options: transactionInput.options
      });
      const senderAuthenticator = await this.signTransaction(transaction);
      const response = await this.submitTransaction({
        transaction,
        senderAuthenticator
      });
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrPayload, asFeePayer, options) {
    var _a, _b, _c, _d, _e3, _f, _g;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_transaction");
      if (this._wallet.signTransaction) {
        if (this._wallet.isAIP62Standard) {
          if ("rawTransaction" in transactionOrPayload) {
            return await this.walletStandardCore.signTransaction(
              transactionOrPayload,
              this._wallet,
              asFeePayer
            );
          } else if (this._wallet.isSignTransactionV1_1) {
            const payload = convertPayloadInputV1ToV2(transactionOrPayload);
            const optionsV1 = options;
            const { authenticator } = await this.walletStandardCore.signTransaction(
              {
                payload,
                expirationTimestamp: (_a = optionsV1 == null ? void 0 : optionsV1.expireTimestamp) != null ? _a : optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
                expirationSecondsFromNow: optionsV1 == null ? void 0 : optionsV1.expirationSecondsFromNow,
                gasUnitPrice: (_b = optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) != null ? _b : optionsV1 == null ? void 0 : optionsV1.gas_unit_price,
                maxGasAmount: (_c = optionsV1 == null ? void 0 : optionsV1.maxGasAmount) != null ? _c : optionsV1 == null ? void 0 : optionsV1.max_gas_amount,
                sequenceNumber: optionsV1 == null ? void 0 : optionsV1.sequenceNumber,
                sender: (optionsV1 == null ? void 0 : optionsV1.sender) ? { address: l.from(optionsV1.sender) } : void 0
              },
              this._wallet
            );
            return authenticator;
          } else {
            const aptosConfig = getAptosConfig(this._network, this._dappConfig);
            this.ensureAccountExists(this._account);
            const sender = this._account.address;
            const payload = await generateTransactionPayloadFromV1Input(
              aptosConfig,
              transactionOrPayload
            );
            const optionsV1 = options;
            const optionsV2 = {
              accountSequenceNumber: optionsV1 == null ? void 0 : optionsV1.sequenceNumber,
              expireTimestamp: (_d = optionsV1 == null ? void 0 : optionsV1.expireTimestamp) != null ? _d : optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
              gasUnitPrice: (_e3 = optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) != null ? _e3 : optionsV1 == null ? void 0 : optionsV1.gas_unit_price,
              maxGasAmount: (_f = optionsV1 == null ? void 0 : optionsV1.maxGasAmount) != null ? _f : optionsV1 == null ? void 0 : optionsV1.max_gas_amount
            };
            const rawTransaction = await Ur({
              aptosConfig,
              payload,
              sender,
              options: optionsV2
            });
            return await this.walletStandardCore.signTransaction(
              new Gt(rawTransaction),
              this._wallet,
              false
            );
          }
        }
        if ("rawTransaction" in transactionOrPayload) {
          const accountAuthenticator = await this._wallet.signTransaction(
            transactionOrPayload,
            asFeePayer
          );
          return accountAuthenticator;
        } else {
          const response = await this.walletCoreV1.signTransaction(
            transactionOrPayload,
            this._wallet,
            {
              max_gas_amount: (options == null ? void 0 : options.maxGasAmount) ? BigInt(options == null ? void 0 : options.maxGasAmount) : void 0,
              gas_unit_price: (options == null ? void 0 : options.gasUnitPrice) ? BigInt(options == null ? void 0 : options.gasUnitPrice) : void 0
            }
          );
          if (!response) {
            throw new Error("error");
          }
          const deserializer1 = new bcs_exports.Deserializer(response);
          const deserializedSignature = aptos_types_exports.SignedTransaction.deserialize(deserializer1);
          const transactionAuthenticator = deserializedSignature.authenticator;
          const publicKey = transactionAuthenticator.public_key.value;
          const signature = transactionAuthenticator.signature.value;
          const accountAuthenticator = new me(
            new f(publicKey),
            new h(signature)
          );
          return accountAuthenticator;
        }
      }
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_g = this.wallet) == null ? void 0 : _g.name}`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_message");
      if (this._wallet.isAIP62Standard) {
        return await this.walletStandardCore.signMessage(message, this._wallet);
      }
      const response = await this._wallet.signMessage(message);
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transaction) {
    try {
      this.ensureWalletExists(this._wallet);
      const { additionalSignersAuthenticators } = transaction;
      const transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
      this.recordEvent("submit_transaction", {
        transaction_type: transactionType
      });
      if (this._wallet.submitTransaction) {
        const pendingTransaction = await this._wallet.submitTransaction(transaction);
        return pendingTransaction;
      }
      const aptosConfig = getAptosConfig(this._network, this._dappConfig);
      const aptos = new W(aptosConfig);
      if (additionalSignersAuthenticators !== void 0) {
        const multiAgentTxn = {
          ...transaction,
          additionalSignersAuthenticators
        };
        return aptos.transaction.submit.multiAgent(multiAgentTxn);
      } else {
        return aptos.transaction.submit.simple(transaction);
      }
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onAccountChange(
        async (data) => {
          this.setAccount(data);
          await this.setAnsName();
          this.recordEvent("account_change");
          this.emit("accountChange", this._account);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onNetworkChange(
        async (data) => {
          this.setNetwork(data);
          await this.setAnsName();
          this.emit("networkChange", this._network);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async changeNetwork(network) {
    var _a;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("change_network_request", {
        from: (_a = this._network) == null ? void 0 : _a.name,
        to: network
      });
      const chainId = network === e.DEVNET ? await fetchDevnetChainId() : r[network];
      if (this._wallet.changeNetwork) {
        const networkInfo = {
          name: network,
          chainId
        };
        const response = await this._wallet.changeNetwork(networkInfo);
        if (response.status === r3.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response.args;
      }
      throw new WalletChangeNetworkError(
        `${this._wallet.name} does not support changing network request`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletChangeNetworkError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_message_and_verify");
      if (this._wallet.isAIP62Standard) {
        return this.walletStandardCore.signMessageAndVerify(
          message,
          this._wallet
        );
      }
      return await this.walletCoreV1.signMessageAndVerify(
        message,
        this._wallet,
        this._account
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  plugins,
  optInWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const [{ connected, account, network, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets, setWallets] = (0, import_react.useState)(plugins != null ? plugins : []);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      plugins != null ? plugins : [],
      optInWallets != null ? optInWallets : [],
      dappConfig,
      disableTelemetry
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a;
    setWallets((_a = walletCore == null ? void 0 : walletCore.wallets) != null ? _a : []);
  }, [walletCore]);
  const connect = async (walletName) => {
    try {
      setIsLoading(true);
      await (walletCore == null ? void 0 : walletCore.connect(walletName));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  };
  const disconnect = async () => {
    try {
      await (walletCore == null ? void 0 : walletCore.disconnect());
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signTransaction = async (transaction, asFeePayer, options) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signTransaction(
        transaction,
        asFeePayer,
        options
      ));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessage = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessage(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessageAndVerify = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessageAndVerify(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const submitTransaction = async (transaction) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.submitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signAndSubmitTransaction = async (transaction) => {
    try {
      return await (walletCore == null ? void 0 : walletCore.signAndSubmitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const changeNetwork = async (network2) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.changeNetwork(network2));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  (0, import_react.useEffect)(() => {
    if (autoConnect) {
      if (localStorage.getItem("AptosWalletName") && !connected) {
        connect(localStorage.getItem("AptosWalletName"));
      } else {
        setIsLoading(false);
      }
    }
  }, [autoConnect, wallets]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleConnect = () => {
    setState2((state) => {
      return {
        ...state,
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      };
    });
  };
  const handleDisconnect = () => {
    if (!connected)
      return;
    setState2((state) => {
      return {
        ...state,
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      };
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        account: (walletCore == null ? void 0 : walletCore.account) || null
      };
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        network: (walletCore == null ? void 0 : walletCore.network) || null
      };
    });
  }, [connected]);
  const handleReadyStateChange = (updatedWallet) => {
    const updatedWallets = wallets == null ? void 0 : wallets.map((wallet2) => {
      if (wallet2.name === updatedWallet.name) {
        return { ...wallet2, readyState: updatedWallet.readyState };
      }
      return wallet2;
    });
    setWallets(updatedWallets);
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets2) => [...wallets2, standardWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("readyStateChange", handleReadyStateChange);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("readyStateChange", handleReadyStateChange);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
    };
  }, [wallets, account]);
  return (0, import_jsx_runtime.jsx)(WalletContext.Provider, {
    value: {
      connect,
      account,
      network,
      connected,
      disconnect,
      wallet,
      wallets,
      signAndSubmitTransaction,
      signTransaction,
      signMessage,
      signMessageAndVerify,
      isLoading,
      submitTransaction,
      changeNetwork
    },
    children
  });
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime2.jsx)("svg", {
      ref,
      width: "102",
      height: "132",
      viewBox: "0 0 102 132",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime2.jsxs)("g", {
        stroke: "currentColor",
        strokeMiterlimit: "10",
        children: [
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z"
          })
        ]
      })
    });
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsxs)("svg", {
      ref,
      width: "128",
      height: "102",
      viewBox: "0 0 128 102",
      fill: "none",
      ...props,
      children: [
        (0, import_jsx_runtime3.jsx)("path", {
          fill: "currentColor",
          d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M9.86 23.69V5.72h107.97v18.04H84.65"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
        })
      ]
    });
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsx)("svg", {
      ref,
      width: "142",
      height: "108",
      viewBox: "0 0 142 108",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime4.jsxs)("g", {
        stroke: "currentColor",
        strokeLinejoin: "round",
        children: [
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m105.44 30.8.11 9-.1-9Z"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z"
          })
        ]
      })
    });
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const { children: defaultChildren, ...resolvedProps } = typeof props === "function" ? props(displayName) : props != null ? props : {};
    const resolvedChildren = asChild && (0, import_react7.isValidElement)(children) && !children.props.children ? (0, import_react7.cloneElement)(children, {}, defaultChildren) : children != null ? children : defaultChildren;
    return (0, import_jsx_runtime5.jsx)(Component, {
      ref,
      className,
      ...resolvedProps,
      children: resolvedChildren
    });
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosfoundation.org/ecosystem/projects/all";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Aptos Connect is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, {
        children: [
          "Aptos Connect lets you take one account across any application built on Aptos.",
          " ",
          (0, import_jsx_runtime6.jsx)("a", {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }),
          "."
        ]
      })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_2, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i4) => ({
      ...screen,
      screenIndex: i4,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime6.jsx)(AboutAptosConnectContext.Provider, {
    value: { screenIndex, setScreenIndex },
    children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen)
  });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var SmallAptosLogo = (0, import_react9.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime7.jsx)("svg", {
    ref,
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none",
    ...props,
    children: (0, import_jsx_runtime7.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
      fill: "currentColor"
    })
  });
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root2 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react8.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime8.jsxs)("div", {
    ref,
    className,
    children: [
      (0, import_jsx_runtime8.jsx)("span", {
        children: "Powered by"
      }),
      (0, import_jsx_runtime8.jsx)(SmallAptosLogo, {}),
      (0, import_jsx_runtime8.jsx)("span", {
        children: "Aptos Labs"
      })
    ]
  });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root2, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react10.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react10.createContext)(null);
var Root3 = (0, import_react10.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const connectWallet = (0, import_react10.useCallback)(() => {
      connect(wallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [connect, wallet.name, onConnect]);
    const isWalletReady = wallet.readyState === WalletReadyState.Installed || wallet.readyState === WalletReadyState.Loadable;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    if (!isWalletReady && isRedirectable() && !mobileSupport)
      return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime9.jsx)(WalletItemContext.Provider, {
      value: { wallet, connectWallet },
      children: (0, import_jsx_runtime9.jsx)(Component, {
        ref,
        className,
        children
      })
    });
  }
);
Root3.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root3, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});
export {
  APTOS_CONNECT_ACCOUNT_URL,
  APTOS_CONNECT_BASE_URL,
  APTOS_PRIVACY_POLICY_URL,
  AboutAptosConnect,
  AptosPrivacyPolicy,
  AptosWalletAdapterProvider,
  ChainIdToAnsSupportedNetworkMap,
  EXPLORE_ECOSYSTEM_URL,
  NetworkName2 as NetworkName,
  aptos_types_exports as TxnBuilderTypes,
  generated_exports as Types,
  WalletContext,
  WalletCore,
  WalletCoreV1,
  WalletItem,
  WalletReadyState,
  WalletStandardCore,
  areBCSArguments,
  convertNetwork,
  convertPayloadInputV1ToV2,
  convertV2PayloadToV1JSONPayload,
  convertV2TransactionPayloadToV1BCSPayload,
  fetchDevnetChainId,
  generalizedErrorMessage,
  generateTransactionPayloadFromV1Input,
  getAptosConfig,
  getAptosConnectWallets,
  getLocalStorage,
  groupAndSortWallets,
  handlePublishPackageTransaction,
  isAptosConnectWallet,
  isAptosLiveNetwork,
  isAptosNetwork,
  isInAppBrowser,
  isInstallRequired,
  isInstalledOrLoadable,
  isMobile,
  isRedirectable,
  partitionWallets,
  removeLocalStorage,
  scopePollingDetectionStrategy,
  setLocalStorage,
  truncateAddress,
  useWallet
};
//# sourceMappingURL=@aptos-labs_wallet-adapter-react.js.map
