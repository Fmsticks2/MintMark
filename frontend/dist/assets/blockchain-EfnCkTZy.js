var I=Object.defineProperty;var y=(n,t,e)=>t in n?I(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var o=(n,t,e)=>y(n,typeof t!="symbol"?t+"":t,e);import{M as R,W as C,s as f,e as O}from"./aptos-vendor-BkvCBlYo.js";import{Q as g}from"./vendor-i-3tIvdx.js";var i=(n=>(n.APTOS="aptos",n))(i||{}),w=(n=>(n[n.INDIVIDUAL=0]="INDIVIDUAL",n[n.SMALL_ORG=1]="SMALL_ORG",n[n.ENTERPRISE=2]="ENTERPRISE",n))(w||{});const T=class T{constructor(){o(this,"aptosWallets");o(this,"activeAptosWallet");o(this,"_isAptosConnected",!1);o(this,"_aptosAddress","");o(this,"_activeChainType",null);this.aptosWallets=new Map([["martian",new R],["petra",new g]])}static getInstance(){return T.instance||(T.instance=new T),T.instance}async connectAptos(t="martian"){try{if(this.activeAptosWallet=this.aptosWallets.get(t),!this.activeAptosWallet)throw new Error("No wallet selected");await this.activeAptosWallet.connect();const e=await this.activeAptosWallet.account();if(!e)throw new Error("No account found after connection");this._aptosAddress=e.address,this._isAptosConnected=!0,this._activeChainType=i.APTOS}catch(e){throw console.error("Failed to connect Aptos wallet:",e),this._isAptosConnected=!1,this._aptosAddress="",this._activeChainType=null,e}}async disconnectAptos(){try{this.activeAptosWallet&&this._isAptosConnected&&(await this.activeAptosWallet.disconnect(),this._aptosAddress="",this._isAptosConnected=!1,this.activeAptosWallet=void 0,this._activeChainType===i.APTOS&&(this._activeChainType=null))}catch(t){throw console.error("Failed to disconnect Aptos wallet:",t),t}}get activeChainType(){return this._activeChainType}get isAptosConnected(){return this._isAptosConnected}get aptosAddress(){return this._aptosAddress}getAptosWallet(){return this.activeAptosWallet}get isConnected(){return this._isAptosConnected}get address(){return this._aptosAddress}getWallet(){return this.activeAptosWallet}async connect(t="martian"){return this.connectAptos(t)}async disconnect(){return this.disconnectAptos()}};o(T,"instance");let _=T;const v=O.DEVNET,L=new f({network:v}),A=new C(L),r="0x69a158813efb20d7f134294ae114184cf6a12269a52106cb5e1d471e4761e4db",c="platform",u={INITIALIZE_PLATFORM:"initialize_platform",INITIALIZE_EVENT_PRICING:"initialize_event_pricing",REGISTER_ORGANIZATION:"register_organization",CREATE_EVENT:"create_event",MINT_POAP:"mint_poap",ADD_PARTICIPANT:"add_participant",GET_PLATFORM_CONFIG:"get_platform_config",GET_GUI_TOKEN_INFO:"get_gui_token_info",GET_EVENT_PRICING:"get_event_pricing",GET_EVENT:"get_event"},p={MINTING_FEE:100,ROYALTY_PERCENTAGE:5,PREMIUM_THRESHOLD:1e3,REWARD_RATE:50},a={INSUFFICIENT_BALANCE:"Insufficient GUI token balance",UNAUTHORIZED:"Unauthorized operation",COLLECTION_NOT_INITIALIZED:"Collection not initialized",TOKEN_ALREADY_MINTED:"Token already minted",INVALID_FEE:"Invalid fee percentage",TRANSACTION_FAILED:"Transaction failed",NETWORK_ERROR:"Network error",WALLET_NOT_CONNECTED:"Wallet not connected"},P=3e4,W=1e3;class h extends Error{constructor(t){super(t),this.name="TransactionError"}}const l=class l{constructor(){o(this,"walletManager");this.walletManager=_.getInstance()}static getInstance(){return l.instance||(l.instance=new l),l.instance}detectChainType(){return this.walletManager.activeChainType}async waitForAptosTransaction(t){const e=Date.now();for(;Date.now()-e<P;)try{const s=await A.getTransactionByHash({transactionHash:t});if(s.type==="user_transaction"){if(s.success)return;throw new h(a.TRANSACTION_FAILED)}await new Promise(E=>setTimeout(E,W))}catch(s){throw s instanceof h?s:new Error(a.NETWORK_ERROR)}throw new Error("Transaction timeout")}async executeAptosTransaction(t){try{if(!this.walletManager.isAptosConnected)throw new Error(a.WALLET_NOT_CONNECTED);const s=await this.walletManager.getAptosWallet().signAndSubmitTransaction(t);return await this.waitForAptosTransaction(s.hash),{success:!0,hash:s.hash}}catch(e){return console.error("Aptos transaction failed:",e),{success:!1,error:e instanceof Error?e.message:a.TRANSACTION_FAILED}}}async initializePlatform(){if(this.detectChainType()===i.APTOS){const e={type:"entry_function_payload",function:`${r}::${c}::${u.INITIALIZE_PLATFORM}`,type_arguments:[],arguments:[p.MINTING_FEE,p.ROYALTY_PERCENTAGE,p.PREMIUM_THRESHOLD,p.REWARD_RATE]};return this.executeAptosTransaction(e)}else return{success:!1,error:a.WALLET_NOT_CONNECTED}}async createEvent(t){if(this.detectChainType()===i.APTOS){const s={type:"entry_function_payload",function:`${r}::${c}::${u.CREATE_EVENT}`,type_arguments:[],arguments:[t.creator,t.name,t.organizationType,t.poapEnabled,t.maxAttendees,t.eventDate]};return this.executeAptosTransaction(s)}else return{success:!1,error:a.WALLET_NOT_CONNECTED}}async mintPOAP(t){if(this.detectChainType()===i.APTOS){const s={type:"entry_function_payload",function:`${r}::${c}::${u.MINT_POAP}`,type_arguments:[],arguments:[t.eventId,t.eventCreator]};return this.executeAptosTransaction(s)}else return{success:!1,error:a.WALLET_NOT_CONNECTED}}async getPlatformConfig(){try{return{success:!0,data:(await A.getAccountResource({accountAddress:r,resourceType:`${r}::${c}::PlatformConfig`})).data}}catch(t){return console.error("Failed to get platform config:",t),{success:!1,error:a.NETWORK_ERROR}}}async getGUITokenInfo(){try{return{success:!0,data:(await A.getAccountResource({accountAddress:r,resourceType:`${r}::${c}::GUIToken`})).data}}catch(t){return console.error("Failed to get GUI token info:",t),{success:!1,error:a.NETWORK_ERROR}}}async initializeEventPricing(t,e,s,E){if(this.detectChainType()===i.APTOS){const N={type:"entry_function_payload",function:`${r}::${c}::initialize_event_pricing`,type_arguments:[],arguments:[t,e,s,E]};return this.executeAptosTransaction(N)}else return{success:!1,error:a.WALLET_NOT_CONNECTED}}async addParticipant(t,e){if(this.detectChainType()===i.APTOS){const E={type:"entry_function_payload",function:`${r}::${c}::add_participant`,type_arguments:[],arguments:[t,e]};return this.executeAptosTransaction(E)}else return{success:!1,error:a.WALLET_NOT_CONNECTED}}async getEventPricing(){try{return{success:!0,data:await A.view({payload:{function:`${r}::${c}::${u.GET_EVENT_PRICING}`,functionArguments:[],typeArguments:[]}})}}catch(t){return console.error("Failed to get event pricing:",t),{success:!1,error:a.NETWORK_ERROR}}}async getEvent(t){try{return{success:!0,data:await A.view({payload:{function:`${r}::${c}::${u.GET_EVENT}`,functionArguments:[t],typeArguments:[]}})}}catch(e){return console.error("Failed to get event:",e),{success:!1,error:a.NETWORK_ERROR}}}};o(l,"instance");let d=l;export{d as C,w as O,_ as W};
